{"version":3,"file":"static/js/915.a80b6a27.chunk.js","mappings":"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","sources":["../../core/src/hooks/useQueryPersistedState.tsx","../../core/src/pipelines/PipelineReference.tsx","../../core/src/runs/RunStatuses.tsx","../../core/src/runs/RunsFilterInput.tsx","../../core/src/schedules/TimestampDisplay.tsx","../../ui/src/components/NonIdealState.tsx","../../ui/src/components/TokenizingField.tsx"],"sourcesContent":["import isEqual from 'lodash/isEqual';\nimport qs from 'qs';\nimport React from 'react';\nimport {useHistory, useLocation} from 'react-router-dom';\n\ntype QueryPersistedDataType =\n  | {[key: string]: any}\n  | Array<any>\n  | (string | undefined | number)\n  | (boolean | undefined)\n  | null;\n\nlet currentQueryString: {[key: string]: any} = {};\n\nexport type QueryPersistedStateConfig<T extends QueryPersistedDataType> = {\n  queryKey?: string;\n  defaults?: {[key: string]: any};\n  decode?: (raw: {[key: string]: any}) => T;\n  encode?: (raw: T) => {[key: string]: any};\n};\n\n/**\n * This goal of this hook is to make it easy to replace `React.useState` with a version\n * that persists the value to the page querystring so it is saved across page reload, etc.\n * Hopefully by making it easy, we'll do this often and improve overall UX.\n *\n * Examples:\n *\n * // Single (string | undefined) key saved to querystring with default value applied inline\n *\n * const [search = '', setSearch] = useQueryPersistedState({queryKey: 'q'})\n *\n * // Object saved to querystring with default values pre-filled\n * // Note: String and boolean values are automatically encoded / decoded, see below for others\n *\n * const [query, setQuery] = useQueryPersistedState<{cursor: string, filter: string}>({\n *   defaults: {cursor: '', filter: ''},\n * })\n *\n * // Custom transformer mapping to / from querystring representation (for our filter tokens)\n * // Note: `setIdeas` will be a different function on every render unless you memoize the options\n * // passed to the hook! Pull the encode/decode functions out into a file constant or use React.useRef\n *\n * const [ideas, setIdeas] = useQueryPersistedState<string[]>({\n *   encode: (ideas) => ({q: ideas.join(',')}),\n *   decode: ({q}) => (q || '').split(','),\n * })\n *\n * Note: if you combine encode/decode with defaults, the defaults are applied to the query\n * string BEFORE decoding.\n */\nexport function useQueryPersistedState<T extends QueryPersistedDataType>(\n  options: QueryPersistedStateConfig<T>,\n): [T, (updates: T) => void] {\n  const {queryKey, defaults} = options;\n  let {encode, decode} = options;\n\n  if (queryKey) {\n    // Just a short-hand way of providing encode/decode that go from qs object => string\n    if (!encode) {\n      encode = (raw: T) => ({[queryKey]: raw});\n    }\n    if (!decode) {\n      decode = (qs: {[key: string]: any}) => inferTypeOfQueryParam<T>(qs[queryKey]);\n    }\n  }\n\n  const location = useLocation();\n  const history = useHistory();\n\n  // We stash the query string into a ref so that the setter can operate on the /current/\n  // location even if the user retains it and calls it after other query string changes.\n  currentQueryString = qs.parse(location.search, {ignoreQueryPrefix: true});\n\n  const qsWithDefaults = {...(defaults || {}), ...currentQueryString};\n\n  // Note: If you have provided defaults and no encoder/decoder, the `value` exposed by\n  // useQueryPersistedState only includes those keys so other params don't leak into your value.\n  const qsDecoded = decode ? decode(qsWithDefaults) : inferTypeOfQueryParams<T>(qsWithDefaults);\n\n  // If `decode` yields a non-primitive type (eg: object or array), by default we yield\n  // an object with a new identity on every render. To prevent possible render loops caused by\n  // our value as a useEffect dependency, etc., we re-use the last yielded object if it isEqual.\n  const valueRef = React.useRef<T>(qsDecoded);\n  const onChangeRef = React.useCallback<(updated: T) => void>(\n    (updated: T) => {\n      const next = {\n        ...currentQueryString,\n        ...(encode ? encode(updated) : (updated as {[key: string]: any})),\n      };\n\n      // omit any keys that are equal to the defaults to keep URLs minimal\n      for (const [key, value] of Object.entries(next)) {\n        if (options.defaults && options.defaults[key] === value) {\n          delete next[key];\n        }\n      }\n\n      currentQueryString = next;\n      history.replace(`${location.pathname}?${qs.stringify(next, {arrayFormat: 'brackets'})}`);\n    },\n    [history, encode, location.pathname, options],\n  );\n\n  if (!isEqual(valueRef.current, qsDecoded)) {\n    valueRef.current = qsDecoded;\n  }\n  return [valueRef.current, onChangeRef];\n}\n\nfunction inferTypeOfQueryParam<T>(q: any): T {\n  return q === 'false' ? false : q === 'true' ? true : q;\n}\n\nfunction inferTypeOfQueryParams<T>(qs: {[key: string]: any}) {\n  const result: {[key: string]: any} = {};\n  for (const key of Object.keys(qs)) {\n    result[key] = inferTypeOfQueryParam<any>(qs[key]);\n  }\n  return result as T;\n}\n","import {Box, Colors, Icon} from '@dagster-io/ui';\nimport * as React from 'react';\nimport {Link} from 'react-router-dom';\n\nimport {RepoAddress} from '../workspace/types';\nimport {workspacePipelinePath, workspacePipelinePathGuessRepo} from '../workspace/workspacePath';\n\nimport {PipelineSnapshotLink} from './PipelinePathUtils';\n\nexport interface Props {\n  pipelineName: string;\n  pipelineHrefContext: 'repo-unknown' | RepoAddress | 'no-link';\n  isJob: boolean;\n  snapshotId?: string | null;\n  showIcon?: boolean;\n  truncationThreshold?: number;\n  size?: 'small' | 'normal';\n}\n\nconst DEFAULT_TRUNCATION_THRESHOLD = 40;\nconst TRUNCATION_BUFFER = 5;\n\nexport const PipelineReference: React.FC<Props> = ({\n  pipelineName,\n  pipelineHrefContext,\n  isJob,\n  snapshotId,\n  showIcon,\n  truncationThreshold = DEFAULT_TRUNCATION_THRESHOLD,\n  size = 'normal',\n}) => {\n  const truncatedName =\n    truncationThreshold > 0 && pipelineName.length > truncationThreshold\n      ? `${pipelineName.slice(0, truncationThreshold - TRUNCATION_BUFFER)}…`\n      : pipelineName;\n\n  const pipeline =\n    pipelineHrefContext === 'repo-unknown' ? (\n      <Link to={workspacePipelinePathGuessRepo(pipelineName, isJob)}>{truncatedName}</Link>\n    ) : pipelineHrefContext === 'no-link' ? (\n      <>{truncatedName}</>\n    ) : (\n      <Link\n        to={workspacePipelinePath({\n          repoName: pipelineHrefContext.name,\n          repoLocation: pipelineHrefContext.location,\n          pipelineName,\n          isJob,\n        })}\n      >\n        {truncatedName}\n      </Link>\n    );\n\n  return (\n    <Box flex={{direction: 'row', alignItems: 'center', display: 'inline-flex'}}>\n      {showIcon && (\n        <Box margin={{right: 8}}>\n          <Icon color={Colors.Gray400} name=\"job\" />\n        </Box>\n      )}\n      <span>\n        {pipeline}\n        {snapshotId && ' @ '}\n        {snapshotId && (\n          <PipelineSnapshotLink snapshotId={snapshotId} pipelineName={pipelineName} size={size} />\n        )}\n      </span>\n    </Box>\n  );\n};\n","import {RunStatus} from '../graphql/types';\n\nexport const queuedStatuses = new Set([RunStatus.QUEUED]);\n\nexport const inProgressStatuses = new Set([\n  RunStatus.STARTED,\n  RunStatus.STARTING,\n  RunStatus.CANCELING,\n]);\n\nexport const successStatuses = new Set([RunStatus.SUCCESS]);\nexport const failedStatuses = new Set([RunStatus.FAILURE, RunStatus.CANCELED]);\nexport const canceledStatuses = new Set([RunStatus.CANCELING, RunStatus.CANCELED]);\n\nexport const doneStatuses = new Set([RunStatus.FAILURE, RunStatus.SUCCESS, RunStatus.CANCELED]);\n\nexport const cancelableStatuses = new Set([RunStatus.QUEUED, RunStatus.STARTED]);\n","import {\n  SuggestionProvider,\n  TokenizingField,\n  TokenizingFieldValue,\n  tokensAsStringArray,\n  tokenizedValuesFromStringArray,\n} from '@dagster-io/ui';\nimport qs from 'qs';\nimport * as React from 'react';\n\nimport {RunsFilter, RunStatus} from '../graphql/types';\nimport {useQueryPersistedState} from '../hooks/useQueryPersistedState';\nimport {DagsterRepoOption, useRepositoryOptions} from '../workspace/WorkspaceContext';\n\nexport type RunFilterTokenType = 'id' | 'status' | 'pipeline' | 'job' | 'snapshotId' | 'tag';\n\nexport type RunFilterToken = {\n  token?: RunFilterTokenType;\n  value: string;\n};\n\nconst RUN_PROVIDERS_EMPTY = [\n  {\n    token: 'id',\n    values: () => [],\n  },\n  {\n    token: 'status',\n    values: () => [],\n  },\n  {\n    token: 'pipeline',\n    values: () => [],\n  },\n  {\n    token: 'job',\n    values: () => [],\n  },\n  {\n    token: 'tag',\n    values: () => [],\n  },\n  {\n    token: 'snapshotId',\n    values: () => [],\n  },\n];\n\n/**\n * This React hook provides run filtering state similar to React.useState(), but syncs\n * the value to the URL query string so that reloading the page / navigating \"back\"\n * maintains your view as expected.\n *\n * @param enabledFilters: This is useful if you want to ignore some filters that could\n * be provided (eg pipeline:, which is not relevant within pipeline scoped views.)\n */\nexport function useQueryPersistedRunFilters(enabledFilters?: RunFilterTokenType[]) {\n  return useQueryPersistedState<RunFilterToken[]>(\n    React.useMemo(\n      () => ({\n        encode: (tokens) => ({q: tokensAsStringArray(tokens), cursor: undefined}),\n        decode: ({q = []}) =>\n          tokenizedValuesFromStringArray(q, RUN_PROVIDERS_EMPTY).filter(\n            (t) =>\n              !t.token || !enabledFilters || enabledFilters.includes(t.token as RunFilterTokenType),\n          ) as RunFilterToken[],\n      }),\n      [enabledFilters],\n    ),\n  );\n}\n\nexport function runsPathWithFilters(filterTokens: RunFilterToken[]) {\n  return `/runs?${qs.stringify({q: tokensAsStringArray(filterTokens)}, {arrayFormat: 'brackets'})}`;\n}\n\nexport function runsFilterForSearchTokens(search: TokenizingFieldValue[]) {\n  if (!search[0]) {\n    return {};\n  }\n\n  const obj: RunsFilter = {};\n\n  for (const item of search) {\n    if (item.token === 'pipeline' || item.token === 'job') {\n      obj.pipelineName = item.value;\n    } else if (item.token === 'id') {\n      obj.runIds = obj.runIds || [];\n      obj.runIds.push(item.value);\n    } else if (item.token === 'status') {\n      obj.statuses = obj.statuses || [];\n      obj.statuses.push(item.value as RunStatus);\n    } else if (item.token === 'snapshotId') {\n      obj.snapshotId = item.value;\n    } else if (item.token === 'tag') {\n      const [key, value = ''] = item.value.split('=');\n      if (obj.tags) {\n        obj.tags.push({key, value});\n      } else {\n        obj.tags = [{key, value}];\n      }\n    }\n  }\n\n  return obj;\n}\n\nfunction searchSuggestionsForRuns(\n  repositoryOptions: DagsterRepoOption[],\n  enabledFilters?: RunFilterTokenType[],\n): SuggestionProvider[] {\n  const pipelineNames = new Set<string>();\n  const jobNames = new Set<string>();\n\n  for (const option of repositoryOptions) {\n    const {repository} = option;\n    for (const pipeline of repository.pipelines) {\n      if (pipeline.isJob) {\n        jobNames.add(pipeline.name);\n      } else {\n        pipelineNames.add(pipeline.name);\n      }\n    }\n  }\n\n  const suggestions: {token: RunFilterTokenType; values: () => string[]}[] = [\n    {\n      token: 'id',\n      values: () => [],\n    },\n    {\n      token: 'status',\n      values: () => Object.keys(RunStatus),\n    },\n    {\n      token: 'pipeline',\n      values: () => Array.from(pipelineNames),\n    },\n    {\n      token: 'job',\n      values: () => Array.from(jobNames),\n    },\n    {\n      token: 'tag',\n      values: () => [],\n    },\n    {\n      token: 'snapshotId',\n      values: () => [],\n    },\n  ];\n\n  if (enabledFilters) {\n    return suggestions.filter((x) => enabledFilters.includes(x.token));\n  }\n\n  return suggestions;\n}\n\ninterface RunsFilterInputProps {\n  loading?: boolean;\n  tokens: RunFilterToken[];\n  onChange: (tokens: RunFilterToken[]) => void;\n  enabledFilters?: RunFilterTokenType[];\n}\n\nexport const RunsFilterInput: React.FC<RunsFilterInputProps> = ({\n  loading,\n  tokens,\n  onChange,\n  enabledFilters,\n}) => {\n  const {options} = useRepositoryOptions();\n\n  const suggestions = searchSuggestionsForRuns(options, enabledFilters);\n\n  const search = tokenizedValuesFromStringArray(tokensAsStringArray(tokens), suggestions);\n\n  const suggestionProvidersFilter = (\n    suggestionProviders: SuggestionProvider[],\n    values: TokenizingFieldValue[],\n  ) => {\n    const tokens: string[] = [];\n    for (const {token} of values) {\n      if (token) {\n        tokens.push(token);\n      }\n    }\n\n    // If id is set, then no other filters can be set\n    if (tokens.includes('id')) {\n      return [];\n    }\n\n    // Can only have one filter value for pipeline or id\n    const limitedTokens = new Set<string>(['id', 'job', 'pipeline', 'snapshotId']);\n    const presentLimitedTokens = tokens.filter((token) => limitedTokens.has(token));\n\n    return suggestionProviders.filter(\n      (provider) => !provider.token || !presentLimitedTokens.includes(provider.token),\n    );\n  };\n\n  return (\n    <TokenizingField\n      values={search}\n      onChange={(values) => onChange(values as RunFilterToken[])}\n      suggestionProviders={suggestions}\n      suggestionProvidersFilter={suggestionProvidersFilter}\n      loading={loading}\n    />\n  );\n};\n","import {Colors, Icon, Tooltip} from '@dagster-io/ui';\nimport * as React from 'react';\nimport styled from 'styled-components/macro';\n\nimport {DEFAULT_TIME_FORMAT, TimeFormat} from '../app/time/TimestampFormat';\nimport {TimezoneContext} from '../app/time/TimezoneContext';\nimport {timestampToString} from '../app/time/timestampToString';\n\ninterface Props {\n  timestamp: number;\n  timezone?: string | null;\n  timeFormat?: TimeFormat;\n  tooltipTimeFormat?: TimeFormat;\n}\n\nexport const TimestampDisplay = (props: Props) => {\n  const {timestamp, timezone, timeFormat, tooltipTimeFormat} = props;\n  const [userTimezone] = React.useContext(TimezoneContext);\n  const locale = navigator.language;\n  const mainString = timestampToString({\n    timestamp: {unix: timestamp},\n    locale,\n    timezone: timezone || userTimezone,\n    timeFormat,\n  });\n\n  return (\n    <span>\n      <TabularNums style={{minWidth: 0}} title={mainString}>\n        {mainString}\n      </TabularNums>\n      {timezone && timezone !== userTimezone ? (\n        <TimestampTooltip\n          placement=\"top\"\n          content={\n            <TabularNums>\n              {timestampToString({\n                timestamp: {unix: timestamp},\n                locale,\n                timezone: userTimezone,\n                timeFormat: tooltipTimeFormat,\n              })}\n            </TabularNums>\n          }\n        >\n          <Icon name=\"schedule\" color={Colors.Gray400} size={12} />\n        </TimestampTooltip>\n      ) : null}\n    </span>\n  );\n};\n\nTimestampDisplay.defaultProps = {\n  timeFormat: DEFAULT_TIME_FORMAT,\n  tooltipTimeFormat: {showSeconds: false, showTimezone: true},\n};\n\nconst TabularNums = styled.span`\n  font-variant-numeric: tabular-nums;\n`;\n\nconst TimestampTooltip = styled(Tooltip)`\n  cursor: pointer;\n  position: relative;\n  top: 2px;\n  margin-left: 4px;\n`;\n","import * as React from 'react';\n\nimport {Box} from './Box';\nimport {Colors} from './Colors';\nimport {IconName, Icon} from './Icon';\nimport {Spinner} from './Spinner';\nimport {Subheading} from './Text';\n\nexport type NonIdealStateProps = React.DetailedHTMLProps<\n  React.InputHTMLAttributes<HTMLInputElement>,\n  HTMLInputElement\n> & {\n  icon: 'error' | 'no-results' | 'spinner' | IconName;\n  title: string;\n  description?: React.ReactNode;\n  action?: React.ReactNode;\n  shrinkable?: boolean;\n};\n\nexport const NonIdealState: React.FC<NonIdealStateProps> = ({\n  title,\n  description,\n  icon,\n  action,\n  shrinkable,\n}) => {\n  const singleContentElement = [title, description, action].filter(Boolean).length === 1;\n\n  return (\n    <Box\n      flex={{gap: 20, alignItems: singleContentElement ? 'center' : 'flex-start'}}\n      background={Colors.Gray50}\n      padding={24}\n      style={{\n        margin: 'auto',\n        borderRadius: 8,\n        width: shrinkable ? 'initial' : 'max-content',\n        maxWidth: 500,\n      }}\n    >\n      {icon === 'spinner' ? (\n        <Spinner purpose=\"section\" />\n      ) : icon === 'no-results' ? (\n        <Icon name=\"search\" size={48} color={Colors.Gray400} />\n      ) : (\n        <Icon name={icon} size={48} color={Colors.Gray400} />\n      )}\n      <Box\n        flex={{\n          gap: 8,\n          direction: 'column',\n          alignItems: 'flex-start',\n        }}\n      >\n        {title && <Subheading style={{color: Colors.Gray900}}>{title}</Subheading>}\n        {description && <div style={{color: Colors.Gray500}}>{description}</div>}\n        {action}\n      </Box>\n    </Box>\n  );\n};\n","// eslint-disable-next-line no-restricted-imports\nimport {TagInput} from '@blueprintjs/core';\nimport * as React from 'react';\nimport styled from 'styled-components/macro';\n\nimport {Box} from './Box';\nimport {Colors} from './Colors';\nimport {MenuItem, Menu} from './Menu';\nimport {Popover} from './Popover';\nimport {Spinner} from './Spinner';\n\nconst MAX_SUGGESTIONS = 100;\n\nexport interface SuggestionProvider {\n  token?: string;\n  values: () => string[];\n  suggestionFilter?: (query: string, suggestion: Suggestion) => boolean;\n}\n\nexport interface Suggestion {\n  text: string;\n  final: boolean;\n}\n\ninterface ActiveSuggestionInfo {\n  text: string;\n  idx: number;\n}\n\nexport interface TokenizingFieldValue {\n  token?: string;\n  value: string;\n}\n\ninterface TokenizingFieldProps {\n  values: TokenizingFieldValue[];\n  maxValues?: number;\n  onChange: (values: TokenizingFieldValue[]) => void;\n  onChangeBeforeCommit?: boolean;\n  addOnBlur?: boolean;\n  onFocus?: () => void;\n\n  placeholder?: string;\n  loading?: boolean;\n  className?: string;\n  small?: boolean;\n\n  fullwidth?: boolean;\n\n  suggestionProviders: SuggestionProvider[];\n  suggestionRenderer?: (suggestion: Suggestion) => React.ReactNode;\n  suggestionProvidersFilter?: (\n    suggestionProvider: SuggestionProvider[],\n    values: TokenizingFieldValue[],\n  ) => SuggestionProvider[];\n}\n\nfunction findProviderByToken(token: string, providers: SuggestionProvider[]) {\n  return providers.find((p) => p.token && p.token.toLowerCase() === token.toLowerCase());\n}\n\nexport const tokenizedValuesFromString = (str: string, providers: SuggestionProvider[]) => {\n  if (str === '') {\n    return [];\n  }\n  const tokens = str.split(',');\n  return tokenizedValuesFromStringArray(tokens, providers);\n};\n\nexport const tokenizedValuesFromStringArray = (tokens: string[], providers: SuggestionProvider[]) =>\n  tokens.map((token) => tokenizedValueFromString(token, providers));\n\nexport const tokenizeString = (str: string): [string, string] => {\n  const colonAt = str.indexOf(':');\n  if (colonAt === -1) {\n    return [str, ''];\n  }\n  return [str.slice(0, colonAt), str.slice(colonAt + 1)];\n};\n\nexport function tokenizedValueFromString(\n  str: string,\n  providers: SuggestionProvider[],\n): TokenizingFieldValue {\n  const [token, value] = tokenizeString(str);\n  if (findProviderByToken(token, providers)) {\n    if (token && value) {\n      return {token, value};\n    }\n  }\n\n  return {value: str};\n}\n\nexport const tokenToString = (v: TokenizingFieldValue) =>\n  v.token ? `${v.token}:${v.value}` : v.value;\n\nexport const tokensAsStringArray = (value: TokenizingFieldValue[]) =>\n  value.filter((v) => v.value !== '').map(tokenToString);\n\nexport const stringFromValue = (value: TokenizingFieldValue[]) =>\n  tokensAsStringArray(value).join(',');\n\nconst isEqual = (a: TokenizingFieldValue, b?: TokenizingFieldValue) =>\n  b && a.token === b.token && a.value === b.value;\n\n/** Provides a text field with typeahead autocompletion.\n *  This completion either provides a list of standalone tokens\n *  sourced from the `tokens` param, or a set of key value pairs,\n *  sourced from the `suggestionProviders` param. In the latter case, the\n *  key is one of a known set of \"suggestion provider tokens\".\n *\n *  Provide one or more SuggestionProviders or a list of tokens\n *  to build the tree of autocompletions.\n *\n *  The input also allows for freeform typing (`value` items with no token value) */\nexport const TokenizingField: React.FC<TokenizingFieldProps> = ({\n  suggestionProviders,\n  suggestionProvidersFilter,\n  values: externalValues,\n  maxValues,\n  onChange,\n  onChangeBeforeCommit,\n  onFocus,\n  placeholder,\n  addOnBlur,\n  loading,\n  className,\n  fullwidth,\n  suggestionRenderer,\n}) => {\n  const [open, setOpen] = React.useState<boolean>(false);\n  const [active, setActive] = React.useState<ActiveSuggestionInfo | null>(null);\n  const [typed, setTyped] = React.useState<string>('');\n\n  const values = React.useMemo(() => [...externalValues], [externalValues]);\n  const typedValue = tokenizedValueFromString(typed, suggestionProviders);\n  if (isEqual(typedValue, values[values.length - 1])) {\n    values.pop();\n  }\n\n  const atMaxValues = maxValues !== undefined && values.length >= maxValues;\n\n  const filteredSuggestionProviders = suggestionProvidersFilter\n    ? suggestionProvidersFilter(suggestionProviders, values)\n    : suggestionProviders;\n\n  // Build the set of suggestions that should be displayed for the current input value.\n  // Note: \"typed\" is the text that has not yet been submitted, separate from values[].\n  const parts = typed.split(':');\n  const lastPart = (parts[parts.length - 1] || '').toLowerCase();\n\n  const suggestions = React.useMemo(() => {\n    if (atMaxValues) {\n      return [];\n    }\n\n    let suggestionsArr: Suggestion[] = [];\n\n    const matchesTypedText = (query: string, s: Suggestion) =>\n      !query ||\n      s.text\n        .toLowerCase()\n        .split(':')\n        .some((c) => c.includes(query));\n\n    const availableSuggestionsForProvider = (provider: SuggestionProvider) => {\n      const suggestionNotUsed = (v: string) =>\n        !values.some((e) => e.token === provider.token && e.value === v);\n\n      const suggestionFilter = provider.suggestionFilter || matchesTypedText;\n\n      return provider\n        .values()\n        .filter(suggestionNotUsed)\n        .map((v) => ({text: provider?.token ? `${provider.token}:${v}` : v, final: true}))\n        .filter((s) => suggestionFilter(lastPart, s))\n        .slice(0, MAX_SUGGESTIONS); // never show too many suggestions for one provider\n    };\n\n    if (parts.length === 1) {\n      // Suggest providers (eg: `pipeline:`) so users can discover the search space\n\n      suggestionsArr = filteredSuggestionProviders\n        .reduce(\n          (accum: Suggestion[], s) =>\n            s.token ? [...accum, {text: `${s.token}:`, final: false}] : accum,\n          [],\n        )\n        .filter((s) => matchesTypedText(lastPart, s));\n\n      // Suggest value completions so users can type \"airline_\" without the \"pipeline\"\n      // prefix and get the correct suggestion.\n      for (const p of filteredSuggestionProviders) {\n        if (!p.token || typed.length > 0) {\n          suggestionsArr.push(...availableSuggestionsForProvider(p));\n        }\n      }\n    }\n\n    if (parts.length === 2) {\n      const firstPart = parts[0];\n      if (firstPart) {\n        // Suggest values from the chosen provider (eg: `pipeline:abc`)\n        const provider = findProviderByToken(firstPart, filteredSuggestionProviders);\n        suggestionsArr = provider ? availableSuggestionsForProvider(provider) : [];\n      }\n    }\n\n    // Truncate suggestions to the ones currently matching the typed text,\n    // and always sort them in alphabetical order.\n    suggestionsArr.sort((a, b) => a.text.localeCompare(b.text));\n\n    return suggestionsArr;\n  }, [atMaxValues, filteredSuggestionProviders, lastPart, parts, typed.length, values]);\n\n  // We need to manage selection in the dropdown by ourselves. To ensure the\n  // best behavior we store the active item's index and text (the text allows\n  // us to relocate it if it's moved and the index allows us to keep selection\n  // at the same location if the previous item is gone.)\n\n  // This hook keeps the active row state in sync with the suggestions, which\n  // are derived from the current input value.\n\n  React.useEffect(() => {\n    // If suggestions are present, autoselect the first one so the user can press\n    // enter to complete their search. (Esc + enter is how you enter your raw text.)\n    if (!active && suggestions.length) {\n      const item = suggestions[0];\n      if (item) {\n        setActive({text: item.text, idx: 0});\n      }\n      return;\n    }\n    if (!active) {\n      return;\n    }\n    if (suggestions.length === 0) {\n      setActive(null);\n      return;\n    }\n\n    // Relocate the currently active item in the latest suggestions list\n    const pos = suggestions.findIndex((a) => a.text === active.text);\n\n    // The new index is the index of the active item, or whatever item\n    // is now at it's location if it's gone, bounded to the array.\n    let nextIdx = pos !== -1 ? pos : active.idx;\n    nextIdx = Math.max(0, Math.min(suggestions.length - 1, nextIdx));\n    const nextItem = suggestions[nextIdx];\n\n    if (nextItem && (nextIdx !== active.idx || nextItem.text !== active.text)) {\n      setActive({text: nextItem.text, idx: nextIdx});\n    }\n  }, [active, suggestions]);\n\n  const onConfirmSuggestion = (suggestion: Suggestion) => {\n    if (atMaxValues) {\n      return;\n    }\n\n    if (suggestion.final) {\n      // The user has finished a key-value pair\n      onConfirmText(suggestion.text);\n      setTyped('');\n      setActive(null);\n      setOpen(false);\n    } else {\n      // The user has finished a key\n      setTyped(suggestion.text);\n    }\n  };\n\n  const onConfirmText = (str: string) => {\n    if (atMaxValues) {\n      return;\n    }\n    if (str.endsWith(':')) {\n      return;\n    }\n    if (str === '') {\n      return;\n    }\n\n    setTyped('');\n    onChange([...values, tokenizedValueFromString(str, filteredSuggestionProviders)]);\n  };\n\n  const onKeyDown = (e: React.KeyboardEvent<any>) => {\n    if (atMaxValues && e.key !== 'Delete' && e.key !== 'Backspace') {\n      e.preventDefault();\n      e.stopPropagation();\n      return;\n    }\n    // Enter and Return confirm the currently selected suggestion or\n    // confirm the freeform text you've typed if no suggestions are shown.\n    if (e.key === 'Enter' || e.key === 'Return' || e.key === 'Tab') {\n      if (active) {\n        const picked = suggestions.find((s) => s.text === active.text);\n        if (!picked) {\n          throw new Error('Selection out of sync with suggestions');\n        }\n        onConfirmSuggestion(picked);\n        e.preventDefault();\n        e.stopPropagation();\n      } else if (typed.length) {\n        onConfirmText(typed);\n        e.preventDefault();\n        e.stopPropagation();\n      }\n      return;\n    }\n\n    // Typing space confirms your freeform text\n    if (e.key === ' ') {\n      e.preventDefault();\n      onConfirmText(typed);\n      return;\n    }\n\n    // Escape closes the options. The options re-open if you type another char or click.\n    if (e.key === 'Escape') {\n      setActive(null);\n      setOpen(false);\n      return;\n    }\n\n    if (!open && e.key !== 'Delete' && e.key !== 'Backspace') {\n      setOpen(true);\n    }\n\n    // The up/down arrow keys shift selection in the dropdown.\n    // Note: The first down arrow press activates the first item.\n    const shift = {ArrowDown: 1, ArrowUp: -1}[e.key];\n    if (shift && suggestions.length > 0) {\n      e.preventDefault();\n      let idx = (active ? active.idx : -1) + shift;\n      idx = Math.max(0, Math.min(idx, suggestions.length - 1));\n      const item = suggestions[idx];\n      if (item) {\n        setActive({text: item.text, idx});\n      }\n    }\n  };\n\n  const menuRef = React.createRef<HTMLDivElement>();\n  React.useEffect(() => {\n    if (menuRef.current && active) {\n      const el = menuRef.current.querySelector(`[data-idx='${active.idx}']`);\n      if (el && el instanceof HTMLElement && 'scrollIntoView' in el) {\n        el.scrollIntoView({block: 'nearest'});\n      }\n    }\n  }, [menuRef, active]);\n\n  const renderSuggestion = suggestionRenderer || ((suggestion) => suggestion.text);\n\n  return (\n    <Popover\n      isOpen={open && suggestions.length > 0 && !atMaxValues}\n      position=\"bottom-left\"\n      content={\n        suggestions.length > 0 ? (\n          <div style={{maxHeight: 235, overflowY: 'scroll'}} ref={menuRef}>\n            <StyledMenu>\n              {suggestions.map((suggestion, idx) => (\n                <MenuItem\n                  data-idx={idx}\n                  key={suggestion.text}\n                  text={renderSuggestion(suggestion)}\n                  shouldDismissPopover={false}\n                  active={active?.idx === idx}\n                  onMouseDown={(e: React.MouseEvent<any>) => {\n                    e.preventDefault();\n                    e.stopPropagation();\n                    onConfirmSuggestion(suggestion);\n                    setActive(null);\n                  }}\n                />\n              ))}\n            </StyledMenu>\n          </div>\n        ) : (\n          <div />\n        )\n      }\n    >\n      <StyledTagInput\n        className={className}\n        values={values.map((v) => (v.token ? `${v.token}:${v.value}` : v.value))}\n        inputValue={typed}\n        onRemove={(_, idx) => {\n          const next = [...values];\n          next.splice(idx, 1);\n          onChange(next);\n        }}\n        onInputChange={(e) => {\n          setTyped(e.currentTarget.value);\n\n          if (onChangeBeforeCommit) {\n            const tokenized = tokenizedValueFromString(\n              e.currentTarget.value,\n              filteredSuggestionProviders,\n            );\n            onChange([...values, tokenized]);\n          }\n        }}\n        inputProps={{\n          onFocus: () => {\n            setOpen(true);\n            onFocus && onFocus();\n          },\n          onBlur: () => {\n            // Emulate behavior of addOnBlur for TagInput\n            // When a user clicks outside of the input, finish the current token\n            if (addOnBlur) {\n              onConfirmText(typed);\n            }\n            setOpen(false);\n          },\n        }}\n        $maxWidth={fullwidth ? '100%' : undefined}\n        onAdd={() => false}\n        onKeyDown={onKeyDown}\n        tagProps={{minimal: true}}\n        placeholder={placeholder || 'Filter…'}\n        rightElement={\n          loading && open ? (\n            <Box style={{alignSelf: 'center'}} margin={{right: 4}}>\n              <Spinner purpose=\"body-text\" />\n            </Box>\n          ) : undefined\n        }\n      />\n    </Popover>\n  );\n};\n\nexport const StyledTagInput = styled(TagInput)<{$maxWidth?: any}>`\n  border: none;\n  border-radius: 8px;\n  box-shadow: ${Colors.Gray300} inset 0px 0px 0px 1px, ${Colors.KeylineGray} inset 2px 2px 1.5px;\n  min-width: 400px;\n  max-width: ${(p) => (p.$maxWidth ? p.$maxWidth : '600px')};\n  transition: box-shadow 150ms;\n\n  &.bp3-active {\n    box-shadow: ${Colors.Gray300} inset 0px 0px 0px 1px, ${Colors.KeylineGray} inset 2px 2px 1.5px,\n      rgba(58, 151, 212, 0.6) 0 0 0 3px;\n  }\n\n  input {\n    font-size: 14px;\n    font-weight: 400;\n    padding-left: 4px;\n    padding-bottom: 2px;\n    padding-top: 2px;\n  }\n\n  && .bp3-tag-input-values:first-child .bp3-input-ghost:first-child {\n    padding-left: 8px;\n  }\n\n  && .bp3-tag-input-values {\n    margin-right: 4px;\n    margin-top: 4px;\n  }\n\n  && .bp3-tag-input-values > * {\n    margin-bottom: 4px;\n  }\n\n  .bp3-tag {\n    border-radius: 6px;\n    display: inline-flex;\n    flex-direction: row;\n    font-size: 12px;\n    line-height: 16px;\n    align-items: center;\n    max-width: 400px;\n    overflow: hidden;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n    padding: 4px 8px;\n    user-select: none;\n  }\n\n  .bp3-tag.bp3-minimal:not([class*='bp3-intent-']) {\n    background-color: ${Colors.Gray100};\n    color: ${Colors.Gray900};\n  }\n\n  .bp3-tag.bp3-minimal.bp3-intent-success {\n    background-color: ${Colors.Green50};\n    color: ${Colors.Green700};\n  }\n\n  .bp3-tag.bp3-minimal.bp3-intent-warning {\n    background-color: ${Colors.Yellow50};\n    color: ${Colors.Yellow700};\n  }\n\n  .bp3-tag.bp3-minimal.bp3-intent-danger {\n    background-color: ${Colors.Red50};\n    color: ${Colors.Red700};\n  }\n`;\n\nconst StyledMenu = styled(Menu)`\n  width: 400px;\n`;\n"],"names":["currentQueryString","useQueryPersistedState","options","queryKey","defaults","encode","decode","raw","qs","inferTypeOfQueryParam","location","useLocation","history","useHistory","search","ignoreQueryPrefix","qsWithDefaults","qsDecoded","result","Object","keys","key","inferTypeOfQueryParams","valueRef","React","onChangeRef","updated","next","entries","value","replace","pathname","arrayFormat","isEqual","current","q","PipelineReference","pipelineName","pipelineHrefContext","isJob","snapshotId","showIcon","truncationThreshold","size","truncatedName","length","slice","pipeline","to","workspacePipelinePathGuessRepo","workspacePipelinePath","repoName","name","repoLocation","flex","direction","alignItems","display","margin","right","color","Colors","queuedStatuses","Set","RunStatus","inProgressStatuses","successStatuses","failedStatuses","doneStatuses","cancelableStatuses","RUN_PROVIDERS_EMPTY","token","values","useQueryPersistedRunFilters","enabledFilters","tokens","tokensAsStringArray","cursor","undefined","tokenizedValuesFromStringArray","filter","t","includes","runsPathWithFilters","filterTokens","runsFilterForSearchTokens","obj","item","runIds","push","statuses","split","tags","RunsFilterInput","loading","onChange","suggestions","repositoryOptions","pipelineNames","jobNames","repository","pipelines","add","Array","from","x","searchSuggestionsForRuns","useRepositoryOptions","suggestionProviders","suggestionProvidersFilter","limitedTokens","presentLimitedTokens","has","provider","TimestampDisplay","props","timestamp","timezone","timeFormat","tooltipTimeFormat","TimezoneContext","userTimezone","locale","navigator","language","mainString","timestampToString","unix","TabularNums","style","minWidth","title","TimestampTooltip","placement","content","defaultProps","DEFAULT_TIME_FORMAT","showSeconds","showTimezone","styled","Tooltip","NonIdealState","description","icon","action","shrinkable","singleContentElement","Boolean","gap","background","padding","borderRadius","width","maxWidth","purpose","findProviderByToken","providers","find","p","toLowerCase","tokenizedValuesFromString","str","map","tokenizedValueFromString","colonAt","indexOf","tokenizeString","tokenToString","v","stringFromValue","join","TokenizingField","a","b","externalValues","maxValues","onChangeBeforeCommit","onFocus","placeholder","addOnBlur","className","fullwidth","suggestionRenderer","open","setOpen","active","setActive","typed","setTyped","typedValue","pop","atMaxValues","filteredSuggestionProviders","parts","lastPart","suggestionsArr","matchesTypedText","query","s","text","some","c","availableSuggestionsForProvider","suggestionFilter","e","final","reduce","accum","firstPart","sort","localeCompare","pos","findIndex","nextIdx","idx","Math","max","min","nextItem","onConfirmSuggestion","suggestion","onConfirmText","endsWith","menuRef","el","querySelector","HTMLElement","scrollIntoView","block","renderSuggestion","isOpen","position","maxHeight","overflowY","ref","StyledMenu","shouldDismissPopover","onMouseDown","preventDefault","stopPropagation","StyledTagInput","inputValue","onRemove","_","splice","onInputChange","currentTarget","tokenized","inputProps","onBlur","$maxWidth","onAdd","onKeyDown","shift","ArrowDown","ArrowUp","picked","Error","tagProps","minimal","rightElement","alignSelf","TagInput","Menu"],"sourceRoot":""}