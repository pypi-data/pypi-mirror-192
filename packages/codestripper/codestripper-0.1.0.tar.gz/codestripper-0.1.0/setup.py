# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['codestripper', 'codestripper.tags', 'codestripper.utils']

package_data = \
{'': ['*']}

setup_kwargs = {
    'name': 'codestripper',
    'version': '0.1.0',
    'description': '',
    'long_description': '# CodeStripper\n\nNew version of the CodeStripper that was previously used, which can be found at [https://github.com/sebivenlo/codestripper](https://github.com/sebivenlo/codestripper).\n\nThe reason for the switch is to not be dependent on Ant as a build system and the possibility to easily add more tags.\n\n## Available tags\n\n| Command | Tag(s) | Description |\n|-----|-------------|------------|\n| Add | `cs:add:<text>` |  Add the *text* (without the tag in front) |\n| Ignore | `cs:ignore` | Ignore the entire file, only valid on the first line |\n| Remove line | `cs:remove` | Remove the line |\n| Remove range | `cs:remove:start`/`cs:remove:end` | Remove all text in between tags |\n| Replace | `cs:replace:<replacement>` | Replace the text in front by the *replacement*, keeps whitespace |\n| Uncomment | `cs:uncomment:start`/`cs:uncomment:end` | Uncomment all lines in between tags |\n\n### Legacy\n\nTo support the old CodeStripper, the legacy tag `Start Solution::replacewith::`/`End Solution::replacewith::` is still supported for now. This tag does both the `Remove` and `Replace` in one go.\n\n\n## Command Line Properties\n\nCodeStripper can be used as a Python Module and as a command line tool. The command line tool has the following interface.\n\n| Flag | Long form | Description | Default value | Required |\n|----------|------|-------------|---------------|----------|\n| `<positional>` | None | files to include for code stripping (glob) | None | True |\n| -e | --exclude | files to exclude for code stripping (glob) | None | False |\n| -c | --comment | comment symbol(s) for the given language | // | False |\n| -o | --output | the output directory to store the stripped files | out | False |\n| -r | --recursive | do NOT use recursive globs for include/exclude | True | False |\n| -v | --verbosity | increase output verbosity | None | False |\n| -d | --dry | execute a dry run | False | False |\n| -w | --working-directory | set the working directory for include/exclude | pwd | False |\n\n## Examples\n\nThis section contains examples for all supported tags.\n\n### Add\n\nInput:\n```java\npublic class Test {\n    //cs:add:private final String test = "test";\n}\n```\n\nOutput:\n```java\npublic class Test {\n    private final String test = "test";\n}\n```\n\n### Ignore\n\nInput:\n```java\n//cs:ignore\npublic class Test {\n    private final String test = "test";\n}\n```\n\nOutput: No output, file is ignored\n\n### Remove line\n\nInput:\n```java\npublic class Test {\n    private final String test = "test";//cs:remove\n}\n```\n\nOutput:\n```java\npublic class Test {\n}\n```\n\n### Remove range\n\nInput:\n```java\npublic class Test {\n    //cs:remove:start\n    private final String test = "test";\n    private final int count = 0;\n    //cs:remove:end\n    private final boolean keep = true;\n}\n```\n\nOutput:\n```java\npublic class Test {\n    private final boolean keep = true;\n}\n```\n\n### Replace\n\nInput:\n```java\npublic class Test {\n    private final boolean keep = false;//cs:replace://TODO: add fields\n}\n```\n\nOutput:\n```java\npublic class Test {\n    //TODO: add fields\n}\n```\n\n### Uncomment\n\nInput:\n```java\npublic class Test {\n    //cs:uncomment:start\n    //private final String example = "example";\n    //private final boolean isTestCode = true;\n    //cs:uncomment:end\n}\n```\n\nOutput:\n```java\npublic class Test {\n    private final String example = "example";\n    private final boolean isTestCode = true;\n}\n```\n\n## Adding a new tag\n\nIt is possible to add custom tags. There a two types of tags: `SingleTag` that works on one line only and `RangeTag` that works on a range of lines. Tags are defined as follows:\n\n```mermaid\nclassDiagram\n    Tag <|-- SingleTag\n    SingleTag <|-- RangeOpenTag\n    SingleTag <|-- RangeCloseTag\n    Tag <|-- RangeTag\n    \n    class Tag{\n        <<Abstract>>\n        +offset: int\n        +start: int\n        +is_valid()*: bool\n        +execute()*: Optional[str]\n    }\n    class SingleTag{\n        +regex: str\n        +SingleTag(data: TagData)\n    }\n    class RangeOpenTag{\n        +RangeOpen(parent: Type, data: TagData)\n    }\n    class RangeCloseTag{\n        +RangeOpen(parent: Type, data: TagData)\n    }\n    class RangeTag{\n        +inset: int\n        +start: int\n        +end: int\n        +RangeTag(open_tag: RangeOpenTag, close_tag: RangeCloseTag)\n        +add_tags(tags: Iterable[Tag])\n    }\n```\nThe idea is that every tag has the following methods:\n\n- `is_valid`: whether the tag is valid\n- `execute`: handle the text for this tag\n\n`RangeTag` work in the following way:\n\n- `RangeOpenTag`: Specifies the open regex and handles the opening line. Defines the type of parent it belongs to (so that the tokenizer can match open and close tag)\n- `RangeCloseTag`: Specifies the close regex and handles the closing line. Defines the type of parent it belongs to (so that the tokenizer can match open and close tag)\n- `RangeTag`: Handles lines in between the open and close tag. Has access to both the open and close tag that were matched by the tokenizer.\n\nCreate a custom tag:\n\n1. Create a new file for your tag(s)\n2. Depending on if you create a `SingleTag` or `RangeTag`\n  - SingleTag:\n```python\nclass TestTag(SingleTag):\n    regex = r\'<regex>\' # Regex that should match the tag\n\n    def __init__(self, data: TagData) -> None:\n        super().__init__(data)\n\n    def execute(self, content: str) -> Optional[str]:\n        # Manipulate the line\n        # None means the line is removed\n    \n    def is_valid(self) -> bool:\n        # Return wether the tag is valid\n```\n\n  - RangeTag: Range needs a `RangeOpenTag`, `RangeCloseTag` and a `RangeTag`\n```python\nclass TestOpenTag(RangeOpenTag):\n    regex = r\'<regex>\' # Regex that should match the open tag\n\n    def __init__(self, data: TagData) -> None:\n        super().__init__(TestRangeTag, data)# Type of RangeTag is belong to\n\n    def execute(self, content: str) -> Optional[str]:\n        # Manipulate the line\n        # None means the line is removed\n    \n    def is_valid(self) -> bool:\n        # Return wether the tag is valid\n\nclass TestCloseTag(RangeCloseTag):\n    # Same as RangeOpenTag\n\nclass TestRangeTag(RangeTag):\n    regex = None # The matching is done based on open/close tag\n\n    def __init__(self, open_tag: RangeOpenTag, close_tag: RangeCloseTag):\n        super().__init__(open_tag, close_tag)\n\n    def execute(self, content: str) -> Union[str, None]:\n        # Manipulate lines between the tags\n```\n3. Add the new tag(s) to the `default_tags` in the `tokenizer`,\n```python\ndefault_tags: Set[Type[SingleTag]] = {\n    IgnoreFileTag,\n    RemoveOpenTag,\n    ...,\n    TestTag,\n    TestOpenTag\n}\n```\n> :warning: **Only the `SingleTag`(s) need to be added, not the `RangeTag`** ',
    'author': 'Bonajo',
    'author_email': 'm.bonajo@fontys.nl',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'None',
    'packages': packages,
    'package_data': package_data,
    'python_requires': '>=3.8,<4.0',
}


setup(**setup_kwargs)
