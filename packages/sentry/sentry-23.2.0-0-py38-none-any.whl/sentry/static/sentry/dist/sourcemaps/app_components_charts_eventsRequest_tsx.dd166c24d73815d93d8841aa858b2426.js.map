{"version":3,"file":"chunks/app_components_charts_eventsRequest_tsx.xxxxxxxxxxxxxxxxxxxx.js","mappings":"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","sources":["webpack:///./app/actionCreators/events.tsx","webpack:///./app/components/charts/eventsRequest.tsx","webpack:///./app/components/charts/loadingPanel.tsx","webpack:///./app/components/loadingMask.tsx","webpack:///./app/utils/getPeriod.tsx"],"sourcesContent":["import {UseMutationOptions, useQueryClient} from '@tanstack/react-query';\nimport {LocationDescriptor} from 'history';\nimport pick from 'lodash/pick';\n\nimport {addErrorMessage} from 'sentry/actionCreators/indicator';\nimport {Client, ResponseMeta} from 'sentry/api';\nimport {canIncludePreviousPeriod} from 'sentry/components/charts/utils';\nimport {t} from 'sentry/locale';\nimport {\n  DateString,\n  EventsStats,\n  IssueAttachment,\n  MultiSeriesEventsStats,\n  OrganizationSummary,\n} from 'sentry/types';\nimport {LocationQuery} from 'sentry/utils/discover/eventView';\nimport {getPeriod} from 'sentry/utils/getPeriod';\nimport {PERFORMANCE_URL_PARAM} from 'sentry/utils/performance/constants';\nimport {QueryBatching} from 'sentry/utils/performance/contexts/genericQueryBatcher';\nimport {QueryKey, useMutation, useQuery, UseQueryOptions} from 'sentry/utils/queryClient';\nimport RequestError from 'sentry/utils/requestError/requestError';\nimport useApi from 'sentry/utils/useApi';\nimport useOrganization from 'sentry/utils/useOrganization';\n\ntype Options = {\n  organization: OrganizationSummary;\n  partial: boolean;\n  comparisonDelta?: number;\n  end?: DateString;\n  environment?: Readonly<string[]>;\n  excludeOther?: boolean;\n  field?: string[];\n  generatePathname?: (org: OrganizationSummary) => string;\n  includePrevious?: boolean;\n  interval?: string;\n  limit?: number;\n  orderby?: string;\n  period?: string | null;\n  project?: Readonly<number[]>;\n  query?: string;\n  queryBatching?: QueryBatching;\n  queryExtras?: Record<string, string>;\n  referrer?: string;\n  start?: DateString;\n  team?: Readonly<string | string[]>;\n  topEvents?: number;\n  withoutZerofill?: boolean;\n  yAxis?: string | string[];\n};\n\n/**\n * Make requests to `events-stats` endpoint\n *\n * @param {Object} api API client instance\n * @param {Object} options Request parameters\n * @param {Object} options.organization Organization object\n * @param {Number[]} options.project List of project ids\n * @param {String[]} options.environment List of environments to query for\n * @param {Boolean} options.excludeOther Exclude the \"Other\" series when making a topEvents query\n * @param {String[]} options.team List of teams to query for\n * @param {String} options.period Time period to query for, in the format: <integer><units> where units are \"d\" or \"h\"\n * @param {String} options.interval Time interval to group results in, in the format: <integer><units> where units are \"d\", \"h\", \"m\", \"s\"\n * @param {Number} options.comparisonDelta Comparison delta for change alert event stats to include comparison stats\n * @param {Boolean} options.includePrevious Should request also return reqsults for previous period?\n * @param {Number} options.limit The number of rows to return\n * @param {String} options.query Search query\n * @param {QueryBatching} options.queryBatching A container for batching functions from a provider\n * @param {Record<string, string>} options.queryExtras A list of extra query parameters\n * @param {(org: OrganizationSummary) => string} options.generatePathname A function that returns an override for the pathname\n */\nexport const doEventsRequest = <IncludeAllArgsType extends boolean = false>(\n  api: Client,\n  {\n    organization,\n    project,\n    environment,\n    team,\n    period,\n    start,\n    end,\n    interval,\n    comparisonDelta,\n    includePrevious,\n    query,\n    yAxis,\n    field,\n    topEvents,\n    orderby,\n    partial,\n    withoutZerofill,\n    referrer,\n    queryBatching,\n    generatePathname,\n    queryExtras,\n    excludeOther,\n    includeAllArgs,\n  }: {includeAllArgs?: IncludeAllArgsType} & Options\n): IncludeAllArgsType extends true\n  ? Promise<\n      [EventsStats | MultiSeriesEventsStats, string | undefined, ResponseMeta | undefined]\n    >\n  : Promise<EventsStats | MultiSeriesEventsStats> => {\n  const pathname =\n    generatePathname?.(organization) ??\n    `/organizations/${organization.slug}/events-stats/`;\n\n  const shouldDoublePeriod = canIncludePreviousPeriod(includePrevious, period);\n  const urlQuery = Object.fromEntries(\n    Object.entries({\n      interval,\n      comparisonDelta,\n      project,\n      environment,\n      team,\n      query,\n      yAxis,\n      field,\n      topEvents,\n      orderby,\n      partial: partial ? '1' : undefined,\n      withoutZerofill: withoutZerofill ? '1' : undefined,\n      referrer: referrer ? referrer : 'api.organization-event-stats',\n      excludeOther: excludeOther ? '1' : undefined,\n    }).filter(([, value]) => typeof value !== 'undefined')\n  );\n\n  // Doubling period for absolute dates is not accurate unless starting and\n  // ending times are the same (at least for daily intervals). This is\n  // the tradeoff for now.\n  const periodObj = getPeriod({period, start, end}, {shouldDoublePeriod});\n\n  const queryObject = {\n    includeAllArgs,\n    query: {\n      ...urlQuery,\n      ...periodObj,\n      ...queryExtras,\n    },\n  };\n\n  if (queryBatching?.batchRequest) {\n    return queryBatching.batchRequest(api, pathname, queryObject);\n  }\n\n  return api.requestPromise<IncludeAllArgsType>(pathname, queryObject);\n};\n\nexport type EventQuery = {\n  field: string[];\n  query: string;\n  environment?: string[];\n  equation?: string[];\n  noPagination?: boolean;\n  per_page?: number;\n  project?: string | string[];\n  referrer?: string;\n  sort?: string | string[];\n  team?: string | string[];\n};\n\nexport type TagSegment = {\n  count: number;\n  name: string;\n  url: LocationDescriptor;\n  value: string;\n  isOther?: boolean;\n  key?: string;\n};\n\nexport type Tag = {\n  key: string;\n  topValues: Array<TagSegment>;\n};\n\n/**\n * Fetches tag facets for a query\n */\nexport function fetchTagFacets(\n  api: Client,\n  orgSlug: string,\n  query: EventQuery\n): Promise<Tag[]> {\n  const urlParams = pick(query, Object.values(PERFORMANCE_URL_PARAM));\n\n  const queryOption = {...urlParams, query: query.query};\n\n  return api.requestPromise(`/organizations/${orgSlug}/events-facets/`, {\n    query: queryOption,\n  });\n}\n\n/**\n * Fetches total count of events for a given query\n */\nexport function fetchTotalCount(\n  api: Client,\n  orgSlug: string,\n  query: EventQuery & LocationQuery\n): Promise<number> {\n  const urlParams = pick(query, Object.values(PERFORMANCE_URL_PARAM));\n\n  const queryOption = {...urlParams, query: query.query};\n\n  type Response = {\n    count: number;\n  };\n\n  return api\n    .requestPromise(`/organizations/${orgSlug}/events-meta/`, {\n      query: queryOption,\n    })\n    .then((res: Response) => res.count);\n}\n\ntype FetchEventAttachmentParameters = {\n  eventId: string;\n  orgSlug: string;\n  projectSlug: string;\n};\n\ntype FetchEventAttachmentResponse = IssueAttachment[];\n\nexport const makeFetchEventAttachmentsQueryKey = ({\n  orgSlug,\n  projectSlug,\n  eventId,\n}: FetchEventAttachmentParameters): QueryKey => [\n  `/projects/${orgSlug}/${projectSlug}/events/${eventId}/attachments/`,\n];\n\nexport const useFetchEventAttachments = (\n  {orgSlug, projectSlug, eventId}: FetchEventAttachmentParameters,\n  options: Partial<UseQueryOptions<FetchEventAttachmentResponse>> = {}\n) => {\n  const organization = useOrganization();\n  return useQuery<FetchEventAttachmentResponse>(\n    [`/projects/${orgSlug}/${projectSlug}/events/${eventId}/attachments/`],\n    {\n      staleTime: Infinity,\n      ...options,\n      enabled:\n        (organization.features?.includes('event-attachments') ?? false) &&\n        options.enabled !== false,\n    }\n  );\n};\n\ntype DeleteEventAttachmentVariables = {\n  attachmentId: string;\n  eventId: string;\n  orgSlug: string;\n  projectSlug: string;\n};\n\ntype DeleteEventAttachmentResponse = unknown;\n\ntype DeleteEventAttachmentContext = {\n  previous?: IssueAttachment[];\n};\n\ntype DeleteEventAttachmentOptions = UseMutationOptions<\n  DeleteEventAttachmentResponse,\n  RequestError,\n  DeleteEventAttachmentVariables,\n  DeleteEventAttachmentContext\n>;\n\nexport const useDeleteEventAttachmentOptimistic = (\n  incomingOptions: Partial<DeleteEventAttachmentOptions> = {}\n) => {\n  const api = useApi({persistInFlight: true});\n  const queryClient = useQueryClient();\n\n  const options: DeleteEventAttachmentOptions = {\n    ...incomingOptions,\n    mutationFn: ({orgSlug, projectSlug, eventId, attachmentId}) => {\n      return api.requestPromise(\n        `/projects/${orgSlug}/${projectSlug}/events/${eventId}/attachments/${attachmentId}/`,\n        {method: 'DELETE'}\n      );\n    },\n    onMutate: async variables => {\n      await queryClient.cancelQueries(makeFetchEventAttachmentsQueryKey(variables));\n\n      const previous = queryClient.getQueryData<FetchEventAttachmentResponse>(\n        makeFetchEventAttachmentsQueryKey(variables)\n      );\n\n      queryClient.setQueryData<FetchEventAttachmentResponse>(\n        makeFetchEventAttachmentsQueryKey(variables),\n        oldData => {\n          if (!Array.isArray(oldData)) {\n            return oldData;\n          }\n\n          return oldData.filter(attachment => attachment?.id !== variables.attachmentId);\n        }\n      );\n\n      incomingOptions.onMutate?.(variables);\n\n      return {previous};\n    },\n    onError: (error, variables, context) => {\n      addErrorMessage(t('An error occurred while deleting the attachment'));\n\n      if (context) {\n        queryClient.setQueryData(\n          makeFetchEventAttachmentsQueryKey(variables),\n          context.previous\n        );\n      }\n\n      incomingOptions.onError?.(error, variables, context);\n    },\n  };\n\n  return useMutation(options);\n};\n","import {PureComponent} from 'react';\nimport isEqual from 'lodash/isEqual';\nimport omitBy from 'lodash/omitBy';\n\nimport {doEventsRequest} from 'sentry/actionCreators/events';\nimport {addErrorMessage} from 'sentry/actionCreators/indicator';\nimport {Client} from 'sentry/api';\nimport LoadingPanel from 'sentry/components/charts/loadingPanel';\nimport {\n  canIncludePreviousPeriod,\n  getPreviousSeriesName,\n  isMultiSeriesStats,\n} from 'sentry/components/charts/utils';\nimport {t} from 'sentry/locale';\nimport {\n  DateString,\n  EventsStats,\n  EventsStatsData,\n  MultiSeriesEventsStats,\n  OrganizationSummary,\n} from 'sentry/types';\nimport {Series, SeriesDataUnit} from 'sentry/types/echarts';\nimport {defined} from 'sentry/utils';\nimport {DURATION_UNITS, SIZE_UNITS} from 'sentry/utils/discover/fieldRenderers';\nimport {\n  AggregationOutputType,\n  getAggregateAlias,\n  stripEquationPrefix,\n} from 'sentry/utils/discover/fields';\nimport {QueryBatching} from 'sentry/utils/performance/contexts/genericQueryBatcher';\n\nexport type TimeSeriesData = {\n  allTimeseriesData?: EventsStatsData;\n  comparisonTimeseriesData?: Series[];\n  originalPreviousTimeseriesData?: EventsStatsData | null;\n  originalTimeseriesData?: EventsStatsData;\n  previousTimeseriesData?: Series[] | null;\n  timeAggregatedData?: Series | {};\n  timeframe?: {end: number; start: number};\n  // timeseries data\n  timeseriesData?: Series[];\n  timeseriesResultsTypes?: Record<string, AggregationOutputType>;\n  timeseriesTotals?: {count: number};\n  yAxis?: string | string[];\n};\n\ntype LoadingStatus = {\n  /**\n   * Whether there was an error retrieving data\n   */\n  errored: boolean;\n  loading: boolean;\n  reloading: boolean;\n  errorMessage?: string;\n};\n\n// Can hold additional data from the root an events stat object (eg. start, end, order, isMetricsData).\ninterface AdditionalSeriesInfo {\n  isMetricsData?: boolean;\n}\n\nexport type RenderProps = LoadingStatus &\n  TimeSeriesData & {\n    results?: Series[]; // Chart with multiple series.\n    seriesAdditionalInfo?: Record<string, AdditionalSeriesInfo>;\n  };\n\ntype DefaultProps = {\n  /**\n   * Include data for previous period\n   */\n  includePrevious: boolean;\n  /**\n   * Transform the response data to be something ingestible by charts\n   */\n  includeTransformedData: boolean;\n  /**\n   * Interval to group results in\n   *\n   * e.g. 1d, 1h, 1m, 1s\n   */\n  interval: string;\n  /**\n   * number of rows to return\n   */\n  limit: number;\n  /**\n   * The query string to search events by\n   */\n  query: string;\n  /**\n   * Time delta for comparing intervals of alert metrics, in seconds\n   */\n  comparisonDelta?: number;\n  /**\n   * Absolute end date for query\n   */\n  end?: DateString;\n  /**\n   * Relative time period for query.\n   *\n   * Use `start` and `end` for absolute dates.\n   *\n   * e.g. 24h, 7d, 30d\n   */\n  period?: string | null;\n  /**\n   * Absolute start date for query\n   */\n  start?: DateString;\n};\n\ntype EventsRequestPartialProps = {\n  /**\n   * API client instance\n   */\n  api: Client;\n  children: (renderProps: RenderProps) => React.ReactNode;\n  organization: OrganizationSummary;\n  /**\n   * Whether or not to include the last partial bucket. This happens for example when the\n   * current time is 11:26 and the last bucket ranges from 11:25-11:30. This means that\n   * the last bucket contains 1 minute worth of data while the rest contains 5 minutes.\n   *\n   * This flag indicates whether or not this last bucket should be included in the result.\n   */\n  partial: boolean;\n  /**\n   * Discover needs confirmation to run >30 day >10 project queries,\n   * optional and when not passed confirmation is not required.\n   */\n  confirmedQuery?: boolean;\n  /**\n   * Name used for display current series dataset tooltip\n   */\n  currentSeriesNames?: string[];\n  /**\n   * Optional callback to further process raw events request response data\n   */\n  dataLoadedCallback?: (any: EventsStats | MultiSeriesEventsStats | null) => void;\n  /**\n   * List of environments to query\n   */\n  environment?: Readonly<string[]>;\n  /**\n   * Is query out of retention\n   */\n  expired?: boolean;\n  /**\n   * List of fields to group with when doing a topEvents request.\n   */\n  field?: string[];\n  /**\n   * Allows overriding the pathname.\n   */\n  generatePathname?: (org: OrganizationSummary) => string;\n  /**\n   * Hide error toast (used for pages which also query discover). Stops error appearing as a toast.\n   */\n  hideError?: boolean;\n  /**\n   * Initial loading state\n   */\n  loading?: boolean;\n  /**\n   * Query name used for displaying error toast if it is out of retention\n   */\n  name?: string;\n  /**\n   * A way to control error if error handling is not owned by the toast.\n   */\n  onError?: (error: string) => void;\n  /**\n   * How to order results when getting top events.\n   */\n  orderby?: string;\n  previousSeriesNames?: string[];\n  /**\n   * List of project ids to query\n   */\n  project?: Readonly<number[]>;\n  /**\n   * A container for query batching data and functions.\n   */\n  queryBatching?: QueryBatching;\n  /**\n   * Extra query parameters to be added.\n   */\n  queryExtras?: Record<string, string>;\n  /**\n   * A unique name for what's triggering this request, see organization_events_stats for an allowlist\n   */\n  referrer?: string;\n  /**\n   * Should loading be shown.\n   */\n  showLoading?: boolean;\n  /**\n   * List of team ids to query\n   */\n  team?: Readonly<string | string[]>;\n  /**\n   * The number of top results to get. When set a multi-series result will be returned\n   * in the `results` child render function.\n   */\n  topEvents?: number;\n  /**\n   * Whether or not to zerofill results\n   */\n  withoutZerofill?: boolean;\n  /**\n   * The yAxis being plotted. If multiple yAxis are requested,\n   * the child render function will be called with `results`\n   */\n  yAxis?: string | string[];\n};\n\ntype TimeAggregationProps =\n  | {includeTimeAggregation: true; timeAggregationSeriesName: string}\n  | {includeTimeAggregation?: false; timeAggregationSeriesName?: undefined};\n\nexport type EventsRequestProps = DefaultProps &\n  TimeAggregationProps &\n  EventsRequestPartialProps;\n\ntype EventsRequestState = {\n  errored: boolean;\n  fetchedWithPrevious: boolean;\n  reloading: boolean;\n  timeseriesData: null | EventsStats | MultiSeriesEventsStats;\n  errorMessage?: string;\n};\n\nconst propNamesToIgnore = [\n  'api',\n  'children',\n  'organization',\n  'loading',\n  'queryBatching',\n  'generatePathname',\n];\nconst omitIgnoredProps = (props: EventsRequestProps) =>\n  omitBy(props, (_value, key) => propNamesToIgnore.includes(key));\n\nclass EventsRequest extends PureComponent<EventsRequestProps, EventsRequestState> {\n  static defaultProps: DefaultProps = {\n    period: undefined,\n    start: null,\n    end: null,\n    interval: '1d',\n    comparisonDelta: undefined,\n    limit: 15,\n    query: '',\n    includePrevious: true,\n    includeTransformedData: true,\n  };\n\n  state: EventsRequestState = {\n    reloading: !!this.props.loading,\n    errored: false,\n    timeseriesData: null,\n    fetchedWithPrevious: false,\n  };\n\n  componentDidMount() {\n    this.fetchData();\n  }\n\n  componentDidUpdate(prevProps: EventsRequestProps) {\n    if (isEqual(omitIgnoredProps(prevProps), omitIgnoredProps(this.props))) {\n      return;\n    }\n    this.fetchData();\n  }\n\n  componentWillUnmount() {\n    this.unmounting = true;\n  }\n\n  private unmounting: boolean = false;\n\n  fetchData = async () => {\n    const {api, confirmedQuery, onError, expired, name, hideError, ...props} = this.props;\n    let timeseriesData: EventsStats | MultiSeriesEventsStats | null = null;\n\n    if (confirmedQuery === false) {\n      return;\n    }\n\n    this.setState(state => ({\n      reloading: state.timeseriesData !== null,\n      errored: false,\n      errorMessage: undefined,\n    }));\n\n    let errorMessage;\n    if (expired) {\n      errorMessage = t(\n        '%s has an invalid date range. Please try a more recent date range.',\n        name\n      );\n      addErrorMessage(errorMessage, {append: true});\n\n      this.setState({\n        errored: true,\n        errorMessage,\n      });\n    } else {\n      try {\n        api.clear();\n        timeseriesData = await doEventsRequest(api, props);\n      } catch (resp) {\n        if (resp && resp.responseJSON && resp.responseJSON.detail) {\n          errorMessage = resp.responseJSON.detail;\n        } else {\n          errorMessage = t('Error loading chart data');\n        }\n        if (!hideError) {\n          addErrorMessage(errorMessage);\n        }\n        if (onError) {\n          onError(errorMessage);\n        }\n        this.setState({\n          errored: true,\n          errorMessage,\n        });\n      }\n    }\n\n    if (this.unmounting) {\n      return;\n    }\n\n    this.setState({\n      reloading: false,\n      timeseriesData,\n      fetchedWithPrevious: props.includePrevious,\n    });\n    if (props.dataLoadedCallback) {\n      props.dataLoadedCallback(timeseriesData);\n    }\n  };\n\n  /**\n   * Retrieves dataset for the current period (since data can potentially\n   * contain previous period's data), as well as the previous period if\n   * possible.\n   *\n   * Returns `null` if data does not exist\n   */\n  getData = (\n    data: EventsStatsData = []\n  ): {current: EventsStatsData; previous: EventsStatsData | null} => {\n    const {fetchedWithPrevious} = this.state;\n    const {period, includePrevious} = this.props;\n\n    const hasPreviousPeriod =\n      fetchedWithPrevious || canIncludePreviousPeriod(includePrevious, period);\n    // Take the floor just in case, but data should always be divisible by 2\n    const dataMiddleIndex = Math.floor(data.length / 2);\n    return {\n      current: hasPreviousPeriod ? data.slice(dataMiddleIndex) : data,\n      previous: hasPreviousPeriod ? data.slice(0, dataMiddleIndex) : null,\n    };\n  };\n\n  // This aggregates all values per `timestamp`\n  calculateTotalsPerTimestamp(\n    data: EventsStatsData,\n    getName: (\n      timestamp: number,\n      countArray: {count: number}[],\n      i: number\n    ) => number = timestamp => timestamp * 1000\n  ): SeriesDataUnit[] {\n    return data.map(([timestamp, countArray], i) => ({\n      name: getName(timestamp, countArray, i),\n      value: countArray.reduce((acc, {count}) => acc + count, 0),\n    }));\n  }\n\n  /**\n   * Get previous period data, but transform timestamps so that data fits unto\n   * the current period's data axis\n   */\n  transformPreviousPeriodData(\n    current: EventsStatsData,\n    previous: EventsStatsData | null,\n    seriesName?: string\n  ): Series | null {\n    // Need the current period data array so we can take the timestamp\n    // so we can be sure the data lines up\n    if (!previous) {\n      return null;\n    }\n\n    return {\n      seriesName: seriesName ?? 'Previous',\n      data: this.calculateTotalsPerTimestamp(\n        previous,\n        (_timestamp, _countArray, i) => current[i][0] * 1000\n      ),\n      stack: 'previous',\n    };\n  }\n\n  /**\n   * Aggregate all counts for each time stamp\n   */\n  transformAggregatedTimeseries(data: EventsStatsData, seriesName: string = ''): Series {\n    return {\n      seriesName,\n      data: this.calculateTotalsPerTimestamp(data),\n    };\n  }\n\n  /**\n   * Transforms query response into timeseries data to be used in a chart\n   */\n  transformTimeseriesData(\n    data: EventsStatsData,\n    meta: EventsStats['meta'],\n    seriesName?: string\n  ): Series[] {\n    let scale = 1;\n    if (seriesName) {\n      const unit = meta?.units?.[getAggregateAlias(seriesName)];\n      // Scale series values to milliseconds or bytes depending on units from meta\n      scale = (unit && (DURATION_UNITS[unit] ?? SIZE_UNITS[unit])) ?? 1;\n    }\n\n    return [\n      {\n        seriesName: seriesName || 'Current',\n        data: data.map(([timestamp, countsForTimestamp]) => ({\n          name: timestamp * 1000,\n          value: countsForTimestamp.reduce((acc, {count}) => acc + count, 0) * scale,\n        })),\n      },\n    ];\n  }\n\n  /**\n   * Transforms comparisonCount in query response into timeseries data to be used in a comparison chart for change alerts\n   */\n  transformComparisonTimeseriesData(data: EventsStatsData): Series[] {\n    return [\n      {\n        seriesName: 'comparisonCount()',\n        data: data.map(([timestamp, countsForTimestamp]) => ({\n          name: timestamp * 1000,\n          value: countsForTimestamp.reduce(\n            (acc, {comparisonCount}) => acc + (comparisonCount ?? 0),\n            0\n          ),\n        })),\n      },\n    ];\n  }\n\n  processData(response: EventsStats, seriesIndex: number = 0, seriesName?: string) {\n    const {data, isMetricsData, totals, meta} = response;\n    const {\n      includeTransformedData,\n      includeTimeAggregation,\n      timeAggregationSeriesName,\n      currentSeriesNames,\n      previousSeriesNames,\n      comparisonDelta,\n    } = this.props;\n    const {current, previous} = this.getData(data);\n    const transformedData = includeTransformedData\n      ? this.transformTimeseriesData(\n          current,\n          meta,\n          seriesName ?? currentSeriesNames?.[seriesIndex]\n        )\n      : [];\n    const transformedComparisonData =\n      includeTransformedData && comparisonDelta\n        ? this.transformComparisonTimeseriesData(current)\n        : [];\n    const previousData = includeTransformedData\n      ? this.transformPreviousPeriodData(\n          current,\n          previous,\n          (seriesName ? getPreviousSeriesName(seriesName) : undefined) ??\n            previousSeriesNames?.[seriesIndex]\n        )\n      : null;\n    const timeAggregatedData = includeTimeAggregation\n      ? this.transformAggregatedTimeseries(current, timeAggregationSeriesName || '')\n      : {};\n    const timeframe =\n      response.start && response.end\n        ? !previous\n          ? {\n              start: response.start * 1000,\n              end: response.end * 1000,\n            }\n          : {\n              // Find the midpoint of start & end since previous includes 2x data\n              start: (response.start + response.end) * 500,\n              end: response.end * 1000,\n            }\n        : undefined;\n\n    const processedData = {\n      data: transformedData,\n      comparisonData: transformedComparisonData,\n      allData: data,\n      originalData: current,\n      totals,\n      isMetricsData,\n      originalPreviousData: previous,\n      previousData,\n      timeAggregatedData,\n      timeframe,\n    };\n\n    return processedData;\n  }\n\n  render() {\n    const {children, showLoading, ...props} = this.props;\n    const {topEvents, yAxis} = this.props;\n    const {timeseriesData, reloading, errored, errorMessage} = this.state;\n    // Is \"loading\" if data is null\n    const loading = this.props.loading || timeseriesData === null;\n\n    if (showLoading && loading) {\n      return <LoadingPanel data-test-id=\"events-request-loading\" />;\n    }\n    if (isMultiSeriesStats(timeseriesData, defined(topEvents))) {\n      // Convert multi-series results into chartable series. Multi series results\n      // are created when multiple yAxis are used or a topEvents request is made.\n      // Convert the timeseries data into a multi-series result set.\n      // As the server will have replied with a map like:\n      // {[titleString: string]: EventsStats}\n      let timeframe: {end: number; start: number} | undefined = undefined;\n      const seriesAdditionalInfo: Record<string, AdditionalSeriesInfo> = {};\n      const sortedTimeseriesData = Object.keys(timeseriesData)\n        .map(\n          (\n            seriesName: string,\n            index: number\n          ): [number, Series, Series | null, AdditionalSeriesInfo] => {\n            const seriesData: EventsStats = timeseriesData[seriesName];\n            const processedData = this.processData(\n              seriesData,\n              index,\n              stripEquationPrefix(seriesName)\n            );\n            if (!timeframe) {\n              timeframe = processedData.timeframe;\n            }\n            if (processedData.isMetricsData) {\n              seriesAdditionalInfo[seriesName] = {\n                isMetricsData: processedData.isMetricsData,\n              };\n            }\n            return [\n              seriesData.order || 0,\n              processedData.data[0],\n              processedData.previousData,\n              {isMetricsData: processedData.isMetricsData},\n            ];\n          }\n        )\n        .sort((a, b) => a[0] - b[0]);\n      const timeseriesResultsTypes: Record<string, AggregationOutputType> = {};\n      Object.keys(timeseriesData).forEach(key => {\n        const fieldsMeta = timeseriesData[key].meta?.fields[getAggregateAlias(key)];\n        if (fieldsMeta) {\n          timeseriesResultsTypes[key] = fieldsMeta;\n        }\n      });\n      const results: Series[] = sortedTimeseriesData.map(item => {\n        return item[1];\n      });\n      const previousTimeseriesData: Series[] | undefined = sortedTimeseriesData.some(\n        item => item[2] === null\n      )\n        ? undefined\n        : sortedTimeseriesData.map(item => {\n            return item[2] as Series;\n          });\n\n      return children({\n        loading,\n        reloading,\n        errored,\n        errorMessage,\n        results,\n        timeframe,\n        previousTimeseriesData,\n        seriesAdditionalInfo,\n        timeseriesResultsTypes,\n        // sometimes we want to reference props that were given to EventsRequest\n        ...props,\n      });\n    }\n    if (timeseriesData) {\n      const yAxisKey = yAxis && (typeof yAxis === 'string' ? yAxis : yAxis[0]);\n      const yAxisFieldType =\n        yAxisKey && timeseriesData.meta?.fields[getAggregateAlias(yAxisKey)];\n      const timeseriesResultsTypes = yAxisFieldType\n        ? {[yAxisKey]: yAxisFieldType}\n        : undefined;\n      const {\n        data: transformedTimeseriesData,\n        comparisonData: transformedComparisonTimeseriesData,\n        allData: allTimeseriesData,\n        originalData: originalTimeseriesData,\n        totals: timeseriesTotals,\n        originalPreviousData: originalPreviousTimeseriesData,\n        previousData: previousTimeseriesData,\n        timeAggregatedData,\n        timeframe,\n        isMetricsData,\n      } = this.processData(timeseriesData);\n\n      const seriesAdditionalInfo = {\n        [this.props.currentSeriesNames?.[0] ?? 'current']: {isMetricsData},\n      };\n\n      return children({\n        loading,\n        reloading,\n        errored,\n        errorMessage,\n        // meta data,\n        seriesAdditionalInfo,\n        // timeseries data\n        timeseriesData: transformedTimeseriesData,\n        comparisonTimeseriesData: transformedComparisonTimeseriesData,\n        allTimeseriesData,\n        originalTimeseriesData,\n        timeseriesTotals,\n        originalPreviousTimeseriesData,\n        previousTimeseriesData: previousTimeseriesData\n          ? [previousTimeseriesData]\n          : previousTimeseriesData,\n        timeAggregatedData,\n        timeframe,\n        timeseriesResultsTypes,\n        // sometimes we want to reference props that were given to EventsRequest\n        ...props,\n      });\n    }\n    return children({\n      loading,\n      reloading,\n      errored,\n      errorMessage,\n      ...props,\n    });\n  }\n}\nexport default EventsRequest;\n","import styled from '@emotion/styled';\n\nimport LoadingMask from 'sentry/components/loadingMask';\n\ninterface Props extends React.HTMLAttributes<HTMLDivElement> {\n  height?: string;\n}\n\nconst LoadingPanel = styled(({height: _height, ...props}: Props) => (\n  <div {...props}>\n    <LoadingMask />\n  </div>\n))`\n  flex: 1;\n  flex-shrink: 0;\n  overflow: hidden;\n  height: ${p => p.height};\n  position: relative;\n  border-color: transparent;\n  margin-bottom: 0;\n`;\n\nLoadingPanel.defaultProps = {\n  height: '200px',\n};\n\nexport default LoadingPanel;\n","import styled from '@emotion/styled';\n\nexport interface LoadingMaskProps extends React.HTMLAttributes<HTMLDivElement> {}\n\nconst LoadingMask = styled('div')<LoadingMaskProps>`\n  background-color: ${p => p.theme.backgroundSecondary};\n  border-radius: ${p => p.theme.borderRadius};\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n`;\n\nexport default LoadingMask;\n","import moment from 'moment';\n\nimport {DEFAULT_STATS_PERIOD} from 'sentry/constants';\nimport {DateString} from 'sentry/types';\nimport {getUtcDateString} from 'sentry/utils/dates';\n\ntype DateObject = {\n  /**\n   * Ending date object\n   */\n  end?: DateString;\n  /**\n   * Relative period string in format \"<int><unit>\" (e.g. 4d for 4 days)\n   */\n  period?: string | null;\n  /**\n   * Starting date object\n   */\n  start?: DateString;\n};\n\ntype Options = {\n  /**\n   * Doubles the given period (useful for getting previous period data)\n   */\n  shouldDoublePeriod?: boolean;\n};\n\n/**\n * Gets the period to query with if we need to double the initial period in order\n * to get data for the previous period\n *\n * Returns an object with either a period or start/end dates ({statsPeriod: string} or {start: string, end: string})\n */\nexport function getPeriod(\n  {period, start, end}: DateObject,\n  {shouldDoublePeriod}: Options = {}\n) {\n  if (!period && !start && !end) {\n    period = DEFAULT_STATS_PERIOD;\n  }\n\n  // you can not specify both relative and absolute periods\n  // relative period takes precedence\n  if (period) {\n    if (!shouldDoublePeriod) {\n      return {statsPeriod: period};\n    }\n    const [, periodNumber, periodLength] = period.match(/([0-9]+)([mhdw])/)!;\n\n    return {statsPeriod: `${parseInt(periodNumber, 10) * 2}${periodLength}`};\n  }\n\n  if (!start || !end) {\n    throw new Error('start and end required');\n  }\n\n  const formattedStart = getUtcDateString(start);\n  const formattedEnd = getUtcDateString(end);\n\n  if (shouldDoublePeriod) {\n    // get duration of end - start and double\n    const diff = moment(end).diff(moment(start));\n\n    const previousPeriodStart = moment(start).subtract(diff);\n\n    // This is not as accurate as having 2 start/end objs\n    return {\n      start: getUtcDateString(previousPeriodStart),\n      end: formattedEnd,\n    };\n  }\n\n  return {\n    start: formattedStart,\n    end: formattedEnd,\n  };\n}\n"],"names":["doEventsRequest","api","organization","project","environment","team","period","start","end","interval","comparisonDelta","includePrevious","query","yAxis","field","topEvents","orderby","partial","withoutZerofill","referrer","queryBatching","generatePathname","queryExtras","excludeOther","includeAllArgs","pathname","slug","shouldDoublePeriod","canIncludePreviousPeriod","queryObject","Object","fromEntries","entries","undefined","filter","value","getPeriod","batchRequest","requestPromise","fetchTagFacets","orgSlug","queryOption","pick","values","PERFORMANCE_URL_PARAM","fetchTotalCount","then","res","count","makeFetchEventAttachmentsQueryKey","projectSlug","eventId","useFetchEventAttachments","options","useOrganization","useQuery","staleTime","Infinity","enabled","features","includes","useDeleteEventAttachmentOptimistic","incomingOptions","useApi","persistInFlight","queryClient","useQueryClient","mutationFn","attachmentId","method","onMutate","async","cancelQueries","variables","previous","getQueryData","setQueryData","oldData","Array","isArray","attachment","id","onError","error","context","addErrorMessage","t","useMutation","propNamesToIgnore","omitIgnoredProps","props","omitBy","_value","key","EventsRequest","PureComponent","reloading","this","loading","errored","timeseriesData","fetchedWithPrevious","confirmedQuery","expired","name","hideError","errorMessage","setState","state","append","clear","resp","responseJSON","detail","unmounting","dataLoadedCallback","data","hasPreviousPeriod","dataMiddleIndex","Math","floor","length","current","slice","componentDidMount","fetchData","componentDidUpdate","prevProps","isEqual","componentWillUnmount","calculateTotalsPerTimestamp","getName","timestamp","map","i","countArray","reduce","acc","transformPreviousPeriodData","seriesName","_timestamp","_countArray","stack","transformAggregatedTimeseries","transformTimeseriesData","meta","scale","unit","units","getAggregateAlias","DURATION_UNITS","SIZE_UNITS","countsForTimestamp","transformComparisonTimeseriesData","comparisonCount","processData","response","seriesIndex","isMetricsData","totals","includeTransformedData","includeTimeAggregation","timeAggregationSeriesName","currentSeriesNames","previousSeriesNames","getData","comparisonData","allData","originalData","originalPreviousData","previousData","getPreviousSeriesName","timeAggregatedData","timeframe","render","children","showLoading","isMultiSeriesStats","defined","seriesAdditionalInfo","sortedTimeseriesData","keys","index","seriesData","processedData","stripEquationPrefix","order","sort","a","b","timeseriesResultsTypes","forEach","fieldsMeta","fields","results","item","previousTimeseriesData","some","yAxisKey","yAxisFieldType","transformedTimeseriesData","transformedComparisonTimeseriesData","allTimeseriesData","originalTimeseriesData","timeseriesTotals","originalPreviousTimeseriesData","comparisonTimeseriesData","limit","LoadingPanel","height","_height","p","defaultProps","theme","backgroundSecondary","borderRadius","DEFAULT_STATS_PERIOD","statsPeriod","periodNumber","periodLength","match","parseInt","Error","formattedStart","getUtcDateString","formattedEnd","diff","moment","previousPeriodStart","subtract"],"sourceRoot":""}