{"version":3,"file":"chunks/app_components_replays_replayPlayer_tsx-app_components_replays_replaysFeatureBadge_tsx-app_ut-8d4b7f.xxxxxxxxxxxxxxxxxxxx.js","mappings":"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","sources":["webpack:///./app/components/replays/player/bufferingOverlay.tsx","webpack:///./app/components/replays/player/fastForwardBadge.tsx","webpack:///./app/components/replays/playerDOMAlert.tsx","webpack:///./app/utils/useDismissAlert.tsx","webpack:///./app/components/replays/replayPlayer.tsx","webpack:///./app/components/replays/replaysFeatureBadge.tsx","webpack:///./app/utils/replays/replayReader.tsx","webpack:///./app/utils/replays/hooks/useReplayData.tsx","webpack:///./app/views/replays/detail/layout/fluidHeight.tsx"],"sourcesContent":["import styled from '@emotion/styled';\n\nimport {IconClock} from 'sentry/icons';\nimport {t} from 'sentry/locale';\nimport {space} from 'sentry/styles/space';\n\ntype Props = {\n  className?: string;\n};\n\nfunction BufferingOverlay({className}: Props) {\n  return (\n    <Overlay className={className}>\n      <Message>\n        <IconClock size=\"sm\" />\n        {t('Buffering...')}\n      </Message>\n    </Overlay>\n  );\n}\n\n/* Position the badge in the corner */\nconst Overlay = styled('div')`\n  user-select: none;\n  display: grid;\n  place-items: center;\n`;\n\n/* Badge layout and style */\nconst Message = styled('div')`\n  display: grid;\n  grid-template-columns: max-content max-content;\n  gap: ${space(0.75)};\n  place-items: center;\n\n  padding: ${space(3)};\n  background: ${p => p.theme.gray300};\n  border-radius: ${p => p.theme.borderRadius};\n  color: ${p => p.theme.white};\n  z-index: ${p => p.theme.zIndex.initial};\n`;\n\nexport default BufferingOverlay;\n","import styled from '@emotion/styled';\n\nimport {Tooltip} from 'sentry/components/tooltip';\nimport {IconArrow} from 'sentry/icons';\nimport {t} from 'sentry/locale';\nimport {space} from 'sentry/styles/space';\n\ntype Props = {\n  speed: number;\n  className?: string;\n};\n\nfunction FastForwardBadge({speed, className}: Props) {\n  return (\n    <Badge className={className}>\n      <FastForwardTooltip title={t('Fast forwarding at %sx', speed)}>\n        {t('Fast forwarding through inactivity')}\n        <IconArrow size=\"sm\" direction=\"right\" />\n      </FastForwardTooltip>\n    </Badge>\n  );\n}\n\n/* Position the badge in the corner */\nconst Badge = styled('div')`\n  user-select: none;\n  display: grid;\n  align-items: end;\n  justify-items: start;\n`;\n\n/* Badge layout and style */\nconst FastForwardTooltip = styled(Tooltip)`\n  display: grid;\n  grid-template-columns: max-content max-content;\n  gap: ${space(0.5)};\n  align-items: center;\n\n  background: ${p => p.theme.gray300};\n  color: ${p => p.theme.white};\n  padding: ${space(1.5)} ${space(2)};\n  border-top-right-radius: ${p => p.theme.borderRadius};\n  z-index: ${p => p.theme.zIndex.initial};\n`;\n\nexport default FastForwardBadge;\n","import styled from '@emotion/styled';\n\nimport {Button} from 'sentry/components/button';\nimport {IconClose, IconInfo} from 'sentry/icons';\nimport {t} from 'sentry/locale';\nimport {space} from 'sentry/styles/space';\nimport useDismissAlert from 'sentry/utils/useDismissAlert';\n\nconst LOCAL_STORAGE_KEY = 'replay-player-dom-alert-dismissed';\n\nfunction PlayerDOMAlert() {\n  const {dismiss, isDismissed} = useDismissAlert({key: LOCAL_STORAGE_KEY});\n\n  if (isDismissed) {\n    return null;\n  }\n\n  return (\n    <DOMAlertContainer data-test-id=\"player-dom-alert\">\n      <DOMAlert>\n        <IconInfo size=\"xs\" />\n        {t(\"Right click & inspect your app's DOM\")}\n        <DismissButton\n          priority=\"link\"\n          size=\"sm\"\n          icon={<IconClose size=\"xs\" />}\n          aria-label={t('Close Alert')}\n          onClick={dismiss}\n        />\n      </DOMAlert>\n    </DOMAlertContainer>\n  );\n}\n\nexport default PlayerDOMAlert;\n\nconst DOMAlertContainer = styled('div')`\n  position: absolute;\n  bottom: ${space(1)};\n  left: 0;\n  width: 100%;\n  text-align: center;\n  font-size: ${p => p.theme.fontSizeMedium};\n  pointer-events: none;\n`;\n\nconst DOMAlert = styled('div')`\n  display: inline-flex;\n  align-items: center;\n  justify-items: center;\n  padding: ${space(1)} ${space(2)};\n  margin: 0 ${space(1)};\n  color: ${p => p.theme.white};\n  background-color: ${p => p.theme.blue400};\n  border-radius: ${p => p.theme.borderRadius};\n  gap: 0 ${space(1)};\n  line-height: 0;\n`;\n\nconst DismissButton = styled(Button)`\n  color: ${p => p.theme.white};\n  pointer-events: all;\n  &:hover {\n    color: ${p => p.theme.white};\n    opacity: 0.5;\n  }\n`;\n","import {useCallback} from 'react';\n\nimport {useLocalStorageState} from 'sentry/utils/useLocalStorageState';\n\ntype Opts = {\n  /**\n   * Key in localStorage.\n   * Use a format like: `${organization.id}:my-feature`\n   */\n  key: string;\n\n  /**\n   * Number of days before the dismissal is expired.\n   * After expiration the the user will need to re-dismiss things.\n   */\n  expirationDays?: number;\n};\n\nconst MS_PER_DAY = 1000 * 60 * 60 * 24;\n\nfunction isValid(timestamp: number, expirationDays: number) {\n  if (!timestamp || isNaN(timestamp)) {\n    return false;\n  }\n  const duration = Date.now() - timestamp;\n  const days = duration / MS_PER_DAY;\n  return days < expirationDays;\n}\n\n/**\n * Nominally for tracking dismissal/acknowledgement of in-app alerts and\n * notifications, specifically those that don't need to be persisted server side.\n *\n * Dismissal can be 'permanent' or have an expiration after some number of days.\n *\n * The real lifecycle depends on whether users reset localStorage or not, if you\n * need something really permanent then save the users' preference to the server.\n */\nfunction useDismissAlert({expirationDays = Number.MAX_SAFE_INTEGER, key}: Opts) {\n  const [dismissedTimestamp, setDismissedTimestamp] = useLocalStorageState<\n    undefined | string\n  >(key, val => (val ? String(val) : undefined));\n\n  const isDismissed =\n    expirationDays === Number.MAX_SAFE_INTEGER\n      ? Boolean(dismissedTimestamp)\n      : isValid(Number(dismissedTimestamp), expirationDays);\n\n  const dismiss = useCallback(() => {\n    setDismissedTimestamp(Date.now().toString());\n  }, [setDismissedTimestamp]);\n\n  return {\n    isDismissed,\n    dismiss,\n  };\n}\n\nexport default useDismissAlert;\n","import {useCallback, useEffect, useRef, useState} from 'react';\nimport styled from '@emotion/styled';\nimport {useResizeObserver} from '@react-aria/utils';\n\nimport {Panel as _Panel} from 'sentry/components/panels';\nimport BufferingOverlay from 'sentry/components/replays/player/bufferingOverlay';\nimport FastForwardBadge from 'sentry/components/replays/player/fastForwardBadge';\nimport {useReplayContext} from 'sentry/components/replays/replayContext';\nimport trackAdvancedAnalyticsEvent from 'sentry/utils/analytics/trackAdvancedAnalyticsEvent';\nimport useOrganization from 'sentry/utils/useOrganization';\n\nimport PlayerDOMAlert from './playerDOMAlert';\n\ntype Dimensions = ReturnType<typeof useReplayContext>['dimensions'];\n\ninterface Props {\n  className?: string;\n  isPreview?: boolean;\n}\n\nfunction useVideoSizeLogger({\n  videoDimensions,\n  windowDimensions,\n}: {\n  videoDimensions: Dimensions;\n  windowDimensions: Dimensions;\n}) {\n  const organization = useOrganization();\n  const [didLog, setDidLog] = useState<boolean>(false);\n  useEffect(() => {\n    if (didLog || (videoDimensions.width === 0 && videoDimensions.height === 0)) {\n      return;\n    }\n\n    const aspect_ratio =\n      videoDimensions.width > videoDimensions.height ? 'landscape' : 'portrait';\n\n    const scale = Math.min(\n      windowDimensions.width / videoDimensions.width,\n      windowDimensions.height / videoDimensions.height,\n      1\n    );\n    const scale_bucket = (Math.floor(scale * 10) * 10) as Parameters<\n      typeof trackAdvancedAnalyticsEvent<'replay.render-player'>\n    >[1]['scale_bucket'];\n\n    trackAdvancedAnalyticsEvent('replay.render-player', {\n      organization,\n      aspect_ratio,\n      scale_bucket,\n    });\n    setDidLog(true);\n  }, [organization, windowDimensions, videoDimensions, didLog]);\n}\n\nfunction BasePlayerRoot({className, isPreview = false}: Props) {\n  const {\n    initRoot,\n    dimensions: videoDimensions,\n    fastForwardSpeed,\n    isBuffering,\n  } = useReplayContext();\n\n  const windowEl = useRef<HTMLDivElement>(null);\n  const viewEl = useRef<HTMLDivElement>(null);\n\n  const [windowDimensions, setWindowDimensions] = useState<Dimensions>({\n    width: 0,\n    height: 0,\n  });\n\n  useVideoSizeLogger({videoDimensions, windowDimensions});\n\n  // Create the `rrweb` instance which creates an iframe inside `viewEl`\n  useEffect(() => initRoot(viewEl.current), [initRoot]);\n\n  // Read the initial width & height where the player will be inserted, this is\n  // so we can shrink the video into the available space.\n  // If the size of the container changes, we can re-calculate the scaling factor\n  const updateWindowDimensions = useCallback(\n    () =>\n      setWindowDimensions({\n        width: windowEl.current?.clientWidth || 0,\n        height: windowEl.current?.clientHeight || 0,\n      }),\n    [setWindowDimensions]\n  );\n  useResizeObserver({ref: windowEl, onResize: updateWindowDimensions});\n  // If your browser doesn't have ResizeObserver then set the size once.\n  useEffect(() => {\n    if (typeof window.ResizeObserver !== 'undefined') {\n      return;\n    }\n    updateWindowDimensions();\n  }, [updateWindowDimensions]);\n\n  // Update the scale of the view whenever dimensions have changed.\n  useEffect(() => {\n    if (viewEl.current) {\n      const scale = Math.min(\n        windowDimensions.width / videoDimensions.width,\n        windowDimensions.height / videoDimensions.height,\n        1\n      );\n      if (scale) {\n        viewEl.current.style['transform-origin'] = 'top left';\n        viewEl.current.style.transform = `scale(${scale})`;\n        viewEl.current.style.width = `${videoDimensions.width * scale}px`;\n        viewEl.current.style.height = `${videoDimensions.height * scale}px`;\n      }\n    }\n  }, [windowDimensions, videoDimensions]);\n\n  return (\n    <SizingWindow ref={windowEl} className=\"sentry-block\">\n      <div ref={viewEl} className={className} />\n      {fastForwardSpeed ? <PositionedFastForward speed={fastForwardSpeed} /> : null}\n      {isBuffering ? <PositionedBuffering /> : null}\n      {!isPreview ? <PlayerDOMAlert /> : null}\n    </SizingWindow>\n  );\n}\n\n// Center the viewEl inside the windowEl.\n// This is useful when the window is inside a container that has large fixed\n// dimensions, like when in fullscreen mode.\n// If the container has a dimensions that can grow/shrink then it is\n// important to also set `overflow: hidden` on the container, so that the\n// SizingWindow can calculate size as things shrink.\nconst SizingWindow = styled('div')`\n  width: 100%;\n  display: flex;\n  flex-grow: 1;\n  justify-content: center;\n  align-items: center;\n  position: relative;\n  overflow: hidden;\n\n  background-color: ${p => p.theme.backgroundSecondary};\n  background-image: repeating-linear-gradient(\n      -145deg,\n      transparent,\n      transparent 8px,\n      ${p => p.theme.backgroundSecondary} 8px,\n      ${p => p.theme.backgroundSecondary} 11px\n    ),\n    repeating-linear-gradient(\n      -45deg,\n      transparent,\n      transparent 15px,\n      ${p => p.theme.gray100} 15px,\n      ${p => p.theme.gray100} 16px\n    );\n`;\n\nconst PositionedFastForward = styled(FastForwardBadge)`\n  position: absolute;\n  left: 0;\n  bottom: 0;\n`;\n\nconst PositionedBuffering = styled(BufferingOverlay)`\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n`;\n\n// Base styles, to make the Replayer instance work\nconst PlayerRoot = styled(BasePlayerRoot)`\n  .replayer-wrapper {\n    user-select: none;\n  }\n\n  .replayer-wrapper > .replayer-mouse {\n    pointer-events: none;\n  }\n  .replayer-wrapper > .replayer-mouse-tail {\n    position: absolute;\n    pointer-events: none;\n  }\n\n  /* Override default user-agent styles */\n  .replayer-wrapper > iframe {\n    border: none;\n    background: white;\n\n    /* Set pointer-events to make it easier to right-click & inspect */\n    pointer-events: initial !important;\n  }\n`;\n\n// Sentry-specific styles for the player.\n// The elements we have to work with are:\n// ```css\n// div.replayer-wrapper {}\n// div.replayer-wrapper > div.replayer-mouse {}\n// div.replayer-wrapper > canvas.replayer-mouse-tail {}\n// div.replayer-wrapper > iframe {}\n// ```\n// The mouse-tail is also configured for color/size in `app/components/replays/replayContext.tsx`\nconst SentryPlayerRoot = styled(PlayerRoot)`\n  .replayer-mouse {\n    position: absolute;\n    width: 32px;\n    height: 32px;\n    transition: left 0.05s linear, top 0.05s linear;\n    background-size: contain;\n    background-repeat: no-repeat;\n    background-image: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTkiIHZpZXdCb3g9IjAgMCAxMiAxOSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTAgMTZWMEwxMS42IDExLjZINC44TDQuNCAxMS43TDAgMTZaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNOS4xIDE2LjdMNS41IDE4LjJMMC43OTk5OTkgNy4xTDQuNSA1LjZMOS4xIDE2LjdaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNNC42NzQ1MSA4LjYxODUxTDIuODMwMzEgOS4zOTI3MUw1LjkyNzExIDE2Ljc2OTVMNy43NzEzMSAxNS45OTUzTDQuNjc0NTEgOC42MTg1MVoiIGZpbGw9ImJsYWNrIi8+CjxwYXRoIGQ9Ik0xIDIuNFYxMy42TDQgMTAuN0w0LjQgMTAuNkg5LjJMMSAyLjRaIiBmaWxsPSJibGFjayIvPgo8L3N2Zz4K');\n    border-color: transparent;\n  }\n  .replayer-mouse:after {\n    content: '';\n    display: inline-block;\n    width: 32px;\n    height: 32px;\n    background: ${p => p.theme.purple300};\n    border-radius: 100%;\n    transform: translate(-50%, -50%);\n    opacity: 0.3;\n  }\n  .replayer-mouse.active:after {\n    animation: click 0.2s ease-in-out 1;\n  }\n  .replayer-mouse.touch-device {\n    background-image: none;\n    width: 70px;\n    height: 70px;\n    border-radius: 100%;\n    margin-left: -37px;\n    margin-top: -37px;\n    border: 4px solid rgba(73, 80, 246, 0);\n    transition: left 0s linear, top 0s linear, border-color 0.2s ease-in-out;\n  }\n  .replayer-mouse.touch-device.touch-active {\n    border-color: ${p => p.theme.purple200};\n    transition: left 0.25s linear, top 0.25s linear, border-color 0.2s ease-in-out;\n  }\n  .replayer-mouse.touch-device:after {\n    opacity: 0;\n  }\n  .replayer-mouse.touch-device.active:after {\n    animation: touch-click 0.2s ease-in-out 1;\n  }\n  @keyframes click {\n    0% {\n      opacity: 0.3;\n      width: 20px;\n      height: 20px;\n    }\n    50% {\n      opacity: 0.5;\n      width: 10px;\n      height: 10px;\n    }\n  }\n  @keyframes touch-click {\n    0% {\n      opacity: 0;\n      width: 20px;\n      height: 20px;\n    }\n    50% {\n      opacity: 0.5;\n      width: 10px;\n      height: 10px;\n    }\n  }\n`;\n\nexport default SentryPlayerRoot;\n","import FeatureBadge from 'sentry/components/featureBadge';\nimport useOrganization from 'sentry/utils/useOrganization';\n\nfunction ReplaysFeatureBadge(\n  props: Omit<React.ComponentProps<typeof FeatureBadge>, 'type'>\n) {\n  // TODO(replay): Remove this special-case for our internal demo org\n  const organization = useOrganization();\n  if (organization.slug === 'testorg-az') {\n    return null;\n  }\n  return <FeatureBadge {...props} type=\"new\" />;\n}\n\nexport default ReplaysFeatureBadge;\n","import {duration} from 'moment';\n\nimport type {Crumb} from 'sentry/types/breadcrumbs';\nimport {\n  breadcrumbFactory,\n  getBreadcrumbsByCategory,\n  isMemorySpan,\n  isNetworkSpan,\n  mapRRWebAttachments,\n  replayTimestamps,\n  rrwebEventListFactory,\n  spansFactory,\n} from 'sentry/utils/replays/replayDataUtils';\nimport type {\n  MemorySpanType,\n  RecordingEvent,\n  ReplayError,\n  ReplayRecord,\n  ReplaySpan,\n} from 'sentry/views/replays/types';\n\ninterface ReplayReaderParams {\n  /**\n   * Loaded segment data\n   *\n   * This is a mix of rrweb data, breadcrumbs and spans/transactions sorted by time\n   * All three types are mixed together.\n   */\n  attachments: unknown[] | undefined;\n  errors: ReplayError[] | undefined;\n\n  /**\n   * The root Replay event, created at the start of the browser session.\n   */\n  replayRecord: ReplayRecord | undefined;\n}\n\ntype RequiredNotNull<T> = {\n  [P in keyof T]: NonNullable<T[P]>;\n};\n\nexport default class ReplayReader {\n  static factory({attachments, replayRecord, errors}: ReplayReaderParams) {\n    if (!attachments || !replayRecord || !errors) {\n      return null;\n    }\n\n    return new ReplayReader({attachments, replayRecord, errors});\n  }\n\n  private constructor({\n    attachments,\n    replayRecord,\n    errors,\n  }: RequiredNotNull<ReplayReaderParams>) {\n    const {breadcrumbs, rrwebEvents, spans} = mapRRWebAttachments(attachments);\n\n    // TODO(replays): We should get correct timestamps from the backend instead\n    // of having to fix them up here.\n    const {startTimestampMs, endTimestampMs} = replayTimestamps(\n      replayRecord,\n      rrwebEvents,\n      breadcrumbs,\n      spans\n    );\n    replayRecord.started_at = new Date(startTimestampMs);\n    replayRecord.finished_at = new Date(endTimestampMs);\n    replayRecord.duration = duration(\n      replayRecord.finished_at.getTime() - replayRecord.started_at.getTime()\n    );\n\n    const sortedSpans = spansFactory(spans);\n    this.networkSpans = sortedSpans.filter(isNetworkSpan);\n    this.memorySpans = sortedSpans.filter(isMemorySpan);\n\n    this.breadcrumbs = breadcrumbFactory(replayRecord, errors, breadcrumbs, sortedSpans);\n    this.consoleCrumbs = getBreadcrumbsByCategory(this.breadcrumbs, ['console', 'issue']);\n\n    this.rrwebEvents = rrwebEventListFactory(replayRecord, rrwebEvents);\n\n    this.replayRecord = replayRecord;\n  }\n\n  private replayRecord: ReplayRecord;\n  private rrwebEvents: RecordingEvent[];\n  private breadcrumbs: Crumb[];\n  private consoleCrumbs: ReturnType<typeof getBreadcrumbsByCategory>;\n  private networkSpans: ReplaySpan[];\n  private memorySpans: MemorySpanType[];\n\n  /**\n   * @returns Duration of Replay (milliseonds)\n   */\n  getDurationMs = () => {\n    return this.replayRecord.duration.asMilliseconds();\n  };\n\n  getReplay = () => {\n    return this.replayRecord;\n  };\n\n  getRRWebEvents = () => {\n    return this.rrwebEvents;\n  };\n\n  getRawCrumbs = () => {\n    return this.breadcrumbs;\n  };\n\n  getConsoleCrumbs = () => {\n    return this.consoleCrumbs;\n  };\n\n  getNetworkSpans = () => {\n    return this.networkSpans;\n  };\n\n  getMemorySpans = () => {\n    return this.memorySpans;\n  };\n}\n","import {useCallback, useEffect, useMemo, useState} from 'react';\nimport * as Sentry from '@sentry/react';\nimport chunk from 'lodash/chunk';\n\nimport parseLinkHeader, {ParsedHeader} from 'sentry/utils/parseLinkHeader';\nimport {mapResponseToReplayRecord} from 'sentry/utils/replays/replayDataUtils';\nimport ReplayReader from 'sentry/utils/replays/replayReader';\nimport RequestError from 'sentry/utils/requestError/requestError';\nimport useApi from 'sentry/utils/useApi';\nimport type {ReplayError, ReplayRecord} from 'sentry/views/replays/types';\n\nconst SEGMENTS_PER_PAGE = 50; // p95 is 44 segments\nconst ERRORS_PER_PAGE = 50; // Need to make sure the url is not too large\n\ntype State = {\n  attachments: undefined | unknown[];\n\n  /**\n   * List of errors that occurred during replay\n   */\n  errors: undefined | ReplayError[];\n\n  /**\n   * If any request returned an error then nothing is being returned\n   */\n  fetchError: undefined | RequestError;\n\n  /**\n   * If a fetch is underway for the requested root reply.\n   * This includes fetched all the sub-resources like attachments and `sentry-replay-event`\n   */\n  fetching: boolean;\n\n  /**\n   * The root replay event\n   */\n  replayRecord: undefined | ReplayRecord;\n};\n\ntype Options = {\n  /**\n   * The organization slug\n   */\n  orgSlug: string;\n\n  /**\n   * The projectSlug and replayId concatenated together\n   */\n  replaySlug: string;\n};\n\ninterface Result extends Pick<State, 'fetchError' | 'fetching'> {\n  onRetry: () => void;\n  replay: ReplayReader | null;\n  replayRecord: ReplayRecord | undefined;\n}\n\nconst INITIAL_STATE: State = Object.freeze({\n  attachments: undefined,\n  errors: undefined,\n  fetchError: undefined,\n  fetching: true,\n  replayRecord: undefined,\n});\n\n/**\n * A react hook to load core replay data over the network.\n *\n * Core replay data includes:\n * 1. The root replay EventTransaction object\n *    - This includes `startTimestamp` and `tags` data\n * 2. Breadcrumb and Span data from all the related Event objects\n *    - Data is merged for consumption\n * 3. RRWeb payloads for the replayer video stream\n *    - TODO(replay): incrementally load the stream to speedup pageload\n *\n * This function should stay focused on loading data over the network.\n * Front-end processing, filtering and re-mixing of the different data streams\n * must be delegated to the `ReplayReader` class.\n *\n * @param {orgSlug, replaySlug} Where to find the root replay event\n * @returns An object representing a unified result of the network requests. Either a single `ReplayReader` data object or fetch errors.\n */\nfunction useReplayData({replaySlug, orgSlug}: Options): Result {\n  const [projectSlug, replayId] = replaySlug.split(':');\n\n  const api = useApi();\n  const [state, setState] = useState<State>(INITIAL_STATE);\n\n  // Fetch every field of the replay. We're overfetching, not every field is needed\n  const fetchReplay = useCallback(async () => {\n    const response = await api.requestPromise(\n      `/projects/${orgSlug}/${projectSlug}/replays/${replayId}/`\n    );\n    return response.data;\n  }, [api, orgSlug, projectSlug, replayId]);\n\n  const fetchAllAttachments = useCallback(async () => {\n    const rootUrl = `/projects/${orgSlug}/${projectSlug}/replays/${replayId}/recording-segments/?download&per_page=${SEGMENTS_PER_PAGE}`;\n    const firstFourCursors = [\n      `${SEGMENTS_PER_PAGE}:0:1`,\n      `${SEGMENTS_PER_PAGE}:1:0`,\n      `${SEGMENTS_PER_PAGE}:2:0`,\n      `${SEGMENTS_PER_PAGE}:3:0`,\n    ];\n    const firstFourUrls = firstFourCursors.map(cursor => `${rootUrl}&cursor=${cursor}`);\n\n    const parallelResponses = await Promise.allSettled(\n      firstFourUrls.map(url =>\n        api.requestPromise(url, {\n          includeAllArgs: true,\n        })\n      )\n    );\n\n    const responses: any = parallelResponses.map(resp =>\n      resp.status === 'fulfilled' ? resp.value[0] : []\n    );\n\n    const lastResponse = parallelResponses[firstFourCursors.length - 1];\n    const [_lastData, _lastTextStatus, lastResp] =\n      lastResponse.status === 'fulfilled' ? lastResponse.value : [];\n\n    let next: ParsedHeader = lastResp\n      ? parseLinkHeader(lastResp.getResponseHeader('Link') ?? '').next\n      : {href: rootUrl, results: true, cursor: ''};\n\n    // TODO(replay): It would be good to load the first page of results then\n    // start to render the UI while the next N pages continue to get fetched in\n    // the background.\n    while (next.results) {\n      const url = `${rootUrl}&cursor=${next.cursor}`;\n\n      const [data, _textStatus, resp] = await api.requestPromise(url, {\n        includeAllArgs: true,\n      });\n      responses.push(data);\n      const links = parseLinkHeader(resp?.getResponseHeader('Link') ?? '');\n      next = links.next;\n    }\n\n    // Each response returns an array of segments\n    const segments = responses.flatMap(_ => _);\n    // Each segment includes an array of attachments\n    const attachments = segments.flatMap(_ => _);\n\n    return attachments;\n  }, [api, orgSlug, projectSlug, replayId]);\n\n  const fetchErrors = useCallback(\n    async (replayRecord: ReplayRecord) => {\n      if (!replayRecord.error_ids.length) {\n        return [];\n      }\n\n      // Clone the `finished_at` time and bump it up one second because finishedAt\n      // has the `ms` portion truncated, while replays-events-meta operates on\n      // timestamps with `ms` attached. So finishedAt could be at time `12:00:00.000Z`\n      // while the event is saved with `12:00:00.450Z`.\n      const finishedAtClone = new Date(replayRecord.finished_at);\n      finishedAtClone.setSeconds(finishedAtClone.getSeconds() + 1);\n\n      const chunks = chunk(replayRecord.error_ids, ERRORS_PER_PAGE);\n      const responses = await Promise.allSettled(\n        chunks.map(errorIds =>\n          api.requestPromise(`/organizations/${orgSlug}/replays-events-meta/`, {\n            query: {\n              start: replayRecord.started_at.toISOString(),\n              end: finishedAtClone.toISOString(),\n              query: `id:[${String(errorIds)}]`,\n            },\n          })\n        )\n      );\n\n      return responses.flatMap(resp =>\n        resp.status === 'fulfilled' ? resp.value.data : []\n      );\n    },\n    [api, orgSlug]\n  );\n\n  const fetchReplayAndErrors = useCallback(async (): Promise<[ReplayRecord, any]> => {\n    const fetchedRecord = await fetchReplay();\n    const mappedRecord = mapResponseToReplayRecord(fetchedRecord);\n    setState(prev => ({\n      ...prev,\n      replayRecord: mappedRecord,\n    }));\n    const fetchedErrors = await fetchErrors(mappedRecord);\n    return [mappedRecord, fetchedErrors];\n  }, [fetchReplay, fetchErrors]);\n\n  const loadEvents = useCallback(async () => {\n    setState(INITIAL_STATE);\n\n    try {\n      const [replayAndErrors, attachments] = await Promise.all([\n        fetchReplayAndErrors(),\n        fetchAllAttachments(),\n      ]);\n      const [replayRecord, errors] = replayAndErrors;\n\n      setState(prev => ({\n        ...prev,\n        attachments,\n        errors,\n        fetchError: undefined,\n        fetching: false,\n        replayRecord,\n      }));\n    } catch (error) {\n      Sentry.captureException(error);\n      setState({\n        ...INITIAL_STATE,\n        fetchError: error,\n        fetching: false,\n      });\n    }\n  }, [fetchReplayAndErrors, fetchAllAttachments]);\n\n  useEffect(() => {\n    loadEvents();\n  }, [loadEvents]);\n\n  const replay = useMemo(() => {\n    return ReplayReader.factory({\n      attachments: state.attachments,\n      errors: state.errors,\n      replayRecord: state.replayRecord,\n    });\n  }, [state.attachments, state.errors, state.replayRecord]);\n\n  return {\n    fetchError: state.fetchError,\n    fetching: state.fetching,\n    onRetry: loadEvents,\n    replay,\n    replayRecord: state.replayRecord,\n  };\n}\n\nexport default useReplayData;\n","import styled from '@emotion/styled';\n\nconst FluidHeight = styled('div')`\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  flex-grow: 1;\n  overflow: hidden;\n`;\n\nexport default FluidHeight;\n"],"names":["BufferingOverlay","className","Overlay","Message","size","t","space","p","theme","gray300","borderRadius","white","zIndex","initial","FastForwardBadge","speed","Badge","FastForwardTooltip","title","direction","Tooltip","PlayerDOMAlert","dismiss","isDismissed","expirationDays","Number","MAX_SAFE_INTEGER","key","dismissedTimestamp","setDismissedTimestamp","useLocalStorageState","val","String","undefined","Boolean","timestamp","isNaN","Date","now","isValid","useCallback","toString","useDismissAlert","DOMAlertContainer","DOMAlert","DismissButton","priority","icon","onClick","fontSizeMedium","blue400","Button","BasePlayerRoot","isPreview","initRoot","dimensions","videoDimensions","fastForwardSpeed","isBuffering","useReplayContext","windowEl","useRef","viewEl","windowDimensions","setWindowDimensions","useState","width","height","organization","useOrganization","didLog","setDidLog","useEffect","aspect_ratio","scale","Math","min","scale_bucket","floor","trackAdvancedAnalyticsEvent","useVideoSizeLogger","current","updateWindowDimensions","clientWidth","clientHeight","useResizeObserver","ref","onResize","window","ResizeObserver","style","transform","SizingWindow","PositionedFastForward","PositionedBuffering","backgroundSecondary","gray100","PlayerRoot","purple300","purple200","ReplaysFeatureBadge","props","slug","type","ReplayReader","static","attachments","replayRecord","errors","constructor","this","duration","asMilliseconds","rrwebEvents","breadcrumbs","consoleCrumbs","networkSpans","memorySpans","spans","mapRRWebAttachments","startTimestampMs","endTimestampMs","replayTimestamps","started_at","finished_at","getTime","sortedSpans","spansFactory","filter","isNetworkSpan","isMemorySpan","breadcrumbFactory","getBreadcrumbsByCategory","rrwebEventListFactory","INITIAL_STATE","Object","freeze","fetchError","fetching","replaySlug","orgSlug","projectSlug","replayId","split","api","useApi","state","setState","fetchReplay","async","requestPromise","data","fetchAllAttachments","rootUrl","firstFourCursors","firstFourUrls","map","cursor","parallelResponses","Promise","allSettled","url","includeAllArgs","responses","resp","status","value","lastResponse","length","_lastData","_lastTextStatus","lastResp","next","parseLinkHeader","getResponseHeader","href","results","_textStatus","push","flatMap","_","fetchErrors","error_ids","finishedAtClone","setSeconds","getSeconds","chunks","chunk","errorIds","query","start","toISOString","end","fetchReplayAndErrors","fetchedRecord","mappedRecord","mapResponseToReplayRecord","prev","fetchedErrors","loadEvents","replayAndErrors","all","error","Sentry","replay","useMemo","factory","onRetry"],"sourceRoot":""}