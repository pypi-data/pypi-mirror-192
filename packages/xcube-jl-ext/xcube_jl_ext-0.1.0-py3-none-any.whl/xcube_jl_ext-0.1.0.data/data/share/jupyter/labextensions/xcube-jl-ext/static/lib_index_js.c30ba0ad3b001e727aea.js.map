{"version":3,"file":"lib_index_js.c30ba0ad3b001e727aea.js","mappings":";;;;;;;;;;;;;;;;;;;;;AAA+C;AACS;AACD;AACvD;AACO;AACP,cAAc,UAAU,qBAAqB,UAAU;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,aAAa,iBAAiB,QAAQ,WAAW;AACjD,8BAA8B,WAAW;AACzC;AACA;AACA;AACA;AACA;AACA,sBAAsB,gFAA8B;AACpD;AACA;AACA;AACA,iCAAiC,gDAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,+BAA+B,mBAAmB;AAClD;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA,8BAA8B,mBAAmB;AACjD;AACA;AACA,qCAAqC,8BAA8B;AACnE;AACA,cAAc,qDAAkB;AAChC;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,+CAA+C;AACtD,2BAA2B,+EAA6B;AACxD,uBAAuB,8DAAW;AAClC;AACA;AACA,yBAAyB,8EAA4B;AACrD;AACA;AACA,kBAAkB,+EAA6B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gFAA8B;AAChD;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnH0D;AACP;AACF;AACc;AACP;AACgD;AAC/D;AACmB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wEAAqB;AACrD,8BAA8B,sEAAmB;AACjD,iCAAiC,yEAAsB;AACvD,gCAAgC,wEAAqB;AACrD,2BAA2B,+EAA6B;AACxD;AACA;AACA;AACA,8BAA8B,gDAAU;AACxC;AACA;AACA;AACA,cAAc,sEAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,+CAAS;AAClD;AACA;AACA;AACA,0BAA0B,sEAAgB;AAC1C;AACA;AACA;AACA;AACA,oCAAoC,mDAAM;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kDAAY;AACzC;AACA,6BAA6B,gEAAc,GAAG,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,sBAAsB,+DAAa;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yEAAgB;AACxB,QAAQ,iEAAe;AACvB,QAAQ,2DAAS;AACjB,QAAQ,oEAAe;AACvB;AACA;AACA;AACA,iEAAe,MAAM,EAAC;;;;;;;;;;;;;;;;ACrItB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,kCAAkC,gBAAgB,cAAc,MAAM,GAAG,SAAS;AAClF;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA","sources":["webpack://xcube-jl-ext/./lib/api.js","webpack://xcube-jl-ext/./lib/index.js","webpack://xcube-jl-ext/./lib/util.js"],"sourcesContent":["import { URLExt } from '@jupyterlab/coreutils';\r\nimport { ServerConnection } from '@jupyterlab/services';\r\nimport { callUntil, UnrecoverableError } from \"./util\";\r\nconst API_NAMESPACE = \"xcube\";\r\nexport function getViewerUrl(serverUrl) {\r\n    return `${serverUrl}/viewer/?serverUrl=${serverUrl}`\r\n        + \"&serverName=xcube+JupyterLab+Integration\"\r\n        + \"&serverId=jupyterlab\"\r\n        + \"&compact=1\";\r\n}\r\n/**\r\n * Set lab information.\r\n */\r\nexport async function setLabInfo(settings) {\r\n    const request = {\r\n        method: \"PUT\",\r\n        headers: {\r\n            \"Content-Type\": \"application/json\",\r\n        },\r\n        body: JSON.stringify({\r\n            lab_url: settings.baseUrl\r\n        })\r\n    };\r\n    return callAPI('labinfo', request, settings);\r\n}\r\n/**\r\n * Start xcube server and return, once it is ready to serve.\r\n */\r\nexport async function getServer(hasServerProxy, settings) {\r\n    const serverState = await startServer(settings);\r\n    assertServerStateOk(serverState);\r\n    const serverPort = serverState.port;\r\n    const serverUrl = hasServerProxy\r\n        ? `${settings.baseUrl}proxy/${serverPort}`\r\n        : `http://127.0.0.1:${serverPort}`;\r\n    const fetchServerInfo = async () => {\r\n        const serverState = await getServerState();\r\n        assertServerStateOk(serverState);\r\n        const response = await fetch(serverUrl);\r\n        if (!response.ok) {\r\n            throw new ServerConnection.ResponseError(response);\r\n        }\r\n        return response.json();\r\n    };\r\n    const serverResponse = await callUntil(fetchServerInfo, 3000, 10);\r\n    console.info('xcube server response:', serverResponse);\r\n    return {\r\n        url: serverUrl,\r\n        state: serverState,\r\n        response: serverResponse,\r\n    };\r\n}\r\nfunction assertServerStateOk(serverState) {\r\n    if (serverState.status === \"running\" || serverState.status === \"sleeping\") {\r\n        return; // Ok!\r\n    }\r\n    console.debug(\"xcube-jl-ext server state:\", serverState);\r\n    let message = \"xcube server could not be started or terminated unexpectedly. \";\r\n    if (typeof serverState.stderr === \"string\") {\r\n        message += `Message: ${serverState.stderr}. `;\r\n    }\r\n    if (typeof serverState.returncode === \"number\") {\r\n        message += `Exit code ${serverState.returncode}. `;\r\n    }\r\n    if (typeof serverState.status === \"string\") {\r\n        message += `Status: ${serverState.status}. `;\r\n    }\r\n    if (Array.isArray(serverState.cmdline)) {\r\n        message += `Command-line: \"${serverState.cmdline.join(\" \")}\". `;\r\n    }\r\n    throw new UnrecoverableError(message);\r\n}\r\n/**\r\n * Start xcube server.\r\n */\r\nasync function startServer(settings) {\r\n    return callAPI('server', { method: \"PUT\" }, settings);\r\n}\r\n/**\r\n * Get xcube server state.\r\n */\r\nasync function getServerState(settings) {\r\n    return callAPI('server', { method: \"GET\" }, settings);\r\n}\r\n/**\r\n * Call the API extension\r\n *\r\n * @param endPoint API REST end point for the extension\r\n * @param init Initial values for the request\r\n * @param settings Server connection settings\r\n * @returns The response body interpreted as JSON\r\n */\r\nexport async function callAPI(endPoint = '', init = {}, settings) {\r\n    settings = settings || ServerConnection.makeSettings();\r\n    const requestUrl = URLExt.join(settings.baseUrl, API_NAMESPACE, endPoint);\r\n    let response;\r\n    try {\r\n        response = await ServerConnection.makeRequest(requestUrl, init, settings);\r\n    }\r\n    catch (error) {\r\n        throw new ServerConnection.NetworkError(error);\r\n    }\r\n    let data = await response.text();\r\n    if (data.length > 0) {\r\n        try {\r\n            data = JSON.parse(data);\r\n        }\r\n        catch (error) {\r\n            console.warn('Not a JSON response body.', response);\r\n        }\r\n    }\r\n    if (!response.ok) {\r\n        throw new ServerConnection.ResponseError(response, data.message || data);\r\n    }\r\n    return data;\r\n}\r\n","import { ILayoutRestorer } from \"@jupyterlab/application\";\r\nimport { PageConfig } from '@jupyterlab/coreutils';\r\nimport { ILauncher } from \"@jupyterlab/launcher\";\r\nimport { ISettingRegistry } from \"@jupyterlab/settingregistry\";\r\nimport { ServerConnection } from '@jupyterlab/services';\r\nimport { ICommandPalette, MainAreaWidget, showErrorMessage, WidgetTracker } from \"@jupyterlab/apputils\";\r\nimport { Widget } from \"@lumino/widgets\";\r\nimport { getServer, getViewerUrl, setLabInfo } from './api';\r\nconst ERROR_BOX_TITLE = \"xcube Extension Error\";\r\nasync function activate(app, settingRegistry, palette, launcher, restorer) {\r\n    console.debug(\"Activating JupyterLab extension xcube-jl-ext:\");\r\n    console.debug(\"  ISettingRegistry:\", settingRegistry);\r\n    console.debug(\"  ICommandPalette:\", palette);\r\n    console.debug(\"  ILauncher:\", launcher);\r\n    console.debug(\"  ILayoutRestorer:\", restorer);\r\n    console.debug(\"  baseUrl:\", PageConfig.getBaseUrl());\r\n    console.debug(\"  wsUrl:\", PageConfig.getWsUrl());\r\n    console.debug(\"  shareUrl:\", PageConfig.getShareUrl());\r\n    console.debug(\"  treeUrl:\", PageConfig.getTreeUrl());\r\n    const serverSettings = ServerConnection.makeSettings();\r\n    // console.debug(\"  serverSettings:\", serverSettings);\r\n    let hasServerProxy = false;\r\n    try {\r\n        const labInfo = await setLabInfo(serverSettings);\r\n        hasServerProxy = !!labInfo.has_proxy;\r\n    }\r\n    catch (error) {\r\n        await showErrorMessage(ERROR_BOX_TITLE, error);\r\n        return;\r\n    }\r\n    if (settingRegistry !== null) {\r\n        let settings;\r\n        try {\r\n            settings = await settingRegistry.load(plugin.id);\r\n            console.debug(\"xcube-jl-ext settings loaded:\", settings.composite);\r\n        }\r\n        catch (error) {\r\n            console.error(\"Failed to load settings for xcube-jl-ext.\", error);\r\n        }\r\n    }\r\n    let widget = null;\r\n    let tracker = null;\r\n    // Add an application command\r\n    const commandID = \"xcube:openViewer\";\r\n    app.commands.addCommand(commandID, {\r\n        label: \"xcube Viewer\",\r\n        iconClass: (args) => (args[\"isPalette\"] ? \"\" : \"xcube-icon\"),\r\n        execute: async () => {\r\n            if (widget === null || widget.isDisposed) {\r\n                console.debug(\"Creating new JupyterLab widget xcube-jl-ext\");\r\n                let serverStatus;\r\n                try {\r\n                    // TODO (forman): show indicator while starting server\r\n                    serverStatus = await getServer(hasServerProxy, serverSettings);\r\n                }\r\n                catch (error) {\r\n                    console.error(\"Argh:\", error);\r\n                    await showErrorMessage(ERROR_BOX_TITLE, error);\r\n                    return;\r\n                }\r\n                const serverUrl = serverStatus.url;\r\n                // Create a blank content widget inside a MainAreaWidget\r\n                const content = new Widget();\r\n                const iframe = document.createElement('iframe');\r\n                iframe.style.position = \"absolute\";\r\n                iframe.style.width = \"100%\";\r\n                iframe.style.height = \"100%\";\r\n                iframe.style.border = \"none\";\r\n                // iframe.src = \"https://viewer.earthsystemdatalab.net/\";\r\n                iframe.src = getViewerUrl(serverUrl);\r\n                content.node.appendChild(iframe);\r\n                widget = new MainAreaWidget({ content });\r\n                widget.id = \"xcube-viewer\";\r\n                widget.title.label = \"xcube Viewer\";\r\n                widget.title.closable = true;\r\n            }\r\n            if (tracker !== null && !tracker.has(widget)) {\r\n                // Track the state of the widget for later restoration\r\n                tracker.add(widget).then(() => {\r\n                    console.debug('JupyterLab widget xcube-jl-ext stored!');\r\n                });\r\n            }\r\n            if (!widget.isAttached) {\r\n                // Attach the widget to the main work area if it's not there\r\n                app.shell.add(widget, \"main\");\r\n            }\r\n            // Activate the widget\r\n            app.shell.activateById(widget.id);\r\n        }\r\n    });\r\n    if (palette !== null) {\r\n        // Add the command to the palette.\r\n        palette.addItem({\r\n            command: commandID,\r\n            category: \"Other\"\r\n        });\r\n    }\r\n    if (launcher !== null) {\r\n        // Add the command to the launcher.\r\n        launcher.add({\r\n            command: commandID,\r\n            category: \"Other\",\r\n            rank: 0\r\n        });\r\n    }\r\n    if (restorer !== null) {\r\n        // Track and restore the widget state\r\n        tracker = new WidgetTracker({\r\n            namespace: \"xcube\"\r\n        });\r\n        restorer.restore(tracker, {\r\n            command: commandID,\r\n            name: () => \"xcube\"\r\n        }).then(() => {\r\n            console.debug('JupyterLab widget xcube-jl-ext restored!');\r\n        });\r\n    }\r\n    console.log('JupyterLab extension xcube-jl-ext is activated!');\r\n}\r\n/**\r\n * Initialization data for the xcube-viewer-jl-ext extension.\r\n */\r\nconst plugin = {\r\n    id: \"xcube-jl-ext:plugin\",\r\n    autoStart: true,\r\n    optional: [\r\n        ISettingRegistry,\r\n        ICommandPalette,\r\n        ILauncher,\r\n        ILayoutRestorer\r\n    ],\r\n    activate\r\n};\r\nexport default plugin;\r\n","/*\r\n * The MIT License (MIT)\r\n *\r\n * Copyright (c) 2019-2023 by the xcube development team and contributors.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n * this software and associated documentation files (the \"Software\"), to deal in\r\n * the Software without restriction, including without limitation the rights to\r\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n * of the Software, and to permit persons to whom the Software is furnished to do\r\n * so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n/**\r\n * Throw this error, if you want `callUntil()` to exit immediately.\r\n */\r\nexport class UnrecoverableError extends Error {\r\n    constructor(message, error) {\r\n        super(message);\r\n        this.error = error;\r\n    }\r\n}\r\n/**\r\n * Call asynchronous function `fetchValue` until it returns a value without throwing an exception.\r\n * If it throws an exception, it will be executed after a delay of `timeout / maxCount`.\r\n * This is repeated until `maxCount` is reached or a `UnrecoverableError` is thrown.\r\n * Eventually, the last exception will be thrown.\r\n *\r\n * @param fetchValue The asynchronous function to be called.\r\n * @param timeout Overall timeout in milliseconds.\r\n * @param maxCount Maximum number of failures.\r\n */\r\nexport async function callUntil(fetchValue, timeout, maxCount) {\r\n    const delay = timeout / maxCount;\r\n    const handler = (resolve, reject, count) => {\r\n        console.debug(`Fetching ${fetchValue.name}() (attempt ${count}/${maxCount})`);\r\n        fetchValue()\r\n            .then(value => {\r\n            resolve(value);\r\n        })\r\n            .catch(error => {\r\n            if (error instanceof UnrecoverableError) {\r\n                reject(error.error || error);\r\n            }\r\n            else if (count >= maxCount) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                delayedHandler(resolve, reject, count + 1);\r\n            }\r\n        });\r\n    };\r\n    const delayedHandler = (resolve, reject, count) => {\r\n        setTimeout(() => handler(resolve, reject, count), delay);\r\n    };\r\n    return new Promise((resolve, reject) => delayedHandler(resolve, reject, 1));\r\n}\r\n"],"names":[],"sourceRoot":""}