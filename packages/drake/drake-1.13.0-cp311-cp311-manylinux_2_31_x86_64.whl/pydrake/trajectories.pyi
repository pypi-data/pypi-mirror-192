from typing import Any, ClassVar, List, Tuple

from typing import overload
import flags
import numpy
import pydrake.autodiffutils
import pydrake.common._module_py
import pydrake.common.cpp_template
import pydrake.common.eigen_geometry
import pydrake.math
import pydrake.polynomial
import pydrake.symbolic
BsplineTrajectory_: pydrake.common.cpp_template.TemplateClass
PathParameterizedTrajectory_: pydrake.common.cpp_template.TemplateClass
PiecewisePolynomial_: pydrake.common.cpp_template.TemplateClass
PiecewisePose_: pydrake.common.cpp_template.TemplateClass
PiecewiseQuaternionSlerp_: pydrake.common.cpp_template.TemplateClass
PiecewiseTrajectory_: pydrake.common.cpp_template.TemplateClass
StackedTrajectory_: pydrake.common.cpp_template.TemplateClass
Trajectory_: pydrake.common.cpp_template.TemplateClass

class BsplineTrajectory(Trajectory_ğ“£floatğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis_ğ“£floatğ“¤, control_points: List[List[float]]) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis_ğ“£floatğ“¤, control_points: List[numpy.ndarray[numpy.float64[m,n]]]) -> None: ...
    def Clone(self) -> Trajectory_ğ“£floatğ“¤: ...
    def CopyBlock(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> BsplineTrajectory_ğ“£floatğ“¤: ...
    def CopyHead(self, n: int) -> BsplineTrajectory_ğ“£floatğ“¤: ...
    def FinalValue(self) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def InitialValue(self) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def InsertKnots(self, additional_knots: List[float]) -> None: ...
    def basis(self) -> pydrake.math.BsplineBasis_ğ“£floatğ“¤: ...
    def control_points(self) -> List[numpy.ndarray[numpy.float64[m,n]]]: ...
    def num_control_points(self) -> int: ...
    def __copy__(self) -> BsplineTrajectory_ğ“£floatğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> BsplineTrajectory_ğ“£floatğ“¤: ...
    def __getstate__(self) -> Tuple[pydrake.math.BsplineBasis_ğ“£floatğ“¤,List[numpy.ndarray[numpy.float64[m,n]]]]: ...
    def __setstate__(self, arg0: Tuple[pydrake.math.BsplineBasis_ğ“£floatğ“¤,List[numpy.ndarray[numpy.float64[m,n]]]]) -> None: ...

class BsplineTrajectory_ğ“£AutoDiffXdğ“¤(Trajectory_ğ“£AutoDiffXdğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis_ğ“£AutoDiffXdğ“¤, control_points: List[List[pydrake.autodiffutils.AutoDiffXd]]) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis_ğ“£AutoDiffXdğ“¤, control_points: List[numpy.ndarray[object[m,n]]]) -> None: ...
    def Clone(self) -> Trajectory_ğ“£AutoDiffXdğ“¤: ...
    def CopyBlock(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> BsplineTrajectory_ğ“£AutoDiffXdğ“¤: ...
    def CopyHead(self, n: int) -> BsplineTrajectory_ğ“£AutoDiffXdğ“¤: ...
    def FinalValue(self) -> numpy.ndarray[object[m,n]]: ...
    def InitialValue(self) -> numpy.ndarray[object[m,n]]: ...
    def InsertKnots(self, additional_knots: List[pydrake.autodiffutils.AutoDiffXd]) -> None: ...
    def basis(self) -> pydrake.math.BsplineBasis_ğ“£AutoDiffXdğ“¤: ...
    def control_points(self) -> List[numpy.ndarray[object[m,n]]]: ...
    def num_control_points(self) -> int: ...
    def __copy__(self) -> BsplineTrajectory_ğ“£AutoDiffXdğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> BsplineTrajectory_ğ“£AutoDiffXdğ“¤: ...
    def __getstate__(self) -> Tuple[pydrake.math.BsplineBasis_ğ“£AutoDiffXdğ“¤,List[numpy.ndarray[object[m,n]]]]: ...
    def __setstate__(self, arg0: Tuple[pydrake.math.BsplineBasis_ğ“£AutoDiffXdğ“¤,List[numpy.ndarray[object[m,n]]]]) -> None: ...

class BsplineTrajectory_ğ“£Expressionğ“¤(Trajectory_ğ“£Expressionğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis_ğ“£Expressionğ“¤, control_points: List[List[pydrake.symbolic.Expression]]) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis_ğ“£Expressionğ“¤, control_points: List[numpy.ndarray[object[m,n]]]) -> None: ...
    def Clone(self) -> Trajectory_ğ“£Expressionğ“¤: ...
    def CopyBlock(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> BsplineTrajectory_ğ“£Expressionğ“¤: ...
    def CopyHead(self, n: int) -> BsplineTrajectory_ğ“£Expressionğ“¤: ...
    def FinalValue(self) -> numpy.ndarray[object[m,n]]: ...
    def InitialValue(self) -> numpy.ndarray[object[m,n]]: ...
    def InsertKnots(self, additional_knots: List[pydrake.symbolic.Expression]) -> None: ...
    def basis(self) -> pydrake.math.BsplineBasis_ğ“£Expressionğ“¤: ...
    def control_points(self) -> List[numpy.ndarray[object[m,n]]]: ...
    def num_control_points(self) -> int: ...
    def __copy__(self) -> BsplineTrajectory_ğ“£Expressionğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> BsplineTrajectory_ğ“£Expressionğ“¤: ...
    def __getstate__(self) -> Tuple[pydrake.math.BsplineBasis_ğ“£Expressionğ“¤,List[numpy.ndarray[object[m,n]]]]: ...
    def __setstate__(self, arg0: Tuple[pydrake.math.BsplineBasis_ğ“£Expressionğ“¤,List[numpy.ndarray[object[m,n]]]]) -> None: ...

class BsplineTrajectory_ğ“£floatğ“¤(Trajectory_ğ“£floatğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis_ğ“£floatğ“¤, control_points: List[List[float]]) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis_ğ“£floatğ“¤, control_points: List[numpy.ndarray[numpy.float64[m,n]]]) -> None: ...
    def Clone(self) -> Trajectory_ğ“£floatğ“¤: ...
    def CopyBlock(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> BsplineTrajectory_ğ“£floatğ“¤: ...
    def CopyHead(self, n: int) -> BsplineTrajectory_ğ“£floatğ“¤: ...
    def FinalValue(self) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def InitialValue(self) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def InsertKnots(self, additional_knots: List[float]) -> None: ...
    def basis(self) -> pydrake.math.BsplineBasis_ğ“£floatğ“¤: ...
    def control_points(self) -> List[numpy.ndarray[numpy.float64[m,n]]]: ...
    def num_control_points(self) -> int: ...
    def __copy__(self) -> BsplineTrajectory_ğ“£floatğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> BsplineTrajectory_ğ“£floatğ“¤: ...
    def __getstate__(self) -> Tuple[pydrake.math.BsplineBasis_ğ“£floatğ“¤,List[numpy.ndarray[numpy.float64[m,n]]]]: ...
    def __setstate__(self, arg0: Tuple[pydrake.math.BsplineBasis_ğ“£floatğ“¤,List[numpy.ndarray[numpy.float64[m,n]]]]) -> None: ...

class PathParameterizedTrajectory(Trajectory_ğ“£floatğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, path: Trajectory_ğ“£floatğ“¤, time_scaling: Trajectory_ğ“£floatğ“¤) -> None: ...
    def Clone(self) -> Trajectory_ğ“£floatğ“¤: ...
    def path(self) -> Trajectory_ğ“£floatğ“¤: ...
    def time_scaling(self) -> Trajectory_ğ“£floatğ“¤: ...
    def __copy__(self) -> PathParameterizedTrajectory_ğ“£floatğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> PathParameterizedTrajectory_ğ“£floatğ“¤: ...

class PathParameterizedTrajectory_ğ“£AutoDiffXdğ“¤(Trajectory_ğ“£AutoDiffXdğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, path: Trajectory_ğ“£AutoDiffXdğ“¤, time_scaling: Trajectory_ğ“£AutoDiffXdğ“¤) -> None: ...
    def Clone(self) -> Trajectory_ğ“£AutoDiffXdğ“¤: ...
    def path(self) -> Trajectory_ğ“£AutoDiffXdğ“¤: ...
    def time_scaling(self) -> Trajectory_ğ“£AutoDiffXdğ“¤: ...
    def __copy__(self) -> PathParameterizedTrajectory_ğ“£AutoDiffXdğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> PathParameterizedTrajectory_ğ“£AutoDiffXdğ“¤: ...

class PathParameterizedTrajectory_ğ“£Expressionğ“¤(Trajectory_ğ“£Expressionğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, path: Trajectory_ğ“£Expressionğ“¤, time_scaling: Trajectory_ğ“£Expressionğ“¤) -> None: ...
    def Clone(self) -> Trajectory_ğ“£Expressionğ“¤: ...
    def path(self) -> Trajectory_ğ“£Expressionğ“¤: ...
    def time_scaling(self) -> Trajectory_ğ“£Expressionğ“¤: ...
    def __copy__(self) -> PathParameterizedTrajectory_ğ“£Expressionğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> PathParameterizedTrajectory_ğ“£Expressionğ“¤: ...

class PathParameterizedTrajectory_ğ“£floatğ“¤(Trajectory_ğ“£floatğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, path: Trajectory_ğ“£floatğ“¤, time_scaling: Trajectory_ğ“£floatğ“¤) -> None: ...
    def Clone(self) -> Trajectory_ğ“£floatğ“¤: ...
    def path(self) -> Trajectory_ğ“£floatğ“¤: ...
    def time_scaling(self) -> Trajectory_ğ“£floatğ“¤: ...
    def __copy__(self) -> PathParameterizedTrajectory_ğ“£floatğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> PathParameterizedTrajectory_ğ“£floatğ“¤: ...

class PiecewisePolynomial(PiecewiseTrajectory_ğ“£floatğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous]) -> None: ...
    @overload
    def __init__(self, arg0: List[numpy.ndarray[object[m,n]]], arg1: List[float]) -> None: ...
    @overload
    def __init__(self, arg0: List[pydrake.polynomial.Polynomial_ğ“£floatğ“¤], arg1: List[float]) -> None: ...
    def AppendCubicHermiteSegment(self, time: float, sample: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], sample_dot: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous]) -> None: ...
    def AppendFirstOrderSegment(self, time: float, sample: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous]) -> None: ...
    def Block(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> PiecewisePolynomial_ğ“£floatğ“¤: ...
    def Clone(self) -> Trajectory_ğ“£floatğ“¤: ...
    def ConcatenateInTime(self, other: PiecewisePolynomial_ğ“£floatğ“¤) -> None: ...
    def CubicHermite(self, *args, **kwargs) -> Any: ...
    def CubicShapePreserving(self, *args, **kwargs) -> Any: ...
    def CubicWithContinuousSecondDerivatives(self, *args, **kwargs) -> Any: ...
    def FirstOrderHold(self, *args, **kwargs) -> Any: ...
    def LagrangeInterpolatingPolynomial(self, *args, **kwargs) -> Any: ...
    def RemoveFinalSegment(self) -> None: ...
    def Reshape(self, rows: int, cols: int) -> None: ...
    def ReverseTime(self) -> None: ...
    def ScaleTime(self, scale: float) -> None: ...
    def Transpose(self) -> PiecewisePolynomial_ğ“£floatğ“¤: ...
    def ZeroOrderHold(self, *args, **kwargs) -> Any: ...
    @overload
    def derivative(self, derivative_order: int = ...) -> PiecewisePolynomial_ğ“£floatğ“¤: ...
    @overload
    def derivative(self) -> Any: ...
    def getPolynomial(self, segment_index: int, row: int = ..., col: int = ...) -> pydrake.polynomial.Polynomial_ğ“£floatğ“¤: ...
    def getPolynomialMatrix(self, segment_index: int) -> numpy.ndarray[object[m,n]]: ...
    def getSegmentPolynomialDegree(self, segment_index: int, row: int = ..., col: int = ...) -> int: ...
    def isApprox(self, other: PiecewisePolynomial_ğ“£floatğ“¤, tol: float, tol_type: pydrake.common._module_py.ToleranceType = ...) -> bool: ...
    def setPolynomialMatrixBlock(self, replacement: numpy.ndarray[object[m,n]], segment_index: int, row_start: int = ..., col_start: int = ...) -> None: ...
    def shiftRight(self, offset: float) -> None: ...
    def slice(self, start_segment_index: int, num_segments: int) -> PiecewisePolynomial_ğ“£floatğ“¤: ...
    def __add__(self, arg0: PiecewisePolynomial_ğ“£floatğ“¤) -> PiecewisePolynomial_ğ“£floatğ“¤: ...
    def __copy__(self) -> PiecewisePolynomial_ğ“£floatğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePolynomial_ğ“£floatğ“¤: ...

class PiecewisePolynomial_ğ“£AutoDiffXdğ“¤(PiecewiseTrajectory_ğ“£AutoDiffXdğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    @overload
    def __init__(self, arg0: List[numpy.ndarray[object[m,n]]], arg1: List[pydrake.autodiffutils.AutoDiffXd]) -> None: ...
    @overload
    def __init__(self, arg0: List[pydrake.polynomial.Polynomial_ğ“£AutoDiffXdğ“¤], arg1: List[pydrake.autodiffutils.AutoDiffXd]) -> None: ...
    def AppendCubicHermiteSegment(self, time: pydrake.autodiffutils.AutoDiffXd, sample: numpy.ndarray[object[m,n],flags.f_contiguous], sample_dot: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    def AppendFirstOrderSegment(self, time: pydrake.autodiffutils.AutoDiffXd, sample: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    def Block(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> PiecewisePolynomial_ğ“£AutoDiffXdğ“¤: ...
    def Clone(self) -> Trajectory_ğ“£AutoDiffXdğ“¤: ...
    def ConcatenateInTime(self, other: PiecewisePolynomial_ğ“£AutoDiffXdğ“¤) -> None: ...
    def CubicHermite(self, *args, **kwargs) -> Any: ...
    def CubicShapePreserving(self, *args, **kwargs) -> Any: ...
    def CubicWithContinuousSecondDerivatives(self, *args, **kwargs) -> Any: ...
    def FirstOrderHold(self, *args, **kwargs) -> Any: ...
    def LagrangeInterpolatingPolynomial(self, *args, **kwargs) -> Any: ...
    def RemoveFinalSegment(self) -> None: ...
    def Reshape(self, rows: int, cols: int) -> None: ...
    def ReverseTime(self) -> None: ...
    def ScaleTime(self, scale: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    def Transpose(self) -> PiecewisePolynomial_ğ“£AutoDiffXdğ“¤: ...
    def ZeroOrderHold(self, *args, **kwargs) -> Any: ...
    @overload
    def derivative(self, derivative_order: int = ...) -> PiecewisePolynomial_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def derivative(self) -> Any: ...
    def getPolynomial(self, segment_index: int, row: int = ..., col: int = ...) -> pydrake.polynomial.Polynomial_ğ“£AutoDiffXdğ“¤: ...
    def getPolynomialMatrix(self, segment_index: int) -> numpy.ndarray[object[m,n]]: ...
    def getSegmentPolynomialDegree(self, segment_index: int, row: int = ..., col: int = ...) -> int: ...
    def isApprox(self, other: PiecewisePolynomial_ğ“£AutoDiffXdğ“¤, tol: float, tol_type: pydrake.common._module_py.ToleranceType = ...) -> bool: ...
    def setPolynomialMatrixBlock(self, replacement: numpy.ndarray[object[m,n]], segment_index: int, row_start: int = ..., col_start: int = ...) -> None: ...
    def shiftRight(self, offset: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    def slice(self, start_segment_index: int, num_segments: int) -> PiecewisePolynomial_ğ“£AutoDiffXdğ“¤: ...
    def __add__(self, arg0: PiecewisePolynomial_ğ“£AutoDiffXdğ“¤) -> PiecewisePolynomial_ğ“£AutoDiffXdğ“¤: ...
    def __copy__(self) -> PiecewisePolynomial_ğ“£AutoDiffXdğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePolynomial_ğ“£AutoDiffXdğ“¤: ...

class PiecewisePolynomial_ğ“£Expressionğ“¤(PiecewiseTrajectory_ğ“£Expressionğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    @overload
    def __init__(self, arg0: List[numpy.ndarray[object[m,n]]], arg1: List[pydrake.symbolic.Expression]) -> None: ...
    @overload
    def __init__(self, arg0: List[pydrake.polynomial.Polynomial_ğ“£Expressionğ“¤], arg1: List[pydrake.symbolic.Expression]) -> None: ...
    def AppendCubicHermiteSegment(self, time: pydrake.symbolic.Expression, sample: numpy.ndarray[object[m,n],flags.f_contiguous], sample_dot: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    def AppendFirstOrderSegment(self, time: pydrake.symbolic.Expression, sample: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    def Block(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> PiecewisePolynomial_ğ“£Expressionğ“¤: ...
    def Clone(self) -> Trajectory_ğ“£Expressionğ“¤: ...
    def ConcatenateInTime(self, other: PiecewisePolynomial_ğ“£Expressionğ“¤) -> None: ...
    def CubicHermite(self, *args, **kwargs) -> Any: ...
    def CubicShapePreserving(self, *args, **kwargs) -> Any: ...
    def CubicWithContinuousSecondDerivatives(self, *args, **kwargs) -> Any: ...
    def FirstOrderHold(self, *args, **kwargs) -> Any: ...
    def LagrangeInterpolatingPolynomial(self, *args, **kwargs) -> Any: ...
    def RemoveFinalSegment(self) -> None: ...
    def Reshape(self, rows: int, cols: int) -> None: ...
    def ReverseTime(self) -> None: ...
    def ScaleTime(self, scale: pydrake.symbolic.Expression) -> None: ...
    def Transpose(self) -> PiecewisePolynomial_ğ“£Expressionğ“¤: ...
    def ZeroOrderHold(self, *args, **kwargs) -> Any: ...
    @overload
    def derivative(self, derivative_order: int = ...) -> PiecewisePolynomial_ğ“£Expressionğ“¤: ...
    @overload
    def derivative(self) -> Any: ...
    def getPolynomial(self, segment_index: int, row: int = ..., col: int = ...) -> pydrake.polynomial.Polynomial_ğ“£Expressionğ“¤: ...
    def getPolynomialMatrix(self, segment_index: int) -> numpy.ndarray[object[m,n]]: ...
    def getSegmentPolynomialDegree(self, segment_index: int, row: int = ..., col: int = ...) -> int: ...
    def isApprox(self, other: PiecewisePolynomial_ğ“£Expressionğ“¤, tol: float, tol_type: pydrake.common._module_py.ToleranceType = ...) -> bool: ...
    def setPolynomialMatrixBlock(self, replacement: numpy.ndarray[object[m,n]], segment_index: int, row_start: int = ..., col_start: int = ...) -> None: ...
    def shiftRight(self, offset: pydrake.symbolic.Expression) -> None: ...
    def slice(self, start_segment_index: int, num_segments: int) -> PiecewisePolynomial_ğ“£Expressionğ“¤: ...
    def __add__(self, arg0: PiecewisePolynomial_ğ“£Expressionğ“¤) -> PiecewisePolynomial_ğ“£Expressionğ“¤: ...
    def __copy__(self) -> PiecewisePolynomial_ğ“£Expressionğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePolynomial_ğ“£Expressionğ“¤: ...

class PiecewisePolynomial_ğ“£floatğ“¤(PiecewiseTrajectory_ğ“£floatğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous]) -> None: ...
    @overload
    def __init__(self, arg0: List[numpy.ndarray[object[m,n]]], arg1: List[float]) -> None: ...
    @overload
    def __init__(self, arg0: List[pydrake.polynomial.Polynomial_ğ“£floatğ“¤], arg1: List[float]) -> None: ...
    def AppendCubicHermiteSegment(self, time: float, sample: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], sample_dot: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous]) -> None: ...
    def AppendFirstOrderSegment(self, time: float, sample: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous]) -> None: ...
    def Block(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> PiecewisePolynomial_ğ“£floatğ“¤: ...
    def Clone(self) -> Trajectory_ğ“£floatğ“¤: ...
    def ConcatenateInTime(self, other: PiecewisePolynomial_ğ“£floatğ“¤) -> None: ...
    def CubicHermite(self, *args, **kwargs) -> Any: ...
    def CubicShapePreserving(self, *args, **kwargs) -> Any: ...
    def CubicWithContinuousSecondDerivatives(self, *args, **kwargs) -> Any: ...
    def FirstOrderHold(self, *args, **kwargs) -> Any: ...
    def LagrangeInterpolatingPolynomial(self, *args, **kwargs) -> Any: ...
    def RemoveFinalSegment(self) -> None: ...
    def Reshape(self, rows: int, cols: int) -> None: ...
    def ReverseTime(self) -> None: ...
    def ScaleTime(self, scale: float) -> None: ...
    def Transpose(self) -> PiecewisePolynomial_ğ“£floatğ“¤: ...
    def ZeroOrderHold(self, *args, **kwargs) -> Any: ...
    @overload
    def derivative(self, derivative_order: int = ...) -> PiecewisePolynomial_ğ“£floatğ“¤: ...
    @overload
    def derivative(self) -> Any: ...
    def getPolynomial(self, segment_index: int, row: int = ..., col: int = ...) -> pydrake.polynomial.Polynomial_ğ“£floatğ“¤: ...
    def getPolynomialMatrix(self, segment_index: int) -> numpy.ndarray[object[m,n]]: ...
    def getSegmentPolynomialDegree(self, segment_index: int, row: int = ..., col: int = ...) -> int: ...
    def isApprox(self, other: PiecewisePolynomial_ğ“£floatğ“¤, tol: float, tol_type: pydrake.common._module_py.ToleranceType = ...) -> bool: ...
    def setPolynomialMatrixBlock(self, replacement: numpy.ndarray[object[m,n]], segment_index: int, row_start: int = ..., col_start: int = ...) -> None: ...
    def shiftRight(self, offset: float) -> None: ...
    def slice(self, start_segment_index: int, num_segments: int) -> PiecewisePolynomial_ğ“£floatğ“¤: ...
    def __add__(self, arg0: PiecewisePolynomial_ğ“£floatğ“¤) -> PiecewisePolynomial_ğ“£floatğ“¤: ...
    def __copy__(self) -> PiecewisePolynomial_ğ“£floatğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePolynomial_ğ“£floatğ“¤: ...

class PiecewisePose(PiecewiseTrajectory_ğ“£floatğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, position_trajectory: PiecewisePolynomial_ğ“£floatğ“¤, orientation_trajectory: PiecewiseQuaternionSlerp_ğ“£floatğ“¤) -> None: ...
    def GetAcceleration(self, time: float) -> numpy.ndarray[numpy.float64[6,1]]: ...
    def GetPose(self, time: float) -> pydrake.math.RigidTransform_ğ“£floatğ“¤: ...
    def GetVelocity(self, time: float) -> numpy.ndarray[numpy.float64[6,1]]: ...
    def IsApprox(self, other: PiecewisePose_ğ“£floatğ“¤, tol: float) -> bool: ...
    def MakeCubicLinearWithEndLinearVelocity(self, *args, **kwargs) -> Any: ...
    def MakeLinear(self, *args, **kwargs) -> Any: ...
    def get_orientation_trajectory(self) -> PiecewiseQuaternionSlerp_ğ“£floatğ“¤: ...
    def get_position_trajectory(self) -> PiecewisePolynomial_ğ“£floatğ“¤: ...
    def __copy__(self) -> PiecewisePose_ğ“£floatğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePose_ğ“£floatğ“¤: ...

class PiecewisePose_ğ“£AutoDiffXdğ“¤(PiecewiseTrajectory_ğ“£AutoDiffXdğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, position_trajectory: PiecewisePolynomial_ğ“£AutoDiffXdğ“¤, orientation_trajectory: PiecewiseQuaternionSlerp_ğ“£AutoDiffXdğ“¤) -> None: ...
    def GetAcceleration(self, time: pydrake.autodiffutils.AutoDiffXd) -> numpy.ndarray[object[6,1]]: ...
    def GetPose(self, time: pydrake.autodiffutils.AutoDiffXd) -> pydrake.math.RigidTransform_ğ“£AutoDiffXdğ“¤: ...
    def GetVelocity(self, time: pydrake.autodiffutils.AutoDiffXd) -> numpy.ndarray[object[6,1]]: ...
    def IsApprox(self, other: PiecewisePose_ğ“£AutoDiffXdğ“¤, tol: float) -> bool: ...
    def MakeCubicLinearWithEndLinearVelocity(self, *args, **kwargs) -> Any: ...
    def MakeLinear(self, *args, **kwargs) -> Any: ...
    def get_orientation_trajectory(self) -> PiecewiseQuaternionSlerp_ğ“£AutoDiffXdğ“¤: ...
    def get_position_trajectory(self) -> PiecewisePolynomial_ğ“£AutoDiffXdğ“¤: ...
    def __copy__(self) -> PiecewisePose_ğ“£AutoDiffXdğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePose_ğ“£AutoDiffXdğ“¤: ...

class PiecewisePose_ğ“£Expressionğ“¤(PiecewiseTrajectory_ğ“£Expressionğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, position_trajectory: PiecewisePolynomial_ğ“£Expressionğ“¤, orientation_trajectory: PiecewiseQuaternionSlerp_ğ“£Expressionğ“¤) -> None: ...
    def GetAcceleration(self, time: pydrake.symbolic.Expression) -> numpy.ndarray[object[6,1]]: ...
    def GetPose(self, time: pydrake.symbolic.Expression) -> pydrake.math.RigidTransform_ğ“£Expressionğ“¤: ...
    def GetVelocity(self, time: pydrake.symbolic.Expression) -> numpy.ndarray[object[6,1]]: ...
    def IsApprox(self, other: PiecewisePose_ğ“£Expressionğ“¤, tol: float) -> bool: ...
    def MakeCubicLinearWithEndLinearVelocity(self, *args, **kwargs) -> Any: ...
    def MakeLinear(self, *args, **kwargs) -> Any: ...
    def get_orientation_trajectory(self) -> PiecewiseQuaternionSlerp_ğ“£Expressionğ“¤: ...
    def get_position_trajectory(self) -> PiecewisePolynomial_ğ“£Expressionğ“¤: ...
    def __copy__(self) -> PiecewisePose_ğ“£Expressionğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePose_ğ“£Expressionğ“¤: ...

class PiecewisePose_ğ“£floatğ“¤(PiecewiseTrajectory_ğ“£floatğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, position_trajectory: PiecewisePolynomial_ğ“£floatğ“¤, orientation_trajectory: PiecewiseQuaternionSlerp_ğ“£floatğ“¤) -> None: ...
    def GetAcceleration(self, time: float) -> numpy.ndarray[numpy.float64[6,1]]: ...
    def GetPose(self, time: float) -> pydrake.math.RigidTransform_ğ“£floatğ“¤: ...
    def GetVelocity(self, time: float) -> numpy.ndarray[numpy.float64[6,1]]: ...
    def IsApprox(self, other: PiecewisePose_ğ“£floatğ“¤, tol: float) -> bool: ...
    def MakeCubicLinearWithEndLinearVelocity(self, *args, **kwargs) -> Any: ...
    def MakeLinear(self, *args, **kwargs) -> Any: ...
    def get_orientation_trajectory(self) -> PiecewiseQuaternionSlerp_ğ“£floatğ“¤: ...
    def get_position_trajectory(self) -> PiecewisePolynomial_ğ“£floatğ“¤: ...
    def __copy__(self) -> PiecewisePose_ğ“£floatğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePose_ğ“£floatğ“¤: ...

class PiecewiseQuaternionSlerp(PiecewiseTrajectory_ğ“£floatğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, breaks: List[float], quaternions: List[pydrake.common.eigen_geometry.Quaternion_ğ“£floatğ“¤]) -> None: ...
    @overload
    def __init__(self, breaks: List[float], rotation_matrices: List[numpy.ndarray[numpy.float64[3,3]]]) -> None: ...
    @overload
    def __init__(self, breaks: List[float], rotation_matrices: List[pydrake.math.RotationMatrix_ğ“£floatğ“¤]) -> None: ...
    @overload
    def __init__(self, breaks: List[float], angle_axes: List[pydrake.common.eigen_geometry.AngleAxis_ğ“£floatğ“¤]) -> None: ...
    @overload
    def Append(self, time: float, quaternion: pydrake.common.eigen_geometry.Quaternion_ğ“£floatğ“¤) -> None: ...
    @overload
    def Append(self, time: float, rotation_matrix: pydrake.math.RotationMatrix_ğ“£floatğ“¤) -> None: ...
    @overload
    def Append(self, time: float, angle_axis: pydrake.common.eigen_geometry.AngleAxis_ğ“£floatğ“¤) -> None: ...
    def angular_acceleration(self, time: float) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def angular_velocity(self, time: float) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def orientation(self, time: float) -> pydrake.common.eigen_geometry.Quaternion_ğ“£floatğ“¤: ...
    def __copy__(self) -> PiecewiseQuaternionSlerp_ğ“£floatğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> PiecewiseQuaternionSlerp_ğ“£floatğ“¤: ...

class PiecewiseQuaternionSlerp_ğ“£AutoDiffXdğ“¤(PiecewiseTrajectory_ğ“£AutoDiffXdğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.autodiffutils.AutoDiffXd], quaternions: List[pydrake.common.eigen_geometry.Quaternion_ğ“£AutoDiffXdğ“¤]) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.autodiffutils.AutoDiffXd], rotation_matrices: List[numpy.ndarray[object[3,3]]]) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.autodiffutils.AutoDiffXd], rotation_matrices: List[pydrake.math.RotationMatrix_ğ“£AutoDiffXdğ“¤]) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.autodiffutils.AutoDiffXd], angle_axes: List[pydrake.common.eigen_geometry.AngleAxis_ğ“£AutoDiffXdğ“¤]) -> None: ...
    @overload
    def Append(self, time: pydrake.autodiffutils.AutoDiffXd, quaternion: pydrake.common.eigen_geometry.Quaternion_ğ“£AutoDiffXdğ“¤) -> None: ...
    @overload
    def Append(self, time: pydrake.autodiffutils.AutoDiffXd, rotation_matrix: pydrake.math.RotationMatrix_ğ“£AutoDiffXdğ“¤) -> None: ...
    @overload
    def Append(self, time: pydrake.autodiffutils.AutoDiffXd, angle_axis: pydrake.common.eigen_geometry.AngleAxis_ğ“£AutoDiffXdğ“¤) -> None: ...
    def angular_acceleration(self, time: pydrake.autodiffutils.AutoDiffXd) -> numpy.ndarray[object[3,1]]: ...
    def angular_velocity(self, time: pydrake.autodiffutils.AutoDiffXd) -> numpy.ndarray[object[3,1]]: ...
    def orientation(self, time: pydrake.autodiffutils.AutoDiffXd) -> pydrake.common.eigen_geometry.Quaternion_ğ“£AutoDiffXdğ“¤: ...
    def __copy__(self) -> PiecewiseQuaternionSlerp_ğ“£AutoDiffXdğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> PiecewiseQuaternionSlerp_ğ“£AutoDiffXdğ“¤: ...

class PiecewiseQuaternionSlerp_ğ“£Expressionğ“¤(PiecewiseTrajectory_ğ“£Expressionğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.symbolic.Expression], quaternions: List[pydrake.common.eigen_geometry.Quaternion_ğ“£Expressionğ“¤]) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.symbolic.Expression], rotation_matrices: List[numpy.ndarray[object[3,3]]]) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.symbolic.Expression], rotation_matrices: List[pydrake.math.RotationMatrix_ğ“£Expressionğ“¤]) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.symbolic.Expression], angle_axes: List[pydrake.common.eigen_geometry.AngleAxis_ğ“£Expressionğ“¤]) -> None: ...
    @overload
    def Append(self, time: pydrake.symbolic.Expression, quaternion: pydrake.common.eigen_geometry.Quaternion_ğ“£Expressionğ“¤) -> None: ...
    @overload
    def Append(self, time: pydrake.symbolic.Expression, rotation_matrix: pydrake.math.RotationMatrix_ğ“£Expressionğ“¤) -> None: ...
    @overload
    def Append(self, time: pydrake.symbolic.Expression, angle_axis: pydrake.common.eigen_geometry.AngleAxis_ğ“£Expressionğ“¤) -> None: ...
    def angular_acceleration(self, time: pydrake.symbolic.Expression) -> numpy.ndarray[object[3,1]]: ...
    def angular_velocity(self, time: pydrake.symbolic.Expression) -> numpy.ndarray[object[3,1]]: ...
    def orientation(self, time: pydrake.symbolic.Expression) -> pydrake.common.eigen_geometry.Quaternion_ğ“£Expressionğ“¤: ...
    def __copy__(self) -> PiecewiseQuaternionSlerp_ğ“£Expressionğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> PiecewiseQuaternionSlerp_ğ“£Expressionğ“¤: ...

class PiecewiseQuaternionSlerp_ğ“£floatğ“¤(PiecewiseTrajectory_ğ“£floatğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, breaks: List[float], quaternions: List[pydrake.common.eigen_geometry.Quaternion_ğ“£floatğ“¤]) -> None: ...
    @overload
    def __init__(self, breaks: List[float], rotation_matrices: List[numpy.ndarray[numpy.float64[3,3]]]) -> None: ...
    @overload
    def __init__(self, breaks: List[float], rotation_matrices: List[pydrake.math.RotationMatrix_ğ“£floatğ“¤]) -> None: ...
    @overload
    def __init__(self, breaks: List[float], angle_axes: List[pydrake.common.eigen_geometry.AngleAxis_ğ“£floatğ“¤]) -> None: ...
    @overload
    def Append(self, time: float, quaternion: pydrake.common.eigen_geometry.Quaternion_ğ“£floatğ“¤) -> None: ...
    @overload
    def Append(self, time: float, rotation_matrix: pydrake.math.RotationMatrix_ğ“£floatğ“¤) -> None: ...
    @overload
    def Append(self, time: float, angle_axis: pydrake.common.eigen_geometry.AngleAxis_ğ“£floatğ“¤) -> None: ...
    def angular_acceleration(self, time: float) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def angular_velocity(self, time: float) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def orientation(self, time: float) -> pydrake.common.eigen_geometry.Quaternion_ğ“£floatğ“¤: ...
    def __copy__(self) -> PiecewiseQuaternionSlerp_ğ“£floatğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> PiecewiseQuaternionSlerp_ğ“£floatğ“¤: ...

class PiecewiseTrajectory(Trajectory_ğ“£floatğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def duration(self, segment_index: int) -> float: ...
    @overload
    def end_time(self, segment_index: int) -> float: ...
    @overload
    def end_time(self) -> float: ...
    def get_number_of_segments(self) -> int: ...
    def get_segment_index(self, t: float) -> int: ...
    def get_segment_times(self) -> List[float]: ...
    def is_time_in_range(self, t: float) -> bool: ...
    @overload
    def start_time(self, segment_index: int) -> float: ...
    @overload
    def start_time(self) -> float: ...

class PiecewiseTrajectory_ğ“£AutoDiffXdğ“¤(Trajectory_ğ“£AutoDiffXdğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def duration(self, segment_index: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def end_time(self, segment_index: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def end_time(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_number_of_segments(self) -> int: ...
    def get_segment_index(self, t: pydrake.autodiffutils.AutoDiffXd) -> int: ...
    def get_segment_times(self) -> List[pydrake.autodiffutils.AutoDiffXd]: ...
    def is_time_in_range(self, t: pydrake.autodiffutils.AutoDiffXd) -> bool: ...
    @overload
    def start_time(self, segment_index: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def start_time(self) -> pydrake.autodiffutils.AutoDiffXd: ...

class PiecewiseTrajectory_ğ“£Expressionğ“¤(Trajectory_ğ“£Expressionğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def duration(self, segment_index: int) -> pydrake.symbolic.Expression: ...
    @overload
    def end_time(self, segment_index: int) -> pydrake.symbolic.Expression: ...
    @overload
    def end_time(self) -> pydrake.symbolic.Expression: ...
    def get_number_of_segments(self) -> int: ...
    def get_segment_index(self, t: pydrake.symbolic.Expression) -> int: ...
    def get_segment_times(self) -> List[pydrake.symbolic.Expression]: ...
    def is_time_in_range(self, t: pydrake.symbolic.Expression) -> pydrake.symbolic.Formula: ...
    @overload
    def start_time(self, segment_index: int) -> pydrake.symbolic.Expression: ...
    @overload
    def start_time(self) -> pydrake.symbolic.Expression: ...

class PiecewiseTrajectory_ğ“£floatğ“¤(Trajectory_ğ“£floatğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def duration(self, segment_index: int) -> float: ...
    @overload
    def end_time(self, segment_index: int) -> float: ...
    @overload
    def end_time(self) -> float: ...
    def get_number_of_segments(self) -> int: ...
    def get_segment_index(self, t: float) -> int: ...
    def get_segment_times(self) -> List[float]: ...
    def is_time_in_range(self, t: float) -> bool: ...
    @overload
    def start_time(self, segment_index: int) -> float: ...
    @overload
    def start_time(self) -> float: ...

class StackedTrajectory(Trajectory_ğ“£floatğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, rowwise: bool = ...) -> None: ...
    def Append(self, arg0: Trajectory_ğ“£floatğ“¤) -> None: ...
    def Clone(self) -> Trajectory_ğ“£floatğ“¤: ...
    def __copy__(self) -> StackedTrajectory_ğ“£floatğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> StackedTrajectory_ğ“£floatğ“¤: ...

class StackedTrajectory_ğ“£AutoDiffXdğ“¤(Trajectory_ğ“£AutoDiffXdğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, rowwise: bool = ...) -> None: ...
    def Append(self, arg0: Trajectory_ğ“£AutoDiffXdğ“¤) -> None: ...
    def Clone(self) -> Trajectory_ğ“£AutoDiffXdğ“¤: ...
    def __copy__(self) -> StackedTrajectory_ğ“£AutoDiffXdğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> StackedTrajectory_ğ“£AutoDiffXdğ“¤: ...

class StackedTrajectory_ğ“£Expressionğ“¤(Trajectory_ğ“£Expressionğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, rowwise: bool = ...) -> None: ...
    def Append(self, arg0: Trajectory_ğ“£Expressionğ“¤) -> None: ...
    def Clone(self) -> Trajectory_ğ“£Expressionğ“¤: ...
    def __copy__(self) -> StackedTrajectory_ğ“£Expressionğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> StackedTrajectory_ğ“£Expressionğ“¤: ...

class StackedTrajectory_ğ“£floatğ“¤(Trajectory_ğ“£floatğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, rowwise: bool = ...) -> None: ...
    def Append(self, arg0: Trajectory_ğ“£floatğ“¤) -> None: ...
    def Clone(self) -> Trajectory_ğ“£floatğ“¤: ...
    def __copy__(self) -> StackedTrajectory_ğ“£floatğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> StackedTrajectory_ğ“£floatğ“¤: ...

class Trajectory:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def EvalDerivative(self, t: float, derivative_order: int = ...) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def MakeDerivative(self, derivative_order: int = ...) -> Trajectory_ğ“£floatğ“¤: ...
    def cols(self) -> int: ...
    def end_time(self) -> float: ...
    def has_derivative(self) -> bool: ...
    def rows(self) -> int: ...
    def start_time(self) -> float: ...
    def value(self, t: float) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def vector_values(self, arg0: List[float]) -> numpy.ndarray[numpy.float64[m,n]]: ...

class Trajectory_ğ“£AutoDiffXdğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def EvalDerivative(self, t: pydrake.autodiffutils.AutoDiffXd, derivative_order: int = ...) -> numpy.ndarray[object[m,n]]: ...
    def MakeDerivative(self, derivative_order: int = ...) -> Trajectory_ğ“£AutoDiffXdğ“¤: ...
    def cols(self) -> int: ...
    def end_time(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def has_derivative(self) -> bool: ...
    def rows(self) -> int: ...
    def start_time(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def value(self, t: pydrake.autodiffutils.AutoDiffXd) -> numpy.ndarray[object[m,n]]: ...
    def vector_values(self, arg0: List[pydrake.autodiffutils.AutoDiffXd]) -> numpy.ndarray[object[m,n]]: ...

class Trajectory_ğ“£Expressionğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def EvalDerivative(self, t: pydrake.symbolic.Expression, derivative_order: int = ...) -> numpy.ndarray[object[m,n]]: ...
    def MakeDerivative(self, derivative_order: int = ...) -> Trajectory_ğ“£Expressionğ“¤: ...
    def cols(self) -> int: ...
    def end_time(self) -> pydrake.symbolic.Expression: ...
    def has_derivative(self) -> bool: ...
    def rows(self) -> int: ...
    def start_time(self) -> pydrake.symbolic.Expression: ...
    def value(self, t: pydrake.symbolic.Expression) -> numpy.ndarray[object[m,n]]: ...
    def vector_values(self, arg0: List[pydrake.symbolic.Expression]) -> numpy.ndarray[object[m,n]]: ...

class Trajectory_ğ“£floatğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def EvalDerivative(self, t: float, derivative_order: int = ...) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def MakeDerivative(self, derivative_order: int = ...) -> Trajectory_ğ“£floatğ“¤: ...
    def cols(self) -> int: ...
    def end_time(self) -> float: ...
    def has_derivative(self) -> bool: ...
    def rows(self) -> int: ...
    def start_time(self) -> float: ...
    def value(self, t: float) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def vector_values(self, arg0: List[float]) -> numpy.ndarray[numpy.float64[m,n]]: ...

class _MangledName:
    UNICODE_COMMA: ClassVar[str] = ...
    UNICODE_LEFT_BRACKET: ClassVar[str] = ...
    UNICODE_PERIOD: ClassVar[str] = ...
    UNICODE_RIGHT_BRACKET: ClassVar[str] = ...
    def demangle(self, *args, **kwargs) -> Any: ...
    def mangle(self, name) -> Any: ...
    def module_getattr(self, 
module_name = ..., module_globals = ..., name = ...) -> Any: ...

class _TemporaryName_N5drake12trajectories10TrajectoryIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def EvalDerivative(self, t: pydrake.autodiffutils.AutoDiffXd, derivative_order: int = ...) -> numpy.ndarray[object[m,n]]: ...
    def MakeDerivative(self, derivative_order: int = ...) -> Trajectory_ğ“£AutoDiffXdğ“¤: ...
    def cols(self) -> int: ...
    def end_time(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def has_derivative(self) -> bool: ...
    def rows(self) -> int: ...
    def start_time(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def value(self, t: pydrake.autodiffutils.AutoDiffXd) -> numpy.ndarray[object[m,n]]: ...
    def vector_values(self, arg0: List[pydrake.autodiffutils.AutoDiffXd]) -> numpy.ndarray[object[m,n]]: ...

class _TemporaryName_N5drake12trajectories10TrajectoryINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def EvalDerivative(self, t: pydrake.symbolic.Expression, derivative_order: int = ...) -> numpy.ndarray[object[m,n]]: ...
    def MakeDerivative(self, derivative_order: int = ...) -> Trajectory_ğ“£Expressionğ“¤: ...
    def cols(self) -> int: ...
    def end_time(self) -> pydrake.symbolic.Expression: ...
    def has_derivative(self) -> bool: ...
    def rows(self) -> int: ...
    def start_time(self) -> pydrake.symbolic.Expression: ...
    def value(self, t: pydrake.symbolic.Expression) -> numpy.ndarray[object[m,n]]: ...
    def vector_values(self, arg0: List[pydrake.symbolic.Expression]) -> numpy.ndarray[object[m,n]]: ...

class _TemporaryName_N5drake12trajectories10TrajectoryIdEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def EvalDerivative(self, t: float, derivative_order: int = ...) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def MakeDerivative(self, derivative_order: int = ...) -> Trajectory_ğ“£floatğ“¤: ...
    def cols(self) -> int: ...
    def end_time(self) -> float: ...
    def has_derivative(self) -> bool: ...
    def rows(self) -> int: ...
    def start_time(self) -> float: ...
    def value(self, t: float) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def vector_values(self, arg0: List[float]) -> numpy.ndarray[numpy.float64[m,n]]: ...

class _TemporaryName_N5drake12trajectories13PiecewisePoseIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(PiecewiseTrajectory_ğ“£AutoDiffXdğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, position_trajectory: PiecewisePolynomial_ğ“£AutoDiffXdğ“¤, orientation_trajectory: PiecewiseQuaternionSlerp_ğ“£AutoDiffXdğ“¤) -> None: ...
    def GetAcceleration(self, time: pydrake.autodiffutils.AutoDiffXd) -> numpy.ndarray[object[6,1]]: ...
    def GetPose(self, time: pydrake.autodiffutils.AutoDiffXd) -> pydrake.math.RigidTransform_ğ“£AutoDiffXdğ“¤: ...
    def GetVelocity(self, time: pydrake.autodiffutils.AutoDiffXd) -> numpy.ndarray[object[6,1]]: ...
    def IsApprox(self, other: PiecewisePose_ğ“£AutoDiffXdğ“¤, tol: float) -> bool: ...
    def MakeCubicLinearWithEndLinearVelocity(self, *args, **kwargs) -> Any: ...
    def MakeLinear(self, *args, **kwargs) -> Any: ...
    def get_orientation_trajectory(self) -> PiecewiseQuaternionSlerp_ğ“£AutoDiffXdğ“¤: ...
    def get_position_trajectory(self) -> PiecewisePolynomial_ğ“£AutoDiffXdğ“¤: ...
    def __copy__(self) -> PiecewisePose_ğ“£AutoDiffXdğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePose_ğ“£AutoDiffXdğ“¤: ...

class _TemporaryName_N5drake12trajectories13PiecewisePoseINS_8symbolic10ExpressionEEE(PiecewiseTrajectory_ğ“£Expressionğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, position_trajectory: PiecewisePolynomial_ğ“£Expressionğ“¤, orientation_trajectory: PiecewiseQuaternionSlerp_ğ“£Expressionğ“¤) -> None: ...
    def GetAcceleration(self, time: pydrake.symbolic.Expression) -> numpy.ndarray[object[6,1]]: ...
    def GetPose(self, time: pydrake.symbolic.Expression) -> pydrake.math.RigidTransform_ğ“£Expressionğ“¤: ...
    def GetVelocity(self, time: pydrake.symbolic.Expression) -> numpy.ndarray[object[6,1]]: ...
    def IsApprox(self, other: PiecewisePose_ğ“£Expressionğ“¤, tol: float) -> bool: ...
    def MakeCubicLinearWithEndLinearVelocity(self, *args, **kwargs) -> Any: ...
    def MakeLinear(self, *args, **kwargs) -> Any: ...
    def get_orientation_trajectory(self) -> PiecewiseQuaternionSlerp_ğ“£Expressionğ“¤: ...
    def get_position_trajectory(self) -> PiecewisePolynomial_ğ“£Expressionğ“¤: ...
    def __copy__(self) -> PiecewisePose_ğ“£Expressionğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePose_ğ“£Expressionğ“¤: ...

class _TemporaryName_N5drake12trajectories13PiecewisePoseIdEE(PiecewiseTrajectory_ğ“£floatğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, position_trajectory: PiecewisePolynomial_ğ“£floatğ“¤, orientation_trajectory: PiecewiseQuaternionSlerp_ğ“£floatğ“¤) -> None: ...
    def GetAcceleration(self, time: float) -> numpy.ndarray[numpy.float64[6,1]]: ...
    def GetPose(self, time: float) -> pydrake.math.RigidTransform_ğ“£floatğ“¤: ...
    def GetVelocity(self, time: float) -> numpy.ndarray[numpy.float64[6,1]]: ...
    def IsApprox(self, other: PiecewisePose_ğ“£floatğ“¤, tol: float) -> bool: ...
    def MakeCubicLinearWithEndLinearVelocity(self, *args, **kwargs) -> Any: ...
    def MakeLinear(self, *args, **kwargs) -> Any: ...
    def get_orientation_trajectory(self) -> PiecewiseQuaternionSlerp_ğ“£floatğ“¤: ...
    def get_position_trajectory(self) -> PiecewisePolynomial_ğ“£floatğ“¤: ...
    def __copy__(self) -> PiecewisePose_ğ“£floatğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePose_ğ“£floatğ“¤: ...

class _TemporaryName_N5drake12trajectories17BsplineTrajectoryIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(Trajectory_ğ“£AutoDiffXdğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis_ğ“£AutoDiffXdğ“¤, control_points: List[List[pydrake.autodiffutils.AutoDiffXd]]) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis_ğ“£AutoDiffXdğ“¤, control_points: List[numpy.ndarray[object[m,n]]]) -> None: ...
    def Clone(self) -> Trajectory_ğ“£AutoDiffXdğ“¤: ...
    def CopyBlock(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> BsplineTrajectory_ğ“£AutoDiffXdğ“¤: ...
    def CopyHead(self, n: int) -> BsplineTrajectory_ğ“£AutoDiffXdğ“¤: ...
    def FinalValue(self) -> numpy.ndarray[object[m,n]]: ...
    def InitialValue(self) -> numpy.ndarray[object[m,n]]: ...
    def InsertKnots(self, additional_knots: List[pydrake.autodiffutils.AutoDiffXd]) -> None: ...
    def basis(self) -> pydrake.math.BsplineBasis_ğ“£AutoDiffXdğ“¤: ...
    def control_points(self) -> List[numpy.ndarray[object[m,n]]]: ...
    def num_control_points(self) -> int: ...
    def __copy__(self) -> BsplineTrajectory_ğ“£AutoDiffXdğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> BsplineTrajectory_ğ“£AutoDiffXdğ“¤: ...
    def __getstate__(self) -> Tuple[pydrake.math.BsplineBasis_ğ“£AutoDiffXdğ“¤,List[numpy.ndarray[object[m,n]]]]: ...
    def __setstate__(self, arg0: Tuple[pydrake.math.BsplineBasis_ğ“£AutoDiffXdğ“¤,List[numpy.ndarray[object[m,n]]]]) -> None: ...

class _TemporaryName_N5drake12trajectories17BsplineTrajectoryINS_8symbolic10ExpressionEEE(Trajectory_ğ“£Expressionğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis_ğ“£Expressionğ“¤, control_points: List[List[pydrake.symbolic.Expression]]) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis_ğ“£Expressionğ“¤, control_points: List[numpy.ndarray[object[m,n]]]) -> None: ...
    def Clone(self) -> Trajectory_ğ“£Expressionğ“¤: ...
    def CopyBlock(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> BsplineTrajectory_ğ“£Expressionğ“¤: ...
    def CopyHead(self, n: int) -> BsplineTrajectory_ğ“£Expressionğ“¤: ...
    def FinalValue(self) -> numpy.ndarray[object[m,n]]: ...
    def InitialValue(self) -> numpy.ndarray[object[m,n]]: ...
    def InsertKnots(self, additional_knots: List[pydrake.symbolic.Expression]) -> None: ...
    def basis(self) -> pydrake.math.BsplineBasis_ğ“£Expressionğ“¤: ...
    def control_points(self) -> List[numpy.ndarray[object[m,n]]]: ...
    def num_control_points(self) -> int: ...
    def __copy__(self) -> BsplineTrajectory_ğ“£Expressionğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> BsplineTrajectory_ğ“£Expressionğ“¤: ...
    def __getstate__(self) -> Tuple[pydrake.math.BsplineBasis_ğ“£Expressionğ“¤,List[numpy.ndarray[object[m,n]]]]: ...
    def __setstate__(self, arg0: Tuple[pydrake.math.BsplineBasis_ğ“£Expressionğ“¤,List[numpy.ndarray[object[m,n]]]]) -> None: ...

class _TemporaryName_N5drake12trajectories17BsplineTrajectoryIdEE(Trajectory_ğ“£floatğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis_ğ“£floatğ“¤, control_points: List[List[float]]) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis_ğ“£floatğ“¤, control_points: List[numpy.ndarray[numpy.float64[m,n]]]) -> None: ...
    def Clone(self) -> Trajectory_ğ“£floatğ“¤: ...
    def CopyBlock(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> BsplineTrajectory_ğ“£floatğ“¤: ...
    def CopyHead(self, n: int) -> BsplineTrajectory_ğ“£floatğ“¤: ...
    def FinalValue(self) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def InitialValue(self) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def InsertKnots(self, additional_knots: List[float]) -> None: ...
    def basis(self) -> pydrake.math.BsplineBasis_ğ“£floatğ“¤: ...
    def control_points(self) -> List[numpy.ndarray[numpy.float64[m,n]]]: ...
    def num_control_points(self) -> int: ...
    def __copy__(self) -> BsplineTrajectory_ğ“£floatğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> BsplineTrajectory_ğ“£floatğ“¤: ...
    def __getstate__(self) -> Tuple[pydrake.math.BsplineBasis_ğ“£floatğ“¤,List[numpy.ndarray[numpy.float64[m,n]]]]: ...
    def __setstate__(self, arg0: Tuple[pydrake.math.BsplineBasis_ğ“£floatğ“¤,List[numpy.ndarray[numpy.float64[m,n]]]]) -> None: ...

class _TemporaryName_N5drake12trajectories17StackedTrajectoryIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(Trajectory_ğ“£AutoDiffXdğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, rowwise: bool = ...) -> None: ...
    def Append(self, arg0: Trajectory_ğ“£AutoDiffXdğ“¤) -> None: ...
    def Clone(self) -> Trajectory_ğ“£AutoDiffXdğ“¤: ...
    def __copy__(self) -> StackedTrajectory_ğ“£AutoDiffXdğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> StackedTrajectory_ğ“£AutoDiffXdğ“¤: ...

class _TemporaryName_N5drake12trajectories17StackedTrajectoryINS_8symbolic10ExpressionEEE(Trajectory_ğ“£Expressionğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, rowwise: bool = ...) -> None: ...
    def Append(self, arg0: Trajectory_ğ“£Expressionğ“¤) -> None: ...
    def Clone(self) -> Trajectory_ğ“£Expressionğ“¤: ...
    def __copy__(self) -> StackedTrajectory_ğ“£Expressionğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> StackedTrajectory_ğ“£Expressionğ“¤: ...

class _TemporaryName_N5drake12trajectories17StackedTrajectoryIdEE(Trajectory_ğ“£floatğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, rowwise: bool = ...) -> None: ...
    def Append(self, arg0: Trajectory_ğ“£floatğ“¤) -> None: ...
    def Clone(self) -> Trajectory_ğ“£floatğ“¤: ...
    def __copy__(self) -> StackedTrajectory_ğ“£floatğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> StackedTrajectory_ğ“£floatğ“¤: ...

class _TemporaryName_N5drake12trajectories19PiecewisePolynomialIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(PiecewiseTrajectory_ğ“£AutoDiffXdğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    @overload
    def __init__(self, arg0: List[numpy.ndarray[object[m,n]]], arg1: List[pydrake.autodiffutils.AutoDiffXd]) -> None: ...
    @overload
    def __init__(self, arg0: List[pydrake.polynomial.Polynomial_ğ“£AutoDiffXdğ“¤], arg1: List[pydrake.autodiffutils.AutoDiffXd]) -> None: ...
    def AppendCubicHermiteSegment(self, time: pydrake.autodiffutils.AutoDiffXd, sample: numpy.ndarray[object[m,n],flags.f_contiguous], sample_dot: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    def AppendFirstOrderSegment(self, time: pydrake.autodiffutils.AutoDiffXd, sample: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    def Block(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> PiecewisePolynomial_ğ“£AutoDiffXdğ“¤: ...
    def Clone(self) -> Trajectory_ğ“£AutoDiffXdğ“¤: ...
    def ConcatenateInTime(self, other: PiecewisePolynomial_ğ“£AutoDiffXdğ“¤) -> None: ...
    def CubicHermite(self, *args, **kwargs) -> Any: ...
    def CubicShapePreserving(self, *args, **kwargs) -> Any: ...
    def CubicWithContinuousSecondDerivatives(self, *args, **kwargs) -> Any: ...
    def FirstOrderHold(self, *args, **kwargs) -> Any: ...
    def LagrangeInterpolatingPolynomial(self, *args, **kwargs) -> Any: ...
    def RemoveFinalSegment(self) -> None: ...
    def Reshape(self, rows: int, cols: int) -> None: ...
    def ReverseTime(self) -> None: ...
    def ScaleTime(self, scale: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    def Transpose(self) -> PiecewisePolynomial_ğ“£AutoDiffXdğ“¤: ...
    def ZeroOrderHold(self, *args, **kwargs) -> Any: ...
    @overload
    def derivative(self, derivative_order: int = ...) -> PiecewisePolynomial_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def derivative(self) -> Any: ...
    def getPolynomial(self, segment_index: int, row: int = ..., col: int = ...) -> pydrake.polynomial.Polynomial_ğ“£AutoDiffXdğ“¤: ...
    def getPolynomialMatrix(self, segment_index: int) -> numpy.ndarray[object[m,n]]: ...
    def getSegmentPolynomialDegree(self, segment_index: int, row: int = ..., col: int = ...) -> int: ...
    def isApprox(self, other: PiecewisePolynomial_ğ“£AutoDiffXdğ“¤, tol: float, tol_type: pydrake.common._module_py.ToleranceType = ...) -> bool: ...
    def setPolynomialMatrixBlock(self, replacement: numpy.ndarray[object[m,n]], segment_index: int, row_start: int = ..., col_start: int = ...) -> None: ...
    def shiftRight(self, offset: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    def slice(self, start_segment_index: int, num_segments: int) -> PiecewisePolynomial_ğ“£AutoDiffXdğ“¤: ...
    def __add__(self, arg0: PiecewisePolynomial_ğ“£AutoDiffXdğ“¤) -> PiecewisePolynomial_ğ“£AutoDiffXdğ“¤: ...
    def __copy__(self) -> PiecewisePolynomial_ğ“£AutoDiffXdğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePolynomial_ğ“£AutoDiffXdğ“¤: ...

class _TemporaryName_N5drake12trajectories19PiecewisePolynomialINS_8symbolic10ExpressionEEE(PiecewiseTrajectory_ğ“£Expressionğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    @overload
    def __init__(self, arg0: List[numpy.ndarray[object[m,n]]], arg1: List[pydrake.symbolic.Expression]) -> None: ...
    @overload
    def __init__(self, arg0: List[pydrake.polynomial.Polynomial_ğ“£Expressionğ“¤], arg1: List[pydrake.symbolic.Expression]) -> None: ...
    def AppendCubicHermiteSegment(self, time: pydrake.symbolic.Expression, sample: numpy.ndarray[object[m,n],flags.f_contiguous], sample_dot: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    def AppendFirstOrderSegment(self, time: pydrake.symbolic.Expression, sample: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    def Block(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> PiecewisePolynomial_ğ“£Expressionğ“¤: ...
    def Clone(self) -> Trajectory_ğ“£Expressionğ“¤: ...
    def ConcatenateInTime(self, other: PiecewisePolynomial_ğ“£Expressionğ“¤) -> None: ...
    def CubicHermite(self, *args, **kwargs) -> Any: ...
    def CubicShapePreserving(self, *args, **kwargs) -> Any: ...
    def CubicWithContinuousSecondDerivatives(self, *args, **kwargs) -> Any: ...
    def FirstOrderHold(self, *args, **kwargs) -> Any: ...
    def LagrangeInterpolatingPolynomial(self, *args, **kwargs) -> Any: ...
    def RemoveFinalSegment(self) -> None: ...
    def Reshape(self, rows: int, cols: int) -> None: ...
    def ReverseTime(self) -> None: ...
    def ScaleTime(self, scale: pydrake.symbolic.Expression) -> None: ...
    def Transpose(self) -> PiecewisePolynomial_ğ“£Expressionğ“¤: ...
    def ZeroOrderHold(self, *args, **kwargs) -> Any: ...
    @overload
    def derivative(self, derivative_order: int = ...) -> PiecewisePolynomial_ğ“£Expressionğ“¤: ...
    @overload
    def derivative(self) -> Any: ...
    def getPolynomial(self, segment_index: int, row: int = ..., col: int = ...) -> pydrake.polynomial.Polynomial_ğ“£Expressionğ“¤: ...
    def getPolynomialMatrix(self, segment_index: int) -> numpy.ndarray[object[m,n]]: ...
    def getSegmentPolynomialDegree(self, segment_index: int, row: int = ..., col: int = ...) -> int: ...
    def isApprox(self, other: PiecewisePolynomial_ğ“£Expressionğ“¤, tol: float, tol_type: pydrake.common._module_py.ToleranceType = ...) -> bool: ...
    def setPolynomialMatrixBlock(self, replacement: numpy.ndarray[object[m,n]], segment_index: int, row_start: int = ..., col_start: int = ...) -> None: ...
    def shiftRight(self, offset: pydrake.symbolic.Expression) -> None: ...
    def slice(self, start_segment_index: int, num_segments: int) -> PiecewisePolynomial_ğ“£Expressionğ“¤: ...
    def __add__(self, arg0: PiecewisePolynomial_ğ“£Expressionğ“¤) -> PiecewisePolynomial_ğ“£Expressionğ“¤: ...
    def __copy__(self) -> PiecewisePolynomial_ğ“£Expressionğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePolynomial_ğ“£Expressionğ“¤: ...

class _TemporaryName_N5drake12trajectories19PiecewisePolynomialIdEE(PiecewiseTrajectory_ğ“£floatğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous]) -> None: ...
    @overload
    def __init__(self, arg0: List[numpy.ndarray[object[m,n]]], arg1: List[float]) -> None: ...
    @overload
    def __init__(self, arg0: List[pydrake.polynomial.Polynomial_ğ“£floatğ“¤], arg1: List[float]) -> None: ...
    def AppendCubicHermiteSegment(self, time: float, sample: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], sample_dot: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous]) -> None: ...
    def AppendFirstOrderSegment(self, time: float, sample: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous]) -> None: ...
    def Block(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> PiecewisePolynomial_ğ“£floatğ“¤: ...
    def Clone(self) -> Trajectory_ğ“£floatğ“¤: ...
    def ConcatenateInTime(self, other: PiecewisePolynomial_ğ“£floatğ“¤) -> None: ...
    def CubicHermite(self, *args, **kwargs) -> Any: ...
    def CubicShapePreserving(self, *args, **kwargs) -> Any: ...
    def CubicWithContinuousSecondDerivatives(self, *args, **kwargs) -> Any: ...
    def FirstOrderHold(self, *args, **kwargs) -> Any: ...
    def LagrangeInterpolatingPolynomial(self, *args, **kwargs) -> Any: ...
    def RemoveFinalSegment(self) -> None: ...
    def Reshape(self, rows: int, cols: int) -> None: ...
    def ReverseTime(self) -> None: ...
    def ScaleTime(self, scale: float) -> None: ...
    def Transpose(self) -> PiecewisePolynomial_ğ“£floatğ“¤: ...
    def ZeroOrderHold(self, *args, **kwargs) -> Any: ...
    @overload
    def derivative(self, derivative_order: int = ...) -> PiecewisePolynomial_ğ“£floatğ“¤: ...
    @overload
    def derivative(self) -> Any: ...
    def getPolynomial(self, segment_index: int, row: int = ..., col: int = ...) -> pydrake.polynomial.Polynomial_ğ“£floatğ“¤: ...
    def getPolynomialMatrix(self, segment_index: int) -> numpy.ndarray[object[m,n]]: ...
    def getSegmentPolynomialDegree(self, segment_index: int, row: int = ..., col: int = ...) -> int: ...
    def isApprox(self, other: PiecewisePolynomial_ğ“£floatğ“¤, tol: float, tol_type: pydrake.common._module_py.ToleranceType = ...) -> bool: ...
    def setPolynomialMatrixBlock(self, replacement: numpy.ndarray[object[m,n]], segment_index: int, row_start: int = ..., col_start: int = ...) -> None: ...
    def shiftRight(self, offset: float) -> None: ...
    def slice(self, start_segment_index: int, num_segments: int) -> PiecewisePolynomial_ğ“£floatğ“¤: ...
    def __add__(self, arg0: PiecewisePolynomial_ğ“£floatğ“¤) -> PiecewisePolynomial_ğ“£floatğ“¤: ...
    def __copy__(self) -> PiecewisePolynomial_ğ“£floatğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePolynomial_ğ“£floatğ“¤: ...

class _TemporaryName_N5drake12trajectories19PiecewiseTrajectoryIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(Trajectory_ğ“£AutoDiffXdğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def duration(self, segment_index: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def end_time(self, segment_index: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def end_time(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_number_of_segments(self) -> int: ...
    def get_segment_index(self, t: pydrake.autodiffutils.AutoDiffXd) -> int: ...
    def get_segment_times(self) -> List[pydrake.autodiffutils.AutoDiffXd]: ...
    def is_time_in_range(self, t: pydrake.autodiffutils.AutoDiffXd) -> bool: ...
    @overload
    def start_time(self, segment_index: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def start_time(self) -> pydrake.autodiffutils.AutoDiffXd: ...

class _TemporaryName_N5drake12trajectories19PiecewiseTrajectoryINS_8symbolic10ExpressionEEE(Trajectory_ğ“£Expressionğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def duration(self, segment_index: int) -> pydrake.symbolic.Expression: ...
    @overload
    def end_time(self, segment_index: int) -> pydrake.symbolic.Expression: ...
    @overload
    def end_time(self) -> pydrake.symbolic.Expression: ...
    def get_number_of_segments(self) -> int: ...
    def get_segment_index(self, t: pydrake.symbolic.Expression) -> int: ...
    def get_segment_times(self) -> List[pydrake.symbolic.Expression]: ...
    def is_time_in_range(self, t: pydrake.symbolic.Expression) -> pydrake.symbolic.Formula: ...
    @overload
    def start_time(self, segment_index: int) -> pydrake.symbolic.Expression: ...
    @overload
    def start_time(self) -> pydrake.symbolic.Expression: ...

class _TemporaryName_N5drake12trajectories19PiecewiseTrajectoryIdEE(Trajectory_ğ“£floatğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def duration(self, segment_index: int) -> float: ...
    @overload
    def end_time(self, segment_index: int) -> float: ...
    @overload
    def end_time(self) -> float: ...
    def get_number_of_segments(self) -> int: ...
    def get_segment_index(self, t: float) -> int: ...
    def get_segment_times(self) -> List[float]: ...
    def is_time_in_range(self, t: float) -> bool: ...
    @overload
    def start_time(self, segment_index: int) -> float: ...
    @overload
    def start_time(self) -> float: ...

class _TemporaryName_N5drake12trajectories24PiecewiseQuaternionSlerpIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(PiecewiseTrajectory_ğ“£AutoDiffXdğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.autodiffutils.AutoDiffXd], quaternions: List[pydrake.common.eigen_geometry.Quaternion_ğ“£AutoDiffXdğ“¤]) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.autodiffutils.AutoDiffXd], rotation_matrices: List[numpy.ndarray[object[3,3]]]) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.autodiffutils.AutoDiffXd], rotation_matrices: List[pydrake.math.RotationMatrix_ğ“£AutoDiffXdğ“¤]) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.autodiffutils.AutoDiffXd], angle_axes: List[pydrake.common.eigen_geometry.AngleAxis_ğ“£AutoDiffXdğ“¤]) -> None: ...
    @overload
    def Append(self, time: pydrake.autodiffutils.AutoDiffXd, quaternion: pydrake.common.eigen_geometry.Quaternion_ğ“£AutoDiffXdğ“¤) -> None: ...
    @overload
    def Append(self, time: pydrake.autodiffutils.AutoDiffXd, rotation_matrix: pydrake.math.RotationMatrix_ğ“£AutoDiffXdğ“¤) -> None: ...
    @overload
    def Append(self, time: pydrake.autodiffutils.AutoDiffXd, angle_axis: pydrake.common.eigen_geometry.AngleAxis_ğ“£AutoDiffXdğ“¤) -> None: ...
    def angular_acceleration(self, time: pydrake.autodiffutils.AutoDiffXd) -> numpy.ndarray[object[3,1]]: ...
    def angular_velocity(self, time: pydrake.autodiffutils.AutoDiffXd) -> numpy.ndarray[object[3,1]]: ...
    def orientation(self, time: pydrake.autodiffutils.AutoDiffXd) -> pydrake.common.eigen_geometry.Quaternion_ğ“£AutoDiffXdğ“¤: ...
    def __copy__(self) -> PiecewiseQuaternionSlerp_ğ“£AutoDiffXdğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> PiecewiseQuaternionSlerp_ğ“£AutoDiffXdğ“¤: ...

class _TemporaryName_N5drake12trajectories24PiecewiseQuaternionSlerpINS_8symbolic10ExpressionEEE(PiecewiseTrajectory_ğ“£Expressionğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.symbolic.Expression], quaternions: List[pydrake.common.eigen_geometry.Quaternion_ğ“£Expressionğ“¤]) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.symbolic.Expression], rotation_matrices: List[numpy.ndarray[object[3,3]]]) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.symbolic.Expression], rotation_matrices: List[pydrake.math.RotationMatrix_ğ“£Expressionğ“¤]) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.symbolic.Expression], angle_axes: List[pydrake.common.eigen_geometry.AngleAxis_ğ“£Expressionğ“¤]) -> None: ...
    @overload
    def Append(self, time: pydrake.symbolic.Expression, quaternion: pydrake.common.eigen_geometry.Quaternion_ğ“£Expressionğ“¤) -> None: ...
    @overload
    def Append(self, time: pydrake.symbolic.Expression, rotation_matrix: pydrake.math.RotationMatrix_ğ“£Expressionğ“¤) -> None: ...
    @overload
    def Append(self, time: pydrake.symbolic.Expression, angle_axis: pydrake.common.eigen_geometry.AngleAxis_ğ“£Expressionğ“¤) -> None: ...
    def angular_acceleration(self, time: pydrake.symbolic.Expression) -> numpy.ndarray[object[3,1]]: ...
    def angular_velocity(self, time: pydrake.symbolic.Expression) -> numpy.ndarray[object[3,1]]: ...
    def orientation(self, time: pydrake.symbolic.Expression) -> pydrake.common.eigen_geometry.Quaternion_ğ“£Expressionğ“¤: ...
    def __copy__(self) -> PiecewiseQuaternionSlerp_ğ“£Expressionğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> PiecewiseQuaternionSlerp_ğ“£Expressionğ“¤: ...

class _TemporaryName_N5drake12trajectories24PiecewiseQuaternionSlerpIdEE(PiecewiseTrajectory_ğ“£floatğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, breaks: List[float], quaternions: List[pydrake.common.eigen_geometry.Quaternion_ğ“£floatğ“¤]) -> None: ...
    @overload
    def __init__(self, breaks: List[float], rotation_matrices: List[numpy.ndarray[numpy.float64[3,3]]]) -> None: ...
    @overload
    def __init__(self, breaks: List[float], rotation_matrices: List[pydrake.math.RotationMatrix_ğ“£floatğ“¤]) -> None: ...
    @overload
    def __init__(self, breaks: List[float], angle_axes: List[pydrake.common.eigen_geometry.AngleAxis_ğ“£floatğ“¤]) -> None: ...
    @overload
    def Append(self, time: float, quaternion: pydrake.common.eigen_geometry.Quaternion_ğ“£floatğ“¤) -> None: ...
    @overload
    def Append(self, time: float, rotation_matrix: pydrake.math.RotationMatrix_ğ“£floatğ“¤) -> None: ...
    @overload
    def Append(self, time: float, angle_axis: pydrake.common.eigen_geometry.AngleAxis_ğ“£floatğ“¤) -> None: ...
    def angular_acceleration(self, time: float) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def angular_velocity(self, time: float) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def orientation(self, time: float) -> pydrake.common.eigen_geometry.Quaternion_ğ“£floatğ“¤: ...
    def __copy__(self) -> PiecewiseQuaternionSlerp_ğ“£floatğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> PiecewiseQuaternionSlerp_ğ“£floatğ“¤: ...

class _TemporaryName_N5drake12trajectories27PathParameterizedTrajectoryIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(Trajectory_ğ“£AutoDiffXdğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, path: Trajectory_ğ“£AutoDiffXdğ“¤, time_scaling: Trajectory_ğ“£AutoDiffXdğ“¤) -> None: ...
    def Clone(self) -> Trajectory_ğ“£AutoDiffXdğ“¤: ...
    def path(self) -> Trajectory_ğ“£AutoDiffXdğ“¤: ...
    def time_scaling(self) -> Trajectory_ğ“£AutoDiffXdğ“¤: ...
    def __copy__(self) -> PathParameterizedTrajectory_ğ“£AutoDiffXdğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> PathParameterizedTrajectory_ğ“£AutoDiffXdğ“¤: ...

class _TemporaryName_N5drake12trajectories27PathParameterizedTrajectoryINS_8symbolic10ExpressionEEE(Trajectory_ğ“£Expressionğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, path: Trajectory_ğ“£Expressionğ“¤, time_scaling: Trajectory_ğ“£Expressionğ“¤) -> None: ...
    def Clone(self) -> Trajectory_ğ“£Expressionğ“¤: ...
    def path(self) -> Trajectory_ğ“£Expressionğ“¤: ...
    def time_scaling(self) -> Trajectory_ğ“£Expressionğ“¤: ...
    def __copy__(self) -> PathParameterizedTrajectory_ğ“£Expressionğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> PathParameterizedTrajectory_ğ“£Expressionğ“¤: ...

class _TemporaryName_N5drake12trajectories27PathParameterizedTrajectoryIdEE(Trajectory_ğ“£floatğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, path: Trajectory_ğ“£floatğ“¤, time_scaling: Trajectory_ğ“£floatğ“¤) -> None: ...
    def Clone(self) -> Trajectory_ğ“£floatğ“¤: ...
    def path(self) -> Trajectory_ğ“£floatğ“¤: ...
    def time_scaling(self) -> Trajectory_ğ“£floatğ“¤: ...
    def __copy__(self) -> PathParameterizedTrajectory_ğ“£floatğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> PathParameterizedTrajectory_ğ“£floatğ“¤: ...
