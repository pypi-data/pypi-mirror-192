from typing import Any, ClassVar, List, Optional, Tuple, Union

from typing import overload
import flags
import numpy
import pydrake.autodiffutils
import pydrake.common.cpp_template
import pydrake.common.value
import pydrake.lcm
import pydrake.math
import pydrake.symbolic
import pydrake.systems.framework
ContactSurface_: pydrake.common.cpp_template.TemplateClass
DrakeVisualizer_: pydrake.common.cpp_template.TemplateClass
FramePoseVector_: pydrake.common.cpp_template.TemplateClass
MeshcatPointCloudVisualizer_: pydrake.common.cpp_template.TemplateClass
MeshcatVisualizer_: pydrake.common.cpp_template.TemplateClass
PenetrationAsPointPair_: pydrake.common.cpp_template.TemplateClass
PolygonSurfaceMeshFieldLinear_: pydrake.common.cpp_template.TemplateClass
PolygonSurfaceMesh_: pydrake.common.cpp_template.TemplateClass
QueryObject_: pydrake.common.cpp_template.TemplateClass
SceneGraphInspector_: pydrake.common.cpp_template.TemplateClass
SceneGraph_: pydrake.common.cpp_template.TemplateClass
SignedDistancePair_: pydrake.common.cpp_template.TemplateClass
SignedDistanceToPoint_: pydrake.common.cpp_template.TemplateClass
StartMeshcat: function
TriangleSurfaceMeshFieldLinear_: pydrake.common.cpp_template.TemplateClass
TriangleSurfaceMesh_: pydrake.common.cpp_template.TemplateClass
VolumeMesh_: pydrake.common.cpp_template.TemplateClass
_install_deepnote_nginx: function
_is_listening: function
_start_meshcat_deepnote: function

class Box(Shape):
    @overload
    def __init__(self, width: float, depth: float, height: float) -> None: ...
    @overload
    def __init__(self, measures: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def depth(self) -> float: ...
    def height(self) -> float: ...
    def size(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def width(self) -> float: ...
    def __getstate__(self) -> Tuple[float,float,float]: ...
    def __setstate__(self, arg0: Tuple[float,float,float]) -> None: ...

class Capsule(Shape):
    @overload
    def __init__(self, radius: float, length: float) -> None: ...
    @overload
    def __init__(self, measures: numpy.ndarray[numpy.float64[2,1]]) -> None: ...
    def length(self) -> float: ...
    def radius(self) -> float: ...
    def __getstate__(self) -> Tuple[float,float]: ...
    def __setstate__(self, arg0: Tuple[float,float]) -> None: ...

class CollisionFilterDeclaration:
    def __init__(self) -> None: ...
    def AllowBetween(self, *args, **kwargs) -> Any: ...
    def AllowWithin(self, *args, **kwargs) -> Any: ...
    def ExcludeBetween(self, *args, **kwargs) -> Any: ...
    def ExcludeWithin(self, *args, **kwargs) -> Any: ...

class CollisionFilterManager:
    def __init__(self, *args, **kwargs) -> None: ...
    def Apply(self, declaration: CollisionFilterDeclaration) -> None: ...
    def ApplyTransient(self, *args, **kwargs) -> Any: ...
    def IsActive(self, *args, **kwargs) -> Any: ...
    def RemoveDeclaration(self, *args, **kwargs) -> Any: ...
    def has_transient_history(self) -> bool: ...

class ContactSurface:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def Equal(self, surface: ContactSurface_ğ“£floatğ“¤) -> bool: ...
    def EvaluateGradE_M_W(self, index: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def EvaluateGradE_N_W(self, index: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def HasGradE_M(self) -> bool: ...
    def HasGradE_N(self) -> bool: ...
    def area(self, face_index: int) -> float: ...
    @overload
    def centroid(self, face_index: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    @overload
    def centroid(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def face_normal(self, face_index: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def id_M(self) -> GeometryId: ...
    def id_N(self) -> GeometryId: ...
    def is_triangle(self) -> bool: ...
    def num_faces(self) -> int: ...
    def num_vertices(self) -> int: ...
    def poly_e_MN(self) -> PolygonSurfaceMeshFieldLinear_ğ“£floatğ“¬floatğ“¤: ...
    def poly_mesh_W(self) -> PolygonSurfaceMesh_ğ“£floatğ“¤: ...
    def representation(self) -> HydroelasticContactRepresentation: ...
    def total_area(self) -> float: ...
    def tri_e_MN(self) -> TriangleSurfaceMeshFieldLinear_ğ“£floatğ“¬floatğ“¤: ...
    def tri_mesh_W(self) -> TriangleSurfaceMesh_ğ“£floatğ“¤: ...
    def __copy__(self) -> ContactSurface_ğ“£floatğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> ContactSurface_ğ“£floatğ“¤: ...

class ContactSurface_ğ“£AutoDiffXdğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def Equal(self, surface: ContactSurface_ğ“£AutoDiffXdğ“¤) -> bool: ...
    def EvaluateGradE_M_W(self, index: int) -> numpy.ndarray[object[3,1]]: ...
    def EvaluateGradE_N_W(self, index: int) -> numpy.ndarray[object[3,1]]: ...
    def HasGradE_M(self) -> bool: ...
    def HasGradE_N(self) -> bool: ...
    def area(self, face_index: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def centroid(self, face_index: int) -> numpy.ndarray[object[3,1]]: ...
    @overload
    def centroid(self) -> numpy.ndarray[object[3,1]]: ...
    def face_normal(self, face_index: int) -> numpy.ndarray[object[3,1]]: ...
    def id_M(self) -> GeometryId: ...
    def id_N(self) -> GeometryId: ...
    def is_triangle(self) -> bool: ...
    def num_faces(self) -> int: ...
    def num_vertices(self) -> int: ...
    def poly_e_MN(self) -> PolygonSurfaceMeshFieldLinear_ğ“£AutoDiffXdğ“¬AutoDiffXdğ“¤: ...
    def poly_mesh_W(self) -> PolygonSurfaceMesh_ğ“£AutoDiffXdğ“¤: ...
    def representation(self) -> HydroelasticContactRepresentation: ...
    def total_area(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def tri_e_MN(self) -> TriangleSurfaceMeshFieldLinear_ğ“£AutoDiffXdğ“¬AutoDiffXdğ“¤: ...
    def tri_mesh_W(self) -> TriangleSurfaceMesh_ğ“£AutoDiffXdğ“¤: ...
    def __copy__(self) -> ContactSurface_ğ“£AutoDiffXdğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> ContactSurface_ğ“£AutoDiffXdğ“¤: ...

class ContactSurface_ğ“£floatğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def Equal(self, surface: ContactSurface_ğ“£floatğ“¤) -> bool: ...
    def EvaluateGradE_M_W(self, index: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def EvaluateGradE_N_W(self, index: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def HasGradE_M(self) -> bool: ...
    def HasGradE_N(self) -> bool: ...
    def area(self, face_index: int) -> float: ...
    @overload
    def centroid(self, face_index: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    @overload
    def centroid(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def face_normal(self, face_index: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def id_M(self) -> GeometryId: ...
    def id_N(self) -> GeometryId: ...
    def is_triangle(self) -> bool: ...
    def num_faces(self) -> int: ...
    def num_vertices(self) -> int: ...
    def poly_e_MN(self) -> PolygonSurfaceMeshFieldLinear_ğ“£floatğ“¬floatğ“¤: ...
    def poly_mesh_W(self) -> PolygonSurfaceMesh_ğ“£floatğ“¤: ...
    def representation(self) -> HydroelasticContactRepresentation: ...
    def total_area(self) -> float: ...
    def tri_e_MN(self) -> TriangleSurfaceMeshFieldLinear_ğ“£floatğ“¬floatğ“¤: ...
    def tri_mesh_W(self) -> TriangleSurfaceMesh_ğ“£floatğ“¤: ...
    def __copy__(self) -> ContactSurface_ğ“£floatğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> ContactSurface_ğ“£floatğ“¤: ...

class Convex(Shape):
    @overload
    def __init__(self, filename: str, scale: float = ...) -> None: ...
    @overload
    def __init__(self, absolute_filename: str, scale: float = ...) -> None: ...
    def filename(self) -> str: ...
    def scale(self) -> float: ...
    def __getstate__(self) -> Tuple[str,float]: ...
    def __setstate__(self, arg0: Tuple[str,float]) -> None: ...

class Cylinder(Shape):
    @overload
    def __init__(self, radius: float, length: float) -> None: ...
    @overload
    def __init__(self, measures: numpy.ndarray[numpy.float64[2,1]]) -> None: ...
    def length(self) -> float: ...
    def radius(self) -> float: ...
    def __getstate__(self) -> Tuple[float,float]: ...
    def __setstate__(self, arg0: Tuple[float,float]) -> None: ...

class DrakeVisualizer(pydrake.systems.framework.LeafSystem_ğ“£floatğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, lcm: pydrake.lcm.DrakeLcmInterface = ..., params: DrakeVisualizerParams = ...) -> None: ...
    def AddToBuilder(self, *args, **kwargs) -> Any: ...
    def DispatchLoadMessage(self, *args, **kwargs) -> Any: ...
    def query_object_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£floatğ“¤: ...

class DrakeVisualizerParams:
    __fields__: ClassVar[tuple] = ...  # read-only
    _pybind11_del_orig: ClassVar[None] = ...
    default_color: Rgba
    publish_period: float
    role: Role
    show_hydroelastic: bool
    use_role_channel_suffix: bool
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> DrakeVisualizerParams: ...
    def __deepcopy__(self, arg0: dict) -> DrakeVisualizerParams: ...
    def __del__(self, *args, **kwargs) -> Any: ...

class DrakeVisualizer_ğ“£AutoDiffXdğ“¤(pydrake.systems.framework.LeafSystem_ğ“£AutoDiffXdğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, lcm: pydrake.lcm.DrakeLcmInterface = ..., params: DrakeVisualizerParams = ...) -> None: ...
    def AddToBuilder(self, *args, **kwargs) -> Any: ...
    def DispatchLoadMessage(self, *args, **kwargs) -> Any: ...
    def query_object_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£AutoDiffXdğ“¤: ...

class DrakeVisualizer_ğ“£floatğ“¤(pydrake.systems.framework.LeafSystem_ğ“£floatğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, lcm: pydrake.lcm.DrakeLcmInterface = ..., params: DrakeVisualizerParams = ...) -> None: ...
    def AddToBuilder(self, *args, **kwargs) -> Any: ...
    def DispatchLoadMessage(self, *args, **kwargs) -> Any: ...
    def query_object_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£floatğ“¤: ...

class Ellipsoid(Shape):
    @overload
    def __init__(self, a: float, b: float, c: float) -> None: ...
    @overload
    def __init__(self, measures: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def a(self) -> float: ...
    def b(self) -> float: ...
    def c(self) -> float: ...
    def __getstate__(self) -> Tuple[float,float,float]: ...
    def __setstate__(self, arg0: Tuple[float,float,float]) -> None: ...

class FilterId:
    def __init__(self, *args, **kwargs) -> None: ...
    def get_new_id(self, *args, **kwargs) -> Any: ...
    def get_value(self) -> int: ...
    def is_valid(self) -> bool: ...
    def __eq__(self, arg0: FilterId) -> bool: ...
    def __hash__(self) -> int: ...
    def __lt__(self, arg0: FilterId) -> bool: ...
    def __ne__(self, arg0: FilterId) -> bool: ...

class FrameId:
    def __init__(self, *args, **kwargs) -> None: ...
    def get_new_id(self, *args, **kwargs) -> Any: ...
    def get_value(self) -> int: ...
    def is_valid(self) -> bool: ...
    def __eq__(self, arg0: FrameId) -> bool: ...
    def __hash__(self) -> int: ...
    def __lt__(self, arg0: FrameId) -> bool: ...
    def __ne__(self, arg0: FrameId) -> bool: ...

class FramePoseVector:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def clear(self) -> None: ...
    def has_id(self, id: FrameId) -> bool: ...
    @overload
    def ids(self) -> List[FrameId]: ...
    @overload
    def ids(self) -> Any: ...
    def set_value(self, id: FrameId, value: pydrake.math.RigidTransform_ğ“£floatğ“¤) -> None: ...
    def size(self) -> int: ...
    def value(self, id: FrameId) -> pydrake.math.RigidTransform_ğ“£floatğ“¤: ...

class FramePoseVector_ğ“£AutoDiffXdğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def clear(self) -> None: ...
    def has_id(self, id: FrameId) -> bool: ...
    @overload
    def ids(self) -> List[FrameId]: ...
    @overload
    def ids(self) -> Any: ...
    def set_value(self, id: FrameId, value: pydrake.math.RigidTransform_ğ“£AutoDiffXdğ“¤) -> None: ...
    def size(self) -> int: ...
    def value(self, id: FrameId) -> pydrake.math.RigidTransform_ğ“£AutoDiffXdğ“¤: ...

class FramePoseVector_ğ“£Expressionğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def clear(self) -> None: ...
    def has_id(self, id: FrameId) -> bool: ...
    @overload
    def ids(self) -> List[FrameId]: ...
    @overload
    def ids(self) -> Any: ...
    def set_value(self, id: FrameId, value: pydrake.math.RigidTransform_ğ“£Expressionğ“¤) -> None: ...
    def size(self) -> int: ...
    def value(self, id: FrameId) -> pydrake.math.RigidTransform_ğ“£Expressionğ“¤: ...

class FramePoseVector_ğ“£floatğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def clear(self) -> None: ...
    def has_id(self, id: FrameId) -> bool: ...
    @overload
    def ids(self) -> List[FrameId]: ...
    @overload
    def ids(self) -> Any: ...
    def set_value(self, id: FrameId, value: pydrake.math.RigidTransform_ğ“£floatğ“¤) -> None: ...
    def size(self) -> int: ...
    def value(self, id: FrameId) -> pydrake.math.RigidTransform_ğ“£floatğ“¤: ...

class GeometryFrame:
    def __init__(self, frame_name: str, frame_group_id: int = ...) -> None: ...
    def frame_group(self) -> int: ...
    def id(self, *args, **kwargs) -> Any: ...
    def name(self) -> str: ...
    def __copy__(self) -> GeometryFrame: ...
    def __deepcopy__(self, arg0: dict) -> GeometryFrame: ...

class GeometryId:
    def __init__(self, *args, **kwargs) -> None: ...
    def get_new_id(self, *args, **kwargs) -> Any: ...
    def get_value(self) -> int: ...
    def is_valid(self) -> bool: ...
    def __eq__(self, arg0: GeometryId) -> bool: ...
    def __hash__(self) -> int: ...
    def __lt__(self, arg0: GeometryId) -> bool: ...
    def __ne__(self, arg0: GeometryId) -> bool: ...

class GeometryInstance:
    def __init__(self, *args, **kwargs) -> None: ...
    def id(self, *args, **kwargs) -> Any: ...
    def illustration_properties(self, *args, **kwargs) -> Any: ...
    def mutable_illustration_properties(self, *args, **kwargs) -> Any: ...
    def mutable_perception_properties(self, *args, **kwargs) -> Any: ...
    def mutable_proximity_properties(self, *args, **kwargs) -> Any: ...
    def name(self) -> str: ...
    def perception_properties(self, *args, **kwargs) -> Any: ...
    def pose(self) -> pydrake.math.RigidTransform_ğ“£floatğ“¤: ...
    def proximity_properties(self, *args, **kwargs) -> Any: ...
    def release_shape(self, *args, **kwargs) -> Any: ...
    def set_illustration_properties(self, *args, **kwargs) -> Any: ...
    def set_name(self, arg0: str) -> None: ...
    def set_perception_properties(self, *args, **kwargs) -> Any: ...
    def set_pose(self, X_PG: pydrake.math.RigidTransform_ğ“£floatğ“¤) -> None: ...
    def set_proximity_properties(self, *args, **kwargs) -> Any: ...
    def shape(self, *args, **kwargs) -> Any: ...
    def __copy__(self) -> GeometryInstance: ...
    def __deepcopy__(self, arg0: dict) -> GeometryInstance: ...

class GeometryProperties:
    def __init__(self, *args, **kwargs) -> None: ...
    def AddProperty(self, group_name: str, name: str, value: object) -> None: ...
    def GetGroupNames(self) -> Set[str]: ...
    def GetPropertiesInGroup(self, group_name: str) -> dict: ...
    def GetProperty(self, group_name: str, name: str) -> object: ...
    def GetPropertyOrDefault(self, group_name: str, name: str, default_value: object) -> object: ...
    def HasGroup(self, group_name: str) -> bool: ...
    def HasProperty(self, group_name: str, name: str) -> bool: ...
    def RemoveProperty(self, group_name: str, name: str) -> bool: ...
    def UpdateProperty(self, group_name: str, name: str, value: object) -> None: ...
    def default_group_name(self, *args, **kwargs) -> Any: ...
    def num_groups(self) -> int: ...

class GeometrySet:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, geometry_ids) -> None: ...
    @overload
    def __init__(self, frame_ids) -> None: ...
    @overload
    def __init__(self, geometry_ids, frame_ids) -> None: ...
    @overload
    def Add(self, geometry_ids) -> None: ...
    @overload
    def Add(self, frame_ids) -> None: ...
    @overload
    def Add(self, geometry_ids, frame_ids) -> None: ...

class GeometryVersion:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: GeometryVersion) -> None: ...
    def IsSameAs(self, *args, **kwargs) -> Any: ...
    def __copy__(self) -> GeometryVersion: ...
    def __deepcopy__(self, arg0: dict) -> GeometryVersion: ...

class HalfSpace(Shape):
    def __init__(self) -> None: ...
    def MakePose(self, *args, **kwargs) -> Any: ...

class HydroelasticContactRepresentation:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    _pybind11_del_orig: ClassVar[None] = ...
    kPolygon: ClassVar[HydroelasticContactRepresentation] = ...
    kTriangle: ClassVar[HydroelasticContactRepresentation] = ...
    def __init__(self, value: int) -> None: ...
    def __del__(self, *args, **kwargs) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class IllustrationProperties(GeometryProperties):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: IllustrationProperties) -> None: ...
    def __copy__(self) -> IllustrationProperties: ...
    def __deepcopy__(self, arg0: dict) -> IllustrationProperties: ...

class Mesh(Shape):
    @overload
    def __init__(self, filename: str, scale: float = ...) -> None: ...
    @overload
    def __init__(self, absolute_filename: str, scale: float = ...) -> None: ...
    def filename(self) -> str: ...
    def scale(self) -> float: ...
    def __getstate__(self) -> Tuple[str,float]: ...
    def __setstate__(self, arg0: Tuple[str,float]) -> None: ...

class Meshcat:
    class Gamepad:
        __fields__: ClassVar[tuple] = ...  # read-only
        axes: List[float]
        button_values: List[float]
        index: Optional[int]
        def __init__(self, **kwargs) -> None: ...
        def __copy__(self) -> Meshcat.Gamepad: ...
        def __deepcopy__(self, arg0: dict) -> Meshcat.Gamepad: ...

    class OrthographicCamera:
        __fields__: ClassVar[tuple] = ...  # read-only
        bottom: float
        far: float
        left: float
        near: float
        right: float
        top: float
        zoom: float
        def __init__(self, **kwargs) -> None: ...
        def __copy__(self) -> Meshcat.OrthographicCamera: ...
        def __deepcopy__(self, arg0: dict) -> Meshcat.OrthographicCamera: ...

    class PerspectiveCamera:
        __fields__: ClassVar[tuple] = ...  # read-only
        aspect: float
        far: float
        fov: float
        near: float
        zoom: float
        def __init__(self, **kwargs) -> None: ...
        def __copy__(self) -> Meshcat.PerspectiveCamera: ...
        def __deepcopy__(self, arg0: dict) -> Meshcat.PerspectiveCamera: ...
    @overload
    def __init__(self, port: Optional[int] = ...) -> None: ...
    @overload
    def __init__(self, params: MeshcatParams) -> None: ...
    def AddButton(self, name: str, keycode: str = ...) -> None: ...
    def AddSlider(self, name: str, min: float, max: float, step: float, value: float, decrement_keycode: str = ..., increment_keycode: str = ...) -> None: ...
    def Delete(self, path: str = ...) -> None: ...
    def DeleteAddedControls(self) -> None: ...
    def DeleteButton(self, name: str) -> None: ...
    def DeleteSlider(self, name: str) -> None: ...
    def Flush(self) -> None: ...
    def GetButtonClicks(self, name: str) -> int: ...
    def GetGamepad(self, *args, **kwargs) -> Any: ...
    def GetNumActiveConnections(self) -> int: ...
    def GetSliderValue(self, name: str) -> float: ...
    def HasPath(self, path: str) -> bool: ...
    def ResetRenderMode(self) -> None: ...
    def Set2dRenderMode(self, X_WC: pydrake.math.RigidTransform_ğ“£floatğ“¤ = ..., xmin: float = ..., xmax: float = ..., ymin: float = ..., ymax: float = ...) -> None: ...
    def SetAnimation(self, *args, **kwargs) -> Any: ...
    def SetCamera(self, *args, **kwargs) -> Any: ...
    def SetLine(self, path: str, vertices: numpy.ndarray[numpy.float64[3,n],flags.f_contiguous], line_width: float = ..., rgba: Rgba = ...) -> None: ...
    def SetLineSegments(self, path: str, start: numpy.ndarray[numpy.float64[3,n],flags.f_contiguous], end: numpy.ndarray[numpy.float64[3,n],flags.f_contiguous], line_width: float = ..., rgba: Rgba = ...) -> None: ...
    @overload
    def SetObject(self, path: str, shape: Shape, rgba: Rgba = ...) -> None: ...
    @overload
    def SetObject(self, path: str, mesh: TriangleSurfaceMesh_ğ“£floatğ“¤, rgba: Rgba = ..., wireframe: bool = ..., wireframe_line_width: float = ...) -> None: ...
    @overload
    def SetProperty(self, path: str, property: str, value: bool) -> None: ...
    @overload
    def SetProperty(self, path: str, property: str, value: float) -> None: ...
    @overload
    def SetProperty(self, path: str, property: str, value: List[float]) -> None: ...
    def SetRealtimeRate(self, rate: float) -> None: ...
    def SetSliderValue(self, name: str, value: float) -> None: ...
    @overload
    def SetTransform(self, path: str, X_ParentPath: pydrake.math.RigidTransform_ğ“£floatğ“¤) -> None: ...
    @overload
    def SetTransform(self, path: str, matrix: numpy.ndarray[numpy.float64[4,4],flags.f_contiguous]) -> None: ...
    def SetTriangleColorMesh(self, path: str, vertices: numpy.ndarray[numpy.float64[3,n],flags.f_contiguous], faces: numpy.ndarray[numpy.int32[3,n],flags.f_contiguous], colors: numpy.ndarray[numpy.float64[3,n],flags.f_contiguous], wireframe: bool = ..., wireframe_line_width: float = ...) -> None: ...
    def SetTriangleMesh(self, path: str, vertices: numpy.ndarray[numpy.float64[3,n],flags.f_contiguous], faces: numpy.ndarray[numpy.int32[3,n],flags.f_contiguous], rgba: Rgba = ..., wireframe: bool = ..., wireframe_line_width: float = ...) -> None: ...
    def StaticHtml(self) -> str: ...
    def port(self) -> int: ...
    def web_url(self) -> str: ...
    def ws_url(self) -> str: ...

class MeshcatAnimation:
    class LoopMode:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        _pybind11_del_orig: ClassVar[None] = ...
        kLoopOnce: ClassVar[MeshcatAnimation.LoopMode] = ...
        kLoopPingPong: ClassVar[MeshcatAnimation.LoopMode] = ...
        kLoopRepeat: ClassVar[MeshcatAnimation.LoopMode] = ...
        def __init__(self, value: int) -> None: ...
        def __del__(self, *args, **kwargs) -> Any: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    def __init__(self, frames_per_second: float = ...) -> None: ...
    @overload
    def SetProperty(self, frame: int, path: str, property: str, value: bool) -> None: ...
    @overload
    def SetProperty(self, frame: int, path: str, property: str, value: float) -> None: ...
    @overload
    def SetProperty(self, frame: int, path: str, property: str, value: List[float]) -> None: ...
    def SetTransform(self, frame: int, path: str, X_ParentPath: pydrake.math.RigidTransform_ğ“£floatğ“¤) -> None: ...
    def autoplay(self) -> bool: ...
    def clamp_when_finished(self) -> bool: ...
    def frame(self, time_from_start: float) -> int: ...
    def frames_per_second(self) -> float: ...
    def loop_mode(self, *args, **kwargs) -> Any: ...
    def repetitions(self) -> int: ...
    def set_autoplay(self, play: bool) -> None: ...
    def set_clamp_when_finished(self, clamp: bool) -> None: ...
    def set_loop_mode(self, *args, **kwargs) -> Any: ...
    def set_repetitions(self, repetitions: int) -> None: ...

class MeshcatCone(Shape):
    @overload
    def __init__(self, height: float, a: float = ..., b: float = ...) -> None: ...
    @overload
    def __init__(self, measures: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def a(self) -> float: ...
    def b(self) -> float: ...
    def height(self) -> float: ...
    def __getstate__(self) -> Tuple[float,float,float]: ...
    def __setstate__(self, arg0: Tuple[float,float,float]) -> None: ...

class MeshcatParams:
    __fields__: ClassVar[tuple] = ...  # read-only
    host: str
    port: Optional[int]
    show_stats_plot: bool
    web_url_pattern: str
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> MeshcatParams: ...
    def __deepcopy__(self, arg0: dict) -> MeshcatParams: ...

class MeshcatPointCloudVisualizer(pydrake.systems.framework.LeafSystem_ğ“£floatğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, meshcat: Meshcat, path: str, publish_period: float = ...) -> None: ...
    @overload
    def Delete(self) -> None: ...
    @overload
    def Delete(self, path) -> Any: ...
    def cloud_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£floatğ“¤: ...
    def pose_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£floatğ“¤: ...
    def set_default_rgba(self, arg0: Rgba) -> None: ...
    def set_point_size(self, arg0: float) -> None: ...

class MeshcatPointCloudVisualizer_ğ“£AutoDiffXdğ“¤(pydrake.systems.framework.LeafSystem_ğ“£AutoDiffXdğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, meshcat: Meshcat, path: str, publish_period: float = ...) -> None: ...
    @overload
    def Delete(self) -> None: ...
    @overload
    def Delete(self, path) -> Any: ...
    def cloud_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£AutoDiffXdğ“¤: ...
    def pose_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£AutoDiffXdğ“¤: ...
    def set_default_rgba(self, arg0: Rgba) -> None: ...
    def set_point_size(self, arg0: float) -> None: ...

class MeshcatPointCloudVisualizer_ğ“£floatğ“¤(pydrake.systems.framework.LeafSystem_ğ“£floatğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, meshcat: Meshcat, path: str, publish_period: float = ...) -> None: ...
    @overload
    def Delete(self) -> None: ...
    @overload
    def Delete(self, path) -> Any: ...
    def cloud_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£floatğ“¤: ...
    def pose_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£floatğ“¤: ...
    def set_default_rgba(self, arg0: Rgba) -> None: ...
    def set_point_size(self, arg0: float) -> None: ...

class MeshcatVisualizer(pydrake.systems.framework.LeafSystem_ğ“£floatğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, meshcat: Meshcat, params: MeshcatVisualizerParams = ...) -> None: ...
    def AddToBuilder(self, *args, **kwargs) -> Any: ...
    def Delete(self) -> None: ...
    def DeleteRecording(self) -> None: ...
    def PublishRecording(self) -> None: ...
    def StartRecording(self, set_transforms_while_recording: bool = ...) -> MeshcatAnimation: ...
    def StopRecording(self) -> None: ...
    def get_mutable_recording(self) -> MeshcatAnimation: ...
    def query_object_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£floatğ“¤: ...

class MeshcatVisualizerParams:
    __fields__: ClassVar[tuple] = ...  # read-only
    _pybind11_del_orig: ClassVar[None] = ...
    default_color: Rgba
    delete_on_initialization_event: bool
    enable_alpha_slider: bool
    prefix: str
    publish_period: float
    role: Role
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> MeshcatVisualizerParams: ...
    def __deepcopy__(self, arg0: dict) -> MeshcatVisualizerParams: ...
    def __del__(self, *args, **kwargs) -> Any: ...

class MeshcatVisualizer_ğ“£AutoDiffXdğ“¤(pydrake.systems.framework.LeafSystem_ğ“£AutoDiffXdğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, meshcat: Meshcat, params: MeshcatVisualizerParams = ...) -> None: ...
    def AddToBuilder(self, *args, **kwargs) -> Any: ...
    def Delete(self) -> None: ...
    def DeleteRecording(self) -> None: ...
    def PublishRecording(self) -> None: ...
    def StartRecording(self, set_transforms_while_recording: bool = ...) -> MeshcatAnimation: ...
    def StopRecording(self) -> None: ...
    def get_mutable_recording(self) -> MeshcatAnimation: ...
    def query_object_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£AutoDiffXdğ“¤: ...

class MeshcatVisualizer_ğ“£floatğ“¤(pydrake.systems.framework.LeafSystem_ğ“£floatğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, meshcat: Meshcat, params: MeshcatVisualizerParams = ...) -> None: ...
    def AddToBuilder(self, *args, **kwargs) -> Any: ...
    def Delete(self) -> None: ...
    def DeleteRecording(self) -> None: ...
    def PublishRecording(self) -> None: ...
    def StartRecording(self, set_transforms_while_recording: bool = ...) -> MeshcatAnimation: ...
    def StopRecording(self) -> None: ...
    def get_mutable_recording(self) -> MeshcatAnimation: ...
    def query_object_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£floatğ“¤: ...

class PenetrationAsPointPair:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    depth: float
    id_A: GeometryId
    id_B: GeometryId
    nhat_BA_W: numpy.ndarray[numpy.float64[3,1]]
    p_WCa: numpy.ndarray[numpy.float64[3,1]]
    p_WCb: numpy.ndarray[numpy.float64[3,1]]
    def __init__(self, **kwargs) -> None: ...

class PenetrationAsPointPair_ğ“£AutoDiffXdğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    depth: pydrake.autodiffutils.AutoDiffXd
    id_A: GeometryId
    id_B: GeometryId
    nhat_BA_W: numpy.ndarray[object[3,1]]
    p_WCa: numpy.ndarray[object[3,1]]
    p_WCb: numpy.ndarray[object[3,1]]
    def __init__(self, **kwargs) -> None: ...

class PenetrationAsPointPair_ğ“£Expressionğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    depth: pydrake.symbolic.Expression
    id_A: GeometryId
    id_B: GeometryId
    nhat_BA_W: numpy.ndarray[object[3,1]]
    p_WCa: numpy.ndarray[object[3,1]]
    p_WCb: numpy.ndarray[object[3,1]]
    def __init__(self, **kwargs) -> None: ...

class PenetrationAsPointPair_ğ“£floatğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    depth: float
    id_A: GeometryId
    id_B: GeometryId
    nhat_BA_W: numpy.ndarray[numpy.float64[3,1]]
    p_WCa: numpy.ndarray[numpy.float64[3,1]]
    p_WCb: numpy.ndarray[numpy.float64[3,1]]
    def __init__(self, **kwargs) -> None: ...

class PerceptionProperties(GeometryProperties):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: PerceptionProperties) -> None: ...
    def __copy__(self) -> PerceptionProperties: ...
    def __deepcopy__(self, arg0: dict) -> PerceptionProperties: ...

class PolygonSurfaceMesh:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, face_data: List[int], vertices: List[numpy.ndarray[numpy.float64[3,1]]]) -> None: ...
    def CalcBoundingBox(self) -> Tuple[numpy.ndarray[numpy.float64[3,1]],numpy.ndarray[numpy.float64[3,1]]]: ...
    def Equal(self, mesh: PolygonSurfaceMesh_ğ“£floatğ“¤) -> bool: ...
    def area(self, f: int) -> float: ...
    def centroid(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def element(self, e: int) -> SurfacePolygon: ...
    def element_centroid(self, e: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def face_data(self) -> List[int]: ...
    def face_normal(self, f: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def num_elements(self) -> int: ...
    def num_faces(self) -> int: ...
    def num_vertices(self) -> int: ...
    def total_area(self) -> float: ...
    def vertex(self, v: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def __copy__(self) -> PolygonSurfaceMesh_ğ“£floatğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> PolygonSurfaceMesh_ğ“£floatğ“¤: ...

class PolygonSurfaceMeshFieldLinear:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def EvaluateAtVertex(self, v: int) -> float: ...
    def EvaluateCartesian(self, e: int, p_MQ: numpy.ndarray[numpy.float64[3,1]]) -> float: ...
    def EvaluateGradient(self, e: int) -> numpy.ndarray[numpy.float64[3,1]]: ...

class PolygonSurfaceMeshFieldLinear_ğ“£AutoDiffXdğ“¬AutoDiffXdğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def EvaluateAtVertex(self, v: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    def EvaluateCartesian(self, e: int, p_MQ: numpy.ndarray[object[3,1]]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def EvaluateGradient(self, e: int) -> numpy.ndarray[object[3,1]]: ...

class PolygonSurfaceMeshFieldLinear_ğ“£floatğ“¬floatğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def EvaluateAtVertex(self, v: int) -> float: ...
    def EvaluateCartesian(self, e: int, p_MQ: numpy.ndarray[numpy.float64[3,1]]) -> float: ...
    def EvaluateGradient(self, e: int) -> numpy.ndarray[numpy.float64[3,1]]: ...

class PolygonSurfaceMesh_ğ“£AutoDiffXdğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, face_data: List[int], vertices: List[numpy.ndarray[object[3,1]]]) -> None: ...
    def CalcBoundingBox(self) -> Tuple[numpy.ndarray[object[3,1]],numpy.ndarray[object[3,1]]]: ...
    def Equal(self, mesh: PolygonSurfaceMesh_ğ“£AutoDiffXdğ“¤) -> bool: ...
    def area(self, f: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    def centroid(self) -> numpy.ndarray[object[3,1]]: ...
    def element(self, e: int) -> SurfacePolygon: ...
    def element_centroid(self, e: int) -> numpy.ndarray[object[3,1]]: ...
    def face_data(self) -> List[int]: ...
    def face_normal(self, f: int) -> numpy.ndarray[object[3,1]]: ...
    def num_elements(self) -> int: ...
    def num_faces(self) -> int: ...
    def num_vertices(self) -> int: ...
    def total_area(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def vertex(self, v: int) -> numpy.ndarray[object[3,1]]: ...
    def __copy__(self) -> PolygonSurfaceMesh_ğ“£AutoDiffXdğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> PolygonSurfaceMesh_ğ“£AutoDiffXdğ“¤: ...

class PolygonSurfaceMesh_ğ“£floatğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, face_data: List[int], vertices: List[numpy.ndarray[numpy.float64[3,1]]]) -> None: ...
    def CalcBoundingBox(self) -> Tuple[numpy.ndarray[numpy.float64[3,1]],numpy.ndarray[numpy.float64[3,1]]]: ...
    def Equal(self, mesh: PolygonSurfaceMesh_ğ“£floatğ“¤) -> bool: ...
    def area(self, f: int) -> float: ...
    def centroid(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def element(self, e: int) -> SurfacePolygon: ...
    def element_centroid(self, e: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def face_data(self) -> List[int]: ...
    def face_normal(self, f: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def num_elements(self) -> int: ...
    def num_faces(self) -> int: ...
    def num_vertices(self) -> int: ...
    def total_area(self) -> float: ...
    def vertex(self, v: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def __copy__(self) -> PolygonSurfaceMesh_ğ“£floatğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> PolygonSurfaceMesh_ğ“£floatğ“¤: ...

class ProximityProperties(GeometryProperties):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: ProximityProperties) -> None: ...
    def __copy__(self) -> ProximityProperties: ...
    def __deepcopy__(self, arg0: dict) -> ProximityProperties: ...

class QueryObject:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def ComputeContactSurfaces(self, *args, **kwargs) -> Any: ...
    def ComputeContactSurfacesWithFallback(self, *args, **kwargs) -> Any: ...
    def ComputePointPairPenetration(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistancePairClosestPoints(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistancePairwiseClosestPoints(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistanceToPoint(self, *args, **kwargs) -> Any: ...
    def FindCollisionCandidates(self, *args, **kwargs) -> Any: ...
    @overload
    def GetPoseInParent(self, frame_id: FrameId) -> pydrake.math.RigidTransform_ğ“£floatğ“¤: ...
    @overload
    def GetPoseInParent(self) -> Any: ...
    @overload
    def GetPoseInWorld(self, frame_id: FrameId) -> pydrake.math.RigidTransform_ğ“£floatğ“¤: ...
    @overload
    def GetPoseInWorld(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform_ğ“£floatğ“¤: ...
    def HasCollisions(self) -> bool: ...
    def RenderColorImage(self, *args, **kwargs) -> Any: ...
    def RenderDepthImage(self, *args, **kwargs) -> Any: ...
    def RenderLabelImage(self, *args, **kwargs) -> Any: ...
    def inspector(self) -> SceneGraphInspector_ğ“£floatğ“¤: ...

class QueryObject_ğ“£AutoDiffXdğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def ComputeContactSurfaces(self, *args, **kwargs) -> Any: ...
    def ComputeContactSurfacesWithFallback(self, *args, **kwargs) -> Any: ...
    def ComputePointPairPenetration(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistancePairClosestPoints(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistancePairwiseClosestPoints(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistanceToPoint(self, *args, **kwargs) -> Any: ...
    def FindCollisionCandidates(self, *args, **kwargs) -> Any: ...
    @overload
    def GetPoseInParent(self, frame_id: FrameId) -> pydrake.math.RigidTransform_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def GetPoseInParent(self) -> Any: ...
    @overload
    def GetPoseInWorld(self, frame_id: FrameId) -> pydrake.math.RigidTransform_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def GetPoseInWorld(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform_ğ“£AutoDiffXdğ“¤: ...
    def HasCollisions(self) -> bool: ...
    def RenderColorImage(self, *args, **kwargs) -> Any: ...
    def RenderDepthImage(self, *args, **kwargs) -> Any: ...
    def RenderLabelImage(self, *args, **kwargs) -> Any: ...
    def inspector(self) -> SceneGraphInspector_ğ“£AutoDiffXdğ“¤: ...

class QueryObject_ğ“£Expressionğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def ComputePointPairPenetration(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistancePairClosestPoints(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistancePairwiseClosestPoints(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistanceToPoint(self, *args, **kwargs) -> Any: ...
    def FindCollisionCandidates(self, *args, **kwargs) -> Any: ...
    @overload
    def GetPoseInParent(self, frame_id: FrameId) -> pydrake.math.RigidTransform_ğ“£Expressionğ“¤: ...
    @overload
    def GetPoseInParent(self) -> Any: ...
    @overload
    def GetPoseInWorld(self, frame_id: FrameId) -> pydrake.math.RigidTransform_ğ“£Expressionğ“¤: ...
    @overload
    def GetPoseInWorld(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform_ğ“£Expressionğ“¤: ...
    def HasCollisions(self) -> bool: ...
    def RenderColorImage(self, *args, **kwargs) -> Any: ...
    def RenderDepthImage(self, *args, **kwargs) -> Any: ...
    def RenderLabelImage(self, *args, **kwargs) -> Any: ...
    def inspector(self) -> SceneGraphInspector_ğ“£Expressionğ“¤: ...

class QueryObject_ğ“£floatğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def ComputeContactSurfaces(self, *args, **kwargs) -> Any: ...
    def ComputeContactSurfacesWithFallback(self, *args, **kwargs) -> Any: ...
    def ComputePointPairPenetration(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistancePairClosestPoints(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistancePairwiseClosestPoints(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistanceToPoint(self, *args, **kwargs) -> Any: ...
    def FindCollisionCandidates(self, *args, **kwargs) -> Any: ...
    @overload
    def GetPoseInParent(self, frame_id: FrameId) -> pydrake.math.RigidTransform_ğ“£floatğ“¤: ...
    @overload
    def GetPoseInParent(self) -> Any: ...
    @overload
    def GetPoseInWorld(self, frame_id: FrameId) -> pydrake.math.RigidTransform_ğ“£floatğ“¤: ...
    @overload
    def GetPoseInWorld(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform_ğ“£floatğ“¤: ...
    def HasCollisions(self) -> bool: ...
    def RenderColorImage(self, *args, **kwargs) -> Any: ...
    def RenderDepthImage(self, *args, **kwargs) -> Any: ...
    def RenderLabelImage(self, *args, **kwargs) -> Any: ...
    def inspector(self) -> SceneGraphInspector_ğ“£floatğ“¤: ...

class Rgba:
    __fields__: ClassVar[tuple] = ...  # read-only
    _pybind11_del_orig: ClassVar[None] = ...
    __hash__: ClassVar[None] = ...
    rgba: numpy.ndarray[numpy.float64[4,1]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, r: float, g: float, b: float, a: float = ...) -> None: ...
    def a(self) -> float: ...
    def b(self) -> float: ...
    def g(self) -> float: ...
    def r(self) -> float: ...
    @overload
    def set(self, r: float, g: float, b: float, a: float = ...) -> None: ...
    @overload
    def set(self, rgba: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def __copy__(self) -> Rgba: ...
    def __deepcopy__(self, arg0: dict) -> Rgba: ...
    def __del__(self, *args, **kwargs) -> Any: ...
    def __eq__(self, arg0: Rgba) -> bool: ...
    def __ne__(self, arg0: Rgba) -> bool: ...

class Role:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    _pybind11_del_orig: ClassVar[None] = ...
    kIllustration: ClassVar[Role] = ...
    kPerception: ClassVar[Role] = ...
    kProximity: ClassVar[Role] = ...
    kUnassigned: ClassVar[Role] = ...
    def __init__(self, value: int) -> None: ...
    def __del__(self, *args, **kwargs) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class RoleAssign:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    _pybind11_del_orig: ClassVar[None] = ...
    kNew: ClassVar[RoleAssign] = ...
    kReplace: ClassVar[RoleAssign] = ...
    def __init__(self, value: int) -> None: ...
    def __del__(self, *args, **kwargs) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class SceneGraph(pydrake.systems.framework.LeafSystem_ğ“£floatğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def AddRenderer(self, name: str, renderer: render.RenderEngine) -> None: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: ProximityProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_ğ“£floatğ“¤, source_id: SourceId, geometry_id: GeometryId, properties: ProximityProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, ProximityProperties) -> Any: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: PerceptionProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_ğ“£floatğ“¤, source_id: SourceId, geometry_id: GeometryId, properties: PerceptionProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, PerceptionProperties) -> Any: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: IllustrationProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_ğ“£floatğ“¤, source_id: SourceId, geometry_id: GeometryId, properties: IllustrationProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, IllustrationProperties) -> Any: ...
    def HasRenderer(self, name: str) -> bool: ...
    def RegisterAnchoredGeometry(self, source_id: SourceId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterFrame(self, source_id: SourceId, frame: GeometryFrame) -> FrameId: ...
    @overload
    def RegisterFrame(self, source_id: SourceId, parent_id: FrameId, frame: GeometryFrame) -> FrameId: ...
    @overload
    def RegisterGeometry(self, source_id: SourceId, frame_id: FrameId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self, source_id: SourceId, geometry_id: GeometryId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self, frame_id) -> Any: ...
    @overload
    def RegisterGeometry(self, context: pydrake.systems.framework.Context_ğ“£floatğ“¤, source_id: SourceId, geometry_id: GeometryId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self) -> Any: ...
    @overload
    def RegisterGeometry(self, context: pydrake.systems.framework.Context_ğ“£floatğ“¤, source_id: SourceId, frame_id: FrameId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self) -> Any: ...
    def RegisterSource(self, name: str = ...) -> SourceId: ...
    @overload
    def RemoveGeometry(self, source_id: SourceId, geometry_id: GeometryId) -> None: ...
    @overload
    def RemoveGeometry(self, context: pydrake.systems.framework.Context_ğ“£floatğ“¤, source_id: SourceId, geometry_id: GeometryId) -> None: ...
    @overload
    def RemoveGeometry(self) -> Any: ...
    @overload
    def RemoveRole(self, source_id: SourceId, frame_id: FrameId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, context: pydrake.systems.framework.Context_ğ“£floatğ“¤, source_id: SourceId, frame_id: FrameId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, SourceId, FrameId, Role) -> Any: ...
    @overload
    def RemoveRole(self, source_id: SourceId, geometry_id: GeometryId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, context: pydrake.systems.framework.Context_ğ“£floatğ“¤, source_id: SourceId, geometry_id: GeometryId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, SourceId, GeometryId, Role) -> Any: ...
    def RendererCount(self) -> int: ...
    @overload
    def collision_filter_manager(self, context: pydrake.systems.framework.Context_ğ“£floatğ“¤) -> CollisionFilterManager: ...
    @overload
    def collision_filter_manager(self) -> CollisionFilterManager: ...
    def get_query_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£floatğ“¤: ...
    def get_source_configuration_port(self, arg0: SourceId) -> pydrake.systems.framework.InputPort_ğ“£floatğ“¤: ...
    def get_source_pose_port(self, arg0: SourceId) -> pydrake.systems.framework.InputPort_ğ“£floatğ“¤: ...
    def model_inspector(self) -> SceneGraphInspector_ğ“£floatğ“¤: ...
    def world_frame_id(self, *args, **kwargs) -> Any: ...

class SceneGraphInspector:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    def BelongsToSource(self, frame_id: FrameId, source_id: SourceId) -> bool: ...
    @overload
    def BelongsToSource(self, geometry_id: GeometryId, source_id: SourceId) -> bool: ...
    def CloneGeometryInstance(self, geometry_id: GeometryId) -> GeometryInstance: ...
    def CollisionFiltered(self, geometry_id1: GeometryId, geometry_id2: GeometryId) -> bool: ...
    def FramesForSource(self, source_id: SourceId) -> Set[FrameId]: ...
    def GetAllFrameIds(self) -> List[FrameId]: ...
    def GetAllGeometryIds(self) -> List[GeometryId]: ...
    def GetCollisionCandidates(self) -> Set[Tuple[GeometryId,GeometryId]]: ...
    def GetFrameGroup(self, frame_id: FrameId) -> int: ...
    def GetFrameId(self, geometry_id: GeometryId) -> FrameId: ...
    def GetGeometries(self, frame_id: FrameId, role: Optional[Role] = ...) -> List[GeometryId]: ...
    def GetGeometryIdByName(self, frame_id: FrameId, role: Role, name: str) -> GeometryId: ...
    def GetGeometryIds(self, geometry_set: GeometrySet, role: Optional[Role] = ...) -> Set[GeometryId]: ...
    def GetIllustrationProperties(self, geometry_id: GeometryId) -> IllustrationProperties: ...
    @overload
    def GetName(self, source_id: SourceId) -> str: ...
    @overload
    def GetName(self, frame_id: FrameId) -> str: ...
    @overload
    def GetName(self, geometry_id: GeometryId) -> str: ...
    @overload
    def GetOwningSourceName(self, frame_id: FrameId) -> str: ...
    @overload
    def GetOwningSourceName(self, geometry_id: GeometryId) -> str: ...
    def GetPerceptionProperties(self, geometry_id: GeometryId) -> PerceptionProperties: ...
    def GetPoseInFrame(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform_ğ“£floatğ“¤: ...
    def GetPoseInParent(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform_ğ“£floatğ“¤: ...
    def GetProperties(self, geometry_id: GeometryId, role: Role) -> GeometryProperties: ...
    def GetProximityProperties(self, geometry_id: GeometryId) -> ProximityProperties: ...
    def GetShape(self, geometry_id: GeometryId) -> Shape: ...
    def NumAnchoredGeometries(self) -> int: ...
    def NumDynamicGeometries(self) -> int: ...
    def NumFramesForSource(self, source_id: SourceId) -> int: ...
    def NumGeometriesForFrame(self, frame_id: FrameId) -> int: ...
    def NumGeometriesForFrameWithRole(self, frame_id: FrameId, role: Role) -> int: ...
    def NumGeometriesWithRole(self, role: Role) -> int: ...
    def SourceIsRegistered(self, source_id: SourceId) -> bool: ...
    def geometry_version(self) -> GeometryVersion: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, geometry_id: GeometryId) -> Union[None,TriangleSurfaceMesh_ğ“£floatğ“¤,VolumeMesh_ğ“£floatğ“¤]: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, id) -> Any: ...
    def num_frames(self) -> int: ...
    def num_geometries(self) -> int: ...
    def num_sources(self) -> int: ...
    def world_frame_id(self) -> FrameId: ...

class SceneGraphInspector_ğ“£AutoDiffXdğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    def BelongsToSource(self, frame_id: FrameId, source_id: SourceId) -> bool: ...
    @overload
    def BelongsToSource(self, geometry_id: GeometryId, source_id: SourceId) -> bool: ...
    def CloneGeometryInstance(self, geometry_id: GeometryId) -> GeometryInstance: ...
    def CollisionFiltered(self, geometry_id1: GeometryId, geometry_id2: GeometryId) -> bool: ...
    def FramesForSource(self, source_id: SourceId) -> Set[FrameId]: ...
    def GetAllFrameIds(self) -> List[FrameId]: ...
    def GetAllGeometryIds(self) -> List[GeometryId]: ...
    def GetCollisionCandidates(self) -> Set[Tuple[GeometryId,GeometryId]]: ...
    def GetFrameGroup(self, frame_id: FrameId) -> int: ...
    def GetFrameId(self, geometry_id: GeometryId) -> FrameId: ...
    def GetGeometries(self, frame_id: FrameId, role: Optional[Role] = ...) -> List[GeometryId]: ...
    def GetGeometryIdByName(self, frame_id: FrameId, role: Role, name: str) -> GeometryId: ...
    def GetGeometryIds(self, geometry_set: GeometrySet, role: Optional[Role] = ...) -> Set[GeometryId]: ...
    def GetIllustrationProperties(self, geometry_id: GeometryId) -> IllustrationProperties: ...
    @overload
    def GetName(self, source_id: SourceId) -> str: ...
    @overload
    def GetName(self, frame_id: FrameId) -> str: ...
    @overload
    def GetName(self, geometry_id: GeometryId) -> str: ...
    @overload
    def GetOwningSourceName(self, frame_id: FrameId) -> str: ...
    @overload
    def GetOwningSourceName(self, geometry_id: GeometryId) -> str: ...
    def GetPerceptionProperties(self, geometry_id: GeometryId) -> PerceptionProperties: ...
    def GetPoseInFrame(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform_ğ“£floatğ“¤: ...
    def GetPoseInParent(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform_ğ“£floatğ“¤: ...
    def GetProperties(self, geometry_id: GeometryId, role: Role) -> GeometryProperties: ...
    def GetProximityProperties(self, geometry_id: GeometryId) -> ProximityProperties: ...
    def GetShape(self, geometry_id: GeometryId) -> Shape: ...
    def NumAnchoredGeometries(self) -> int: ...
    def NumDynamicGeometries(self) -> int: ...
    def NumFramesForSource(self, source_id: SourceId) -> int: ...
    def NumGeometriesForFrame(self, frame_id: FrameId) -> int: ...
    def NumGeometriesForFrameWithRole(self, frame_id: FrameId, role: Role) -> int: ...
    def NumGeometriesWithRole(self, role: Role) -> int: ...
    def SourceIsRegistered(self, source_id: SourceId) -> bool: ...
    def geometry_version(self) -> GeometryVersion: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, geometry_id: GeometryId) -> Union[None,TriangleSurfaceMesh_ğ“£floatğ“¤,VolumeMesh_ğ“£floatğ“¤]: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, id) -> Any: ...
    def num_frames(self) -> int: ...
    def num_geometries(self) -> int: ...
    def num_sources(self) -> int: ...
    def world_frame_id(self) -> FrameId: ...

class SceneGraphInspector_ğ“£Expressionğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    def BelongsToSource(self, frame_id: FrameId, source_id: SourceId) -> bool: ...
    @overload
    def BelongsToSource(self, geometry_id: GeometryId, source_id: SourceId) -> bool: ...
    def CloneGeometryInstance(self, geometry_id: GeometryId) -> GeometryInstance: ...
    def CollisionFiltered(self, geometry_id1: GeometryId, geometry_id2: GeometryId) -> bool: ...
    def FramesForSource(self, source_id: SourceId) -> Set[FrameId]: ...
    def GetAllFrameIds(self) -> List[FrameId]: ...
    def GetAllGeometryIds(self) -> List[GeometryId]: ...
    def GetCollisionCandidates(self) -> Set[Tuple[GeometryId,GeometryId]]: ...
    def GetFrameGroup(self, frame_id: FrameId) -> int: ...
    def GetFrameId(self, geometry_id: GeometryId) -> FrameId: ...
    def GetGeometries(self, frame_id: FrameId, role: Optional[Role] = ...) -> List[GeometryId]: ...
    def GetGeometryIdByName(self, frame_id: FrameId, role: Role, name: str) -> GeometryId: ...
    def GetGeometryIds(self, geometry_set: GeometrySet, role: Optional[Role] = ...) -> Set[GeometryId]: ...
    def GetIllustrationProperties(self, geometry_id: GeometryId) -> IllustrationProperties: ...
    @overload
    def GetName(self, source_id: SourceId) -> str: ...
    @overload
    def GetName(self, frame_id: FrameId) -> str: ...
    @overload
    def GetName(self, geometry_id: GeometryId) -> str: ...
    @overload
    def GetOwningSourceName(self, frame_id: FrameId) -> str: ...
    @overload
    def GetOwningSourceName(self, geometry_id: GeometryId) -> str: ...
    def GetPerceptionProperties(self, geometry_id: GeometryId) -> PerceptionProperties: ...
    def GetPoseInFrame(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform_ğ“£floatğ“¤: ...
    def GetPoseInParent(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform_ğ“£floatğ“¤: ...
    def GetProperties(self, geometry_id: GeometryId, role: Role) -> GeometryProperties: ...
    def GetProximityProperties(self, geometry_id: GeometryId) -> ProximityProperties: ...
    def GetShape(self, geometry_id: GeometryId) -> Shape: ...
    def NumAnchoredGeometries(self) -> int: ...
    def NumDynamicGeometries(self) -> int: ...
    def NumFramesForSource(self, source_id: SourceId) -> int: ...
    def NumGeometriesForFrame(self, frame_id: FrameId) -> int: ...
    def NumGeometriesForFrameWithRole(self, frame_id: FrameId, role: Role) -> int: ...
    def NumGeometriesWithRole(self, role: Role) -> int: ...
    def SourceIsRegistered(self, source_id: SourceId) -> bool: ...
    def geometry_version(self) -> GeometryVersion: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, geometry_id: GeometryId) -> Union[None,TriangleSurfaceMesh_ğ“£floatğ“¤,VolumeMesh_ğ“£floatğ“¤]: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, id) -> Any: ...
    def num_frames(self) -> int: ...
    def num_geometries(self) -> int: ...
    def num_sources(self) -> int: ...
    def world_frame_id(self) -> FrameId: ...

class SceneGraphInspector_ğ“£floatğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    def BelongsToSource(self, frame_id: FrameId, source_id: SourceId) -> bool: ...
    @overload
    def BelongsToSource(self, geometry_id: GeometryId, source_id: SourceId) -> bool: ...
    def CloneGeometryInstance(self, geometry_id: GeometryId) -> GeometryInstance: ...
    def CollisionFiltered(self, geometry_id1: GeometryId, geometry_id2: GeometryId) -> bool: ...
    def FramesForSource(self, source_id: SourceId) -> Set[FrameId]: ...
    def GetAllFrameIds(self) -> List[FrameId]: ...
    def GetAllGeometryIds(self) -> List[GeometryId]: ...
    def GetCollisionCandidates(self) -> Set[Tuple[GeometryId,GeometryId]]: ...
    def GetFrameGroup(self, frame_id: FrameId) -> int: ...
    def GetFrameId(self, geometry_id: GeometryId) -> FrameId: ...
    def GetGeometries(self, frame_id: FrameId, role: Optional[Role] = ...) -> List[GeometryId]: ...
    def GetGeometryIdByName(self, frame_id: FrameId, role: Role, name: str) -> GeometryId: ...
    def GetGeometryIds(self, geometry_set: GeometrySet, role: Optional[Role] = ...) -> Set[GeometryId]: ...
    def GetIllustrationProperties(self, geometry_id: GeometryId) -> IllustrationProperties: ...
    @overload
    def GetName(self, source_id: SourceId) -> str: ...
    @overload
    def GetName(self, frame_id: FrameId) -> str: ...
    @overload
    def GetName(self, geometry_id: GeometryId) -> str: ...
    @overload
    def GetOwningSourceName(self, frame_id: FrameId) -> str: ...
    @overload
    def GetOwningSourceName(self, geometry_id: GeometryId) -> str: ...
    def GetPerceptionProperties(self, geometry_id: GeometryId) -> PerceptionProperties: ...
    def GetPoseInFrame(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform_ğ“£floatğ“¤: ...
    def GetPoseInParent(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform_ğ“£floatğ“¤: ...
    def GetProperties(self, geometry_id: GeometryId, role: Role) -> GeometryProperties: ...
    def GetProximityProperties(self, geometry_id: GeometryId) -> ProximityProperties: ...
    def GetShape(self, geometry_id: GeometryId) -> Shape: ...
    def NumAnchoredGeometries(self) -> int: ...
    def NumDynamicGeometries(self) -> int: ...
    def NumFramesForSource(self, source_id: SourceId) -> int: ...
    def NumGeometriesForFrame(self, frame_id: FrameId) -> int: ...
    def NumGeometriesForFrameWithRole(self, frame_id: FrameId, role: Role) -> int: ...
    def NumGeometriesWithRole(self, role: Role) -> int: ...
    def SourceIsRegistered(self, source_id: SourceId) -> bool: ...
    def geometry_version(self) -> GeometryVersion: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, geometry_id: GeometryId) -> Union[None,TriangleSurfaceMesh_ğ“£floatğ“¤,VolumeMesh_ğ“£floatğ“¤]: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, id) -> Any: ...
    def num_frames(self) -> int: ...
    def num_geometries(self) -> int: ...
    def num_sources(self) -> int: ...
    def world_frame_id(self) -> FrameId: ...

class SceneGraph_ğ“£AutoDiffXdğ“¤(pydrake.systems.framework.LeafSystem_ğ“£AutoDiffXdğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def AddRenderer(self, name: str, renderer: render.RenderEngine) -> None: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: ProximityProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, source_id: SourceId, geometry_id: GeometryId, properties: ProximityProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, ProximityProperties) -> Any: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: PerceptionProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, source_id: SourceId, geometry_id: GeometryId, properties: PerceptionProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, PerceptionProperties) -> Any: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: IllustrationProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, source_id: SourceId, geometry_id: GeometryId, properties: IllustrationProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, IllustrationProperties) -> Any: ...
    def HasRenderer(self, name: str) -> bool: ...
    def RegisterAnchoredGeometry(self, source_id: SourceId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterFrame(self, source_id: SourceId, frame: GeometryFrame) -> FrameId: ...
    @overload
    def RegisterFrame(self, source_id: SourceId, parent_id: FrameId, frame: GeometryFrame) -> FrameId: ...
    @overload
    def RegisterGeometry(self, source_id: SourceId, frame_id: FrameId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self, source_id: SourceId, geometry_id: GeometryId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self, frame_id) -> Any: ...
    @overload
    def RegisterGeometry(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, source_id: SourceId, geometry_id: GeometryId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self) -> Any: ...
    @overload
    def RegisterGeometry(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, source_id: SourceId, frame_id: FrameId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self) -> Any: ...
    def RegisterSource(self, name: str = ...) -> SourceId: ...
    @overload
    def RemoveGeometry(self, source_id: SourceId, geometry_id: GeometryId) -> None: ...
    @overload
    def RemoveGeometry(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, source_id: SourceId, geometry_id: GeometryId) -> None: ...
    @overload
    def RemoveGeometry(self) -> Any: ...
    @overload
    def RemoveRole(self, source_id: SourceId, frame_id: FrameId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, source_id: SourceId, frame_id: FrameId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, SourceId, FrameId, Role) -> Any: ...
    @overload
    def RemoveRole(self, source_id: SourceId, geometry_id: GeometryId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, source_id: SourceId, geometry_id: GeometryId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, SourceId, GeometryId, Role) -> Any: ...
    def RendererCount(self) -> int: ...
    @overload
    def collision_filter_manager(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤) -> CollisionFilterManager: ...
    @overload
    def collision_filter_manager(self) -> CollisionFilterManager: ...
    def get_query_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_source_configuration_port(self, arg0: SourceId) -> pydrake.systems.framework.InputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_source_pose_port(self, arg0: SourceId) -> pydrake.systems.framework.InputPort_ğ“£AutoDiffXdğ“¤: ...
    def model_inspector(self) -> SceneGraphInspector_ğ“£AutoDiffXdğ“¤: ...
    def world_frame_id(self, *args, **kwargs) -> Any: ...

class SceneGraph_ğ“£Expressionğ“¤(pydrake.systems.framework.LeafSystem_ğ“£Expressionğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def AddRenderer(self, name: str, renderer: render.RenderEngine) -> None: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: ProximityProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, source_id: SourceId, geometry_id: GeometryId, properties: ProximityProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, ProximityProperties) -> Any: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: PerceptionProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, source_id: SourceId, geometry_id: GeometryId, properties: PerceptionProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, PerceptionProperties) -> Any: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: IllustrationProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, source_id: SourceId, geometry_id: GeometryId, properties: IllustrationProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, IllustrationProperties) -> Any: ...
    def HasRenderer(self, name: str) -> bool: ...
    def RegisterAnchoredGeometry(self, source_id: SourceId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterFrame(self, source_id: SourceId, frame: GeometryFrame) -> FrameId: ...
    @overload
    def RegisterFrame(self, source_id: SourceId, parent_id: FrameId, frame: GeometryFrame) -> FrameId: ...
    @overload
    def RegisterGeometry(self, source_id: SourceId, frame_id: FrameId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self, source_id: SourceId, geometry_id: GeometryId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self, frame_id) -> Any: ...
    @overload
    def RegisterGeometry(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, source_id: SourceId, geometry_id: GeometryId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self) -> Any: ...
    @overload
    def RegisterGeometry(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, source_id: SourceId, frame_id: FrameId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self) -> Any: ...
    def RegisterSource(self, name: str = ...) -> SourceId: ...
    @overload
    def RemoveGeometry(self, source_id: SourceId, geometry_id: GeometryId) -> None: ...
    @overload
    def RemoveGeometry(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, source_id: SourceId, geometry_id: GeometryId) -> None: ...
    @overload
    def RemoveGeometry(self) -> Any: ...
    @overload
    def RemoveRole(self, source_id: SourceId, frame_id: FrameId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, source_id: SourceId, frame_id: FrameId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, SourceId, FrameId, Role) -> Any: ...
    @overload
    def RemoveRole(self, source_id: SourceId, geometry_id: GeometryId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, source_id: SourceId, geometry_id: GeometryId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, SourceId, GeometryId, Role) -> Any: ...
    def RendererCount(self) -> int: ...
    @overload
    def collision_filter_manager(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤) -> CollisionFilterManager: ...
    @overload
    def collision_filter_manager(self) -> CollisionFilterManager: ...
    def get_query_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£Expressionğ“¤: ...
    def get_source_configuration_port(self, arg0: SourceId) -> pydrake.systems.framework.InputPort_ğ“£Expressionğ“¤: ...
    def get_source_pose_port(self, arg0: SourceId) -> pydrake.systems.framework.InputPort_ğ“£Expressionğ“¤: ...
    def model_inspector(self) -> SceneGraphInspector_ğ“£Expressionğ“¤: ...
    def world_frame_id(self, *args, **kwargs) -> Any: ...

class SceneGraph_ğ“£floatğ“¤(pydrake.systems.framework.LeafSystem_ğ“£floatğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def AddRenderer(self, name: str, renderer: render.RenderEngine) -> None: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: ProximityProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_ğ“£floatğ“¤, source_id: SourceId, geometry_id: GeometryId, properties: ProximityProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, ProximityProperties) -> Any: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: PerceptionProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_ğ“£floatğ“¤, source_id: SourceId, geometry_id: GeometryId, properties: PerceptionProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, PerceptionProperties) -> Any: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: IllustrationProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_ğ“£floatğ“¤, source_id: SourceId, geometry_id: GeometryId, properties: IllustrationProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, IllustrationProperties) -> Any: ...
    def HasRenderer(self, name: str) -> bool: ...
    def RegisterAnchoredGeometry(self, source_id: SourceId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterFrame(self, source_id: SourceId, frame: GeometryFrame) -> FrameId: ...
    @overload
    def RegisterFrame(self, source_id: SourceId, parent_id: FrameId, frame: GeometryFrame) -> FrameId: ...
    @overload
    def RegisterGeometry(self, source_id: SourceId, frame_id: FrameId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self, source_id: SourceId, geometry_id: GeometryId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self, frame_id) -> Any: ...
    @overload
    def RegisterGeometry(self, context: pydrake.systems.framework.Context_ğ“£floatğ“¤, source_id: SourceId, geometry_id: GeometryId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self) -> Any: ...
    @overload
    def RegisterGeometry(self, context: pydrake.systems.framework.Context_ğ“£floatğ“¤, source_id: SourceId, frame_id: FrameId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self) -> Any: ...
    def RegisterSource(self, name: str = ...) -> SourceId: ...
    @overload
    def RemoveGeometry(self, source_id: SourceId, geometry_id: GeometryId) -> None: ...
    @overload
    def RemoveGeometry(self, context: pydrake.systems.framework.Context_ğ“£floatğ“¤, source_id: SourceId, geometry_id: GeometryId) -> None: ...
    @overload
    def RemoveGeometry(self) -> Any: ...
    @overload
    def RemoveRole(self, source_id: SourceId, frame_id: FrameId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, context: pydrake.systems.framework.Context_ğ“£floatğ“¤, source_id: SourceId, frame_id: FrameId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, SourceId, FrameId, Role) -> Any: ...
    @overload
    def RemoveRole(self, source_id: SourceId, geometry_id: GeometryId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, context: pydrake.systems.framework.Context_ğ“£floatğ“¤, source_id: SourceId, geometry_id: GeometryId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, SourceId, GeometryId, Role) -> Any: ...
    def RendererCount(self) -> int: ...
    @overload
    def collision_filter_manager(self, context: pydrake.systems.framework.Context_ğ“£floatğ“¤) -> CollisionFilterManager: ...
    @overload
    def collision_filter_manager(self) -> CollisionFilterManager: ...
    def get_query_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£floatğ“¤: ...
    def get_source_configuration_port(self, arg0: SourceId) -> pydrake.systems.framework.InputPort_ğ“£floatğ“¤: ...
    def get_source_pose_port(self, arg0: SourceId) -> pydrake.systems.framework.InputPort_ğ“£floatğ“¤: ...
    def model_inspector(self) -> SceneGraphInspector_ğ“£floatğ“¤: ...
    def world_frame_id(self, *args, **kwargs) -> Any: ...

class Shape:
    def __init__(self, *args, **kwargs) -> None: ...
    def Clone(self) -> Shape: ...
    def __copy__(self) -> Shape: ...
    def __deepcopy__(self, arg0: dict) -> Shape: ...

class SignedDistancePair:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    distance: float
    id_A: GeometryId
    id_B: GeometryId
    nhat_BA_W: numpy.ndarray[numpy.float64[3,1]]
    p_ACa: numpy.ndarray[numpy.float64[3,1]]
    p_BCb: numpy.ndarray[numpy.float64[3,1]]
    def __init__(self, **kwargs) -> None: ...

class SignedDistancePair_ğ“£AutoDiffXdğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    distance: pydrake.autodiffutils.AutoDiffXd
    id_A: GeometryId
    id_B: GeometryId
    nhat_BA_W: numpy.ndarray[object[3,1]]
    p_ACa: numpy.ndarray[object[3,1]]
    p_BCb: numpy.ndarray[object[3,1]]
    def __init__(self, **kwargs) -> None: ...

class SignedDistancePair_ğ“£Expressionğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    distance: pydrake.symbolic.Expression
    id_A: GeometryId
    id_B: GeometryId
    nhat_BA_W: numpy.ndarray[object[3,1]]
    p_ACa: numpy.ndarray[object[3,1]]
    p_BCb: numpy.ndarray[object[3,1]]
    def __init__(self, **kwargs) -> None: ...

class SignedDistancePair_ğ“£floatğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    distance: float
    id_A: GeometryId
    id_B: GeometryId
    nhat_BA_W: numpy.ndarray[numpy.float64[3,1]]
    p_ACa: numpy.ndarray[numpy.float64[3,1]]
    p_BCb: numpy.ndarray[numpy.float64[3,1]]
    def __init__(self, **kwargs) -> None: ...

class SignedDistanceToPoint:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    distance: float
    grad_W: numpy.ndarray[numpy.float64[3,1]]
    id_G: GeometryId
    p_GN: numpy.ndarray[numpy.float64[3,1]]
    def __init__(self, **kwargs) -> None: ...

class SignedDistanceToPoint_ğ“£AutoDiffXdğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    distance: pydrake.autodiffutils.AutoDiffXd
    grad_W: numpy.ndarray[object[3,1]]
    id_G: GeometryId
    p_GN: numpy.ndarray[object[3,1]]
    def __init__(self, **kwargs) -> None: ...

class SignedDistanceToPoint_ğ“£Expressionğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    distance: pydrake.symbolic.Expression
    grad_W: numpy.ndarray[object[3,1]]
    id_G: GeometryId
    p_GN: numpy.ndarray[object[3,1]]
    def __init__(self, **kwargs) -> None: ...

class SignedDistanceToPoint_ğ“£floatğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    distance: float
    grad_W: numpy.ndarray[numpy.float64[3,1]]
    id_G: GeometryId
    p_GN: numpy.ndarray[numpy.float64[3,1]]
    def __init__(self, **kwargs) -> None: ...

class SourceId:
    def __init__(self, *args, **kwargs) -> None: ...
    def get_new_id(self, *args, **kwargs) -> Any: ...
    def get_value(self) -> int: ...
    def is_valid(self) -> bool: ...
    def __eq__(self, arg0: SourceId) -> bool: ...
    def __hash__(self) -> int: ...
    def __lt__(self, arg0: SourceId) -> bool: ...
    def __ne__(self, arg0: SourceId) -> bool: ...

class Sphere(Shape):
    def __init__(self, radius: float) -> None: ...
    def radius(self) -> float: ...
    def __getstate__(self) -> float: ...
    def __setstate__(self, arg0: float) -> None: ...

class SurfacePolygon:
    def __init__(self, *args, **kwargs) -> None: ...
    def num_vertices(self) -> int: ...
    def vertex(self, i: int) -> int: ...

class SurfaceTriangle:
    def __init__(self, v0: int, v1: int, v2: int) -> None: ...
    def num_vertices(self) -> int: ...
    def vertex(self, i: int) -> int: ...
    def __copy__(self) -> SurfaceTriangle: ...
    def __deepcopy__(self, arg0: dict) -> SurfaceTriangle: ...

class TriangleSurfaceMesh:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, triangles: List[SurfaceTriangle], vertices: List[numpy.ndarray[numpy.float64[3,1]]]) -> None: ...
    def CalcBarycentric(self, p_MQ: numpy.ndarray[numpy.float64[3,1]], t: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CalcBoundingBox(self) -> Tuple[numpy.ndarray[numpy.float64[3,1]],numpy.ndarray[numpy.float64[3,1]]]: ...
    def CalcCartesianFromBarycentric(self, element_index: int, b_Q: numpy.ndarray[numpy.float64[3,1]]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def Equal(self, mesh: TriangleSurfaceMesh_ğ“£floatğ“¤) -> bool: ...
    def area(self, t: int) -> float: ...
    def centroid(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def element(self, e: int) -> SurfaceTriangle: ...
    def element_centroid(self, t: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def face_normal(self, t: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def num_elements(self) -> int: ...
    def num_triangles(self) -> int: ...
    def num_vertices(self) -> int: ...
    def total_area(self) -> float: ...
    def triangles(self) -> List[SurfaceTriangle]: ...
    def vertex(self, v: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def vertices(self) -> List[numpy.ndarray[numpy.float64[3,1]]]: ...

class TriangleSurfaceMeshFieldLinear:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def Evaluate(self, e: int, b: numpy.ndarray[numpy.float64[3,1]]) -> float: ...
    def EvaluateAtVertex(self, v: int) -> float: ...
    def EvaluateCartesian(self, e: int, p_MQ: numpy.ndarray[numpy.float64[3,1]]) -> float: ...

class TriangleSurfaceMeshFieldLinear_ğ“£AutoDiffXdğ“¬AutoDiffXdğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def Evaluate(self, e: int, b: numpy.ndarray[object[3,1]]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def EvaluateAtVertex(self, v: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    def EvaluateCartesian(self, e: int, p_MQ: numpy.ndarray[object[3,1]]) -> pydrake.autodiffutils.AutoDiffXd: ...

class TriangleSurfaceMeshFieldLinear_ğ“£floatğ“¬floatğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def Evaluate(self, e: int, b: numpy.ndarray[numpy.float64[3,1]]) -> float: ...
    def EvaluateAtVertex(self, v: int) -> float: ...
    def EvaluateCartesian(self, e: int, p_MQ: numpy.ndarray[numpy.float64[3,1]]) -> float: ...

class TriangleSurfaceMesh_ğ“£AutoDiffXdğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, triangles: List[SurfaceTriangle], vertices: List[numpy.ndarray[object[3,1]]]) -> None: ...
    def CalcBarycentric(self, p_MQ: numpy.ndarray[object[3,1]], t: int) -> numpy.ndarray[object[3,1]]: ...
    def CalcBoundingBox(self) -> Tuple[numpy.ndarray[object[3,1]],numpy.ndarray[object[3,1]]]: ...
    def CalcCartesianFromBarycentric(self, element_index: int, b_Q: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,1]]: ...
    def Equal(self, mesh: TriangleSurfaceMesh_ğ“£AutoDiffXdğ“¤) -> bool: ...
    def area(self, t: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    def centroid(self) -> numpy.ndarray[object[3,1]]: ...
    def element(self, e: int) -> SurfaceTriangle: ...
    def element_centroid(self, t: int) -> numpy.ndarray[object[3,1]]: ...
    def face_normal(self, t: int) -> numpy.ndarray[object[3,1]]: ...
    def num_elements(self) -> int: ...
    def num_triangles(self) -> int: ...
    def num_vertices(self) -> int: ...
    def total_area(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def triangles(self) -> List[SurfaceTriangle]: ...
    def vertex(self, v: int) -> numpy.ndarray[object[3,1]]: ...
    def vertices(self) -> List[numpy.ndarray[object[3,1]]]: ...

class TriangleSurfaceMesh_ğ“£floatğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, triangles: List[SurfaceTriangle], vertices: List[numpy.ndarray[numpy.float64[3,1]]]) -> None: ...
    def CalcBarycentric(self, p_MQ: numpy.ndarray[numpy.float64[3,1]], t: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CalcBoundingBox(self) -> Tuple[numpy.ndarray[numpy.float64[3,1]],numpy.ndarray[numpy.float64[3,1]]]: ...
    def CalcCartesianFromBarycentric(self, element_index: int, b_Q: numpy.ndarray[numpy.float64[3,1]]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def Equal(self, mesh: TriangleSurfaceMesh_ğ“£floatğ“¤) -> bool: ...
    def area(self, t: int) -> float: ...
    def centroid(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def element(self, e: int) -> SurfaceTriangle: ...
    def element_centroid(self, t: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def face_normal(self, t: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def num_elements(self) -> int: ...
    def num_triangles(self) -> int: ...
    def num_vertices(self) -> int: ...
    def total_area(self) -> float: ...
    def triangles(self) -> List[SurfaceTriangle]: ...
    def vertex(self, v: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def vertices(self) -> List[numpy.ndarray[numpy.float64[3,1]]]: ...

class VolumeElement:
    def __init__(self, v0: int, v1: int, v2: int, v3: int) -> None: ...
    def vertex(self, i: int) -> int: ...
    def __copy__(self) -> VolumeElement: ...
    def __deepcopy__(self, arg0: dict) -> VolumeElement: ...

class VolumeMesh:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, elements: List[VolumeElement], vertices: List[numpy.ndarray[numpy.float64[3,1]]]) -> None: ...
    def CalcBarycentric(self, p_MQ: numpy.ndarray[numpy.float64[3,1]], e: int) -> numpy.ndarray[numpy.float64[4,1]]: ...
    def CalcTetrahedronVolume(self, e: int) -> float: ...
    def CalcVolume(self) -> float: ...
    def Equal(self, mesh: VolumeMesh_ğ“£floatğ“¤, vertex_tolerance: float = ...) -> bool: ...
    def element(self, e: int) -> VolumeElement: ...
    def num_elements(self) -> int: ...
    def num_vertices(self) -> int: ...
    def tetrahedra(self) -> List[VolumeElement]: ...
    def vertex(self, v: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def vertices(self) -> List[numpy.ndarray[numpy.float64[3,1]]]: ...

class VolumeMesh_ğ“£AutoDiffXdğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, elements: List[VolumeElement], vertices: List[numpy.ndarray[object[3,1]]]) -> None: ...
    def CalcBarycentric(self, p_MQ: numpy.ndarray[object[3,1]], e: int) -> numpy.ndarray[object[4,1]]: ...
    def CalcTetrahedronVolume(self, e: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    def CalcVolume(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def Equal(self, mesh: VolumeMesh_ğ“£AutoDiffXdğ“¤, vertex_tolerance: float = ...) -> bool: ...
    def element(self, e: int) -> VolumeElement: ...
    def num_elements(self) -> int: ...
    def num_vertices(self) -> int: ...
    def tetrahedra(self) -> List[VolumeElement]: ...
    def vertex(self, v: int) -> numpy.ndarray[object[3,1]]: ...
    def vertices(self) -> List[numpy.ndarray[object[3,1]]]: ...

class VolumeMesh_ğ“£floatğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, elements: List[VolumeElement], vertices: List[numpy.ndarray[numpy.float64[3,1]]]) -> None: ...
    def CalcBarycentric(self, p_MQ: numpy.ndarray[numpy.float64[3,1]], e: int) -> numpy.ndarray[numpy.float64[4,1]]: ...
    def CalcTetrahedronVolume(self, e: int) -> float: ...
    def CalcVolume(self) -> float: ...
    def Equal(self, mesh: VolumeMesh_ğ“£floatğ“¤, vertex_tolerance: float = ...) -> bool: ...
    def element(self, e: int) -> VolumeElement: ...
    def num_elements(self) -> int: ...
    def num_vertices(self) -> int: ...
    def tetrahedra(self) -> List[VolumeElement]: ...
    def vertex(self, v: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def vertices(self) -> List[numpy.ndarray[numpy.float64[3,1]]]: ...

class _TemporaryName_N5drake5ValueINS_8geometry11QueryObjectIN5Eigen14AutoDiffScalarINS3_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: QueryObject_ğ“£AutoDiffXdğ“¤) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> QueryObject_ğ“£AutoDiffXdğ“¤: ...
    def get_value(self) -> QueryObject_ğ“£AutoDiffXdğ“¤: ...
    def set_value(self, arg0: QueryObject_ğ“£AutoDiffXdğ“¤) -> None: ...

class _TemporaryName_N5drake5ValueINS_8geometry11QueryObjectINS_8symbolic10ExpressionEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: QueryObject_ğ“£Expressionğ“¤) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> QueryObject_ğ“£Expressionğ“¤: ...
    def get_value(self) -> QueryObject_ğ“£Expressionğ“¤: ...
    def set_value(self, arg0: QueryObject_ğ“£Expressionğ“¤) -> None: ...

class _TemporaryName_N5drake5ValueINS_8geometry11QueryObjectIdEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: QueryObject_ğ“£floatğ“¤) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> QueryObject_ğ“£floatğ“¤: ...
    def get_value(self) -> QueryObject_ğ“£floatğ“¤: ...
    def set_value(self, arg0: QueryObject_ğ“£floatğ“¤) -> None: ...

class _TemporaryName_N5drake5ValueINS_8geometry16KinematicsVectorINS_10IdentifierINS1_8FrameTagEEENS_4math14RigidTransformIN5Eigen14AutoDiffScalarINS8_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: FramePoseVector_ğ“£AutoDiffXdğ“¤) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> FramePoseVector_ğ“£AutoDiffXdğ“¤: ...
    def get_value(self) -> FramePoseVector_ğ“£AutoDiffXdğ“¤: ...
    def set_value(self, arg0: FramePoseVector_ğ“£AutoDiffXdğ“¤) -> None: ...

class _TemporaryName_N5drake5ValueINS_8geometry16KinematicsVectorINS_10IdentifierINS1_8FrameTagEEENS_4math14RigidTransformINS_8symbolic10ExpressionEEEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: FramePoseVector_ğ“£Expressionğ“¤) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> FramePoseVector_ğ“£Expressionğ“¤: ...
    def get_value(self) -> FramePoseVector_ğ“£Expressionğ“¤: ...
    def set_value(self, arg0: FramePoseVector_ğ“£Expressionğ“¤) -> None: ...

class _TemporaryName_N5drake5ValueINS_8geometry16KinematicsVectorINS_10IdentifierINS1_8FrameTagEEENS_4math14RigidTransformIdEEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: FramePoseVector_ğ“£floatğ“¤) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> FramePoseVector_ğ“£floatğ“¤: ...
    def get_value(self) -> FramePoseVector_ğ“£floatğ“¤: ...
    def set_value(self, arg0: FramePoseVector_ğ“£floatğ“¤) -> None: ...

class _TemporaryName_N5drake5ValueINS_8geometry4RgbaEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: Rgba) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> Rgba: ...
    def get_value(self) -> Rgba: ...
    def set_value(self, arg0: Rgba) -> None: ...

class _TemporaryName_N5drake8geometry10SceneGraphIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(pydrake.systems.framework.LeafSystem_ğ“£AutoDiffXdğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def AddRenderer(self, name: str, renderer: render.RenderEngine) -> None: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: ProximityProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, source_id: SourceId, geometry_id: GeometryId, properties: ProximityProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, ProximityProperties) -> Any: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: PerceptionProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, source_id: SourceId, geometry_id: GeometryId, properties: PerceptionProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, PerceptionProperties) -> Any: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: IllustrationProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, source_id: SourceId, geometry_id: GeometryId, properties: IllustrationProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, IllustrationProperties) -> Any: ...
    def HasRenderer(self, name: str) -> bool: ...
    def RegisterAnchoredGeometry(self, source_id: SourceId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterFrame(self, source_id: SourceId, frame: GeometryFrame) -> FrameId: ...
    @overload
    def RegisterFrame(self, source_id: SourceId, parent_id: FrameId, frame: GeometryFrame) -> FrameId: ...
    @overload
    def RegisterGeometry(self, source_id: SourceId, frame_id: FrameId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self, source_id: SourceId, geometry_id: GeometryId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self, frame_id) -> Any: ...
    @overload
    def RegisterGeometry(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, source_id: SourceId, geometry_id: GeometryId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self) -> Any: ...
    @overload
    def RegisterGeometry(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, source_id: SourceId, frame_id: FrameId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self) -> Any: ...
    def RegisterSource(self, name: str = ...) -> SourceId: ...
    @overload
    def RemoveGeometry(self, source_id: SourceId, geometry_id: GeometryId) -> None: ...
    @overload
    def RemoveGeometry(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, source_id: SourceId, geometry_id: GeometryId) -> None: ...
    @overload
    def RemoveGeometry(self) -> Any: ...
    @overload
    def RemoveRole(self, source_id: SourceId, frame_id: FrameId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, source_id: SourceId, frame_id: FrameId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, SourceId, FrameId, Role) -> Any: ...
    @overload
    def RemoveRole(self, source_id: SourceId, geometry_id: GeometryId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, source_id: SourceId, geometry_id: GeometryId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, SourceId, GeometryId, Role) -> Any: ...
    def RendererCount(self) -> int: ...
    @overload
    def collision_filter_manager(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤) -> CollisionFilterManager: ...
    @overload
    def collision_filter_manager(self) -> CollisionFilterManager: ...
    def get_query_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_source_configuration_port(self, arg0: SourceId) -> pydrake.systems.framework.InputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_source_pose_port(self, arg0: SourceId) -> pydrake.systems.framework.InputPort_ğ“£AutoDiffXdğ“¤: ...
    def model_inspector(self) -> SceneGraphInspector_ğ“£AutoDiffXdğ“¤: ...
    def world_frame_id(self, *args, **kwargs) -> Any: ...

class _TemporaryName_N5drake8geometry10SceneGraphINS_8symbolic10ExpressionEEE(pydrake.systems.framework.LeafSystem_ğ“£Expressionğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def AddRenderer(self, name: str, renderer: render.RenderEngine) -> None: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: ProximityProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, source_id: SourceId, geometry_id: GeometryId, properties: ProximityProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, ProximityProperties) -> Any: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: PerceptionProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, source_id: SourceId, geometry_id: GeometryId, properties: PerceptionProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, PerceptionProperties) -> Any: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: IllustrationProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, source_id: SourceId, geometry_id: GeometryId, properties: IllustrationProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, IllustrationProperties) -> Any: ...
    def HasRenderer(self, name: str) -> bool: ...
    def RegisterAnchoredGeometry(self, source_id: SourceId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterFrame(self, source_id: SourceId, frame: GeometryFrame) -> FrameId: ...
    @overload
    def RegisterFrame(self, source_id: SourceId, parent_id: FrameId, frame: GeometryFrame) -> FrameId: ...
    @overload
    def RegisterGeometry(self, source_id: SourceId, frame_id: FrameId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self, source_id: SourceId, geometry_id: GeometryId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self, frame_id) -> Any: ...
    @overload
    def RegisterGeometry(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, source_id: SourceId, geometry_id: GeometryId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self) -> Any: ...
    @overload
    def RegisterGeometry(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, source_id: SourceId, frame_id: FrameId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self) -> Any: ...
    def RegisterSource(self, name: str = ...) -> SourceId: ...
    @overload
    def RemoveGeometry(self, source_id: SourceId, geometry_id: GeometryId) -> None: ...
    @overload
    def RemoveGeometry(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, source_id: SourceId, geometry_id: GeometryId) -> None: ...
    @overload
    def RemoveGeometry(self) -> Any: ...
    @overload
    def RemoveRole(self, source_id: SourceId, frame_id: FrameId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, source_id: SourceId, frame_id: FrameId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, SourceId, FrameId, Role) -> Any: ...
    @overload
    def RemoveRole(self, source_id: SourceId, geometry_id: GeometryId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, source_id: SourceId, geometry_id: GeometryId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, SourceId, GeometryId, Role) -> Any: ...
    def RendererCount(self) -> int: ...
    @overload
    def collision_filter_manager(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤) -> CollisionFilterManager: ...
    @overload
    def collision_filter_manager(self) -> CollisionFilterManager: ...
    def get_query_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£Expressionğ“¤: ...
    def get_source_configuration_port(self, arg0: SourceId) -> pydrake.systems.framework.InputPort_ğ“£Expressionğ“¤: ...
    def get_source_pose_port(self, arg0: SourceId) -> pydrake.systems.framework.InputPort_ğ“£Expressionğ“¤: ...
    def model_inspector(self) -> SceneGraphInspector_ğ“£Expressionğ“¤: ...
    def world_frame_id(self, *args, **kwargs) -> Any: ...

class _TemporaryName_N5drake8geometry10SceneGraphIdEE(pydrake.systems.framework.LeafSystem_ğ“£floatğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def AddRenderer(self, name: str, renderer: render.RenderEngine) -> None: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: ProximityProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_ğ“£floatğ“¤, source_id: SourceId, geometry_id: GeometryId, properties: ProximityProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, ProximityProperties) -> Any: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: PerceptionProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_ğ“£floatğ“¤, source_id: SourceId, geometry_id: GeometryId, properties: PerceptionProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, PerceptionProperties) -> Any: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: IllustrationProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_ğ“£floatğ“¤, source_id: SourceId, geometry_id: GeometryId, properties: IllustrationProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, IllustrationProperties) -> Any: ...
    def HasRenderer(self, name: str) -> bool: ...
    def RegisterAnchoredGeometry(self, source_id: SourceId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterFrame(self, source_id: SourceId, frame: GeometryFrame) -> FrameId: ...
    @overload
    def RegisterFrame(self, source_id: SourceId, parent_id: FrameId, frame: GeometryFrame) -> FrameId: ...
    @overload
    def RegisterGeometry(self, source_id: SourceId, frame_id: FrameId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self, source_id: SourceId, geometry_id: GeometryId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self, frame_id) -> Any: ...
    @overload
    def RegisterGeometry(self, context: pydrake.systems.framework.Context_ğ“£floatğ“¤, source_id: SourceId, geometry_id: GeometryId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self) -> Any: ...
    @overload
    def RegisterGeometry(self, context: pydrake.systems.framework.Context_ğ“£floatğ“¤, source_id: SourceId, frame_id: FrameId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self) -> Any: ...
    def RegisterSource(self, name: str = ...) -> SourceId: ...
    @overload
    def RemoveGeometry(self, source_id: SourceId, geometry_id: GeometryId) -> None: ...
    @overload
    def RemoveGeometry(self, context: pydrake.systems.framework.Context_ğ“£floatğ“¤, source_id: SourceId, geometry_id: GeometryId) -> None: ...
    @overload
    def RemoveGeometry(self) -> Any: ...
    @overload
    def RemoveRole(self, source_id: SourceId, frame_id: FrameId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, context: pydrake.systems.framework.Context_ğ“£floatğ“¤, source_id: SourceId, frame_id: FrameId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, SourceId, FrameId, Role) -> Any: ...
    @overload
    def RemoveRole(self, source_id: SourceId, geometry_id: GeometryId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, context: pydrake.systems.framework.Context_ğ“£floatğ“¤, source_id: SourceId, geometry_id: GeometryId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, SourceId, GeometryId, Role) -> Any: ...
    def RendererCount(self) -> int: ...
    @overload
    def collision_filter_manager(self, context: pydrake.systems.framework.Context_ğ“£floatğ“¤) -> CollisionFilterManager: ...
    @overload
    def collision_filter_manager(self) -> CollisionFilterManager: ...
    def get_query_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£floatğ“¤: ...
    def get_source_configuration_port(self, arg0: SourceId) -> pydrake.systems.framework.InputPort_ğ“£floatğ“¤: ...
    def get_source_pose_port(self, arg0: SourceId) -> pydrake.systems.framework.InputPort_ğ“£floatğ“¤: ...
    def model_inspector(self) -> SceneGraphInspector_ğ“£floatğ“¤: ...
    def world_frame_id(self, *args, **kwargs) -> Any: ...

class _TemporaryName_N5drake8geometry10VolumeMeshIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, elements: List[VolumeElement], vertices: List[numpy.ndarray[object[3,1]]]) -> None: ...
    def CalcBarycentric(self, p_MQ: numpy.ndarray[object[3,1]], e: int) -> numpy.ndarray[object[4,1]]: ...
    def CalcTetrahedronVolume(self, e: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    def CalcVolume(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def Equal(self, mesh: VolumeMesh_ğ“£AutoDiffXdğ“¤, vertex_tolerance: float = ...) -> bool: ...
    def element(self, e: int) -> VolumeElement: ...
    def num_elements(self) -> int: ...
    def num_vertices(self) -> int: ...
    def tetrahedra(self) -> List[VolumeElement]: ...
    def vertex(self, v: int) -> numpy.ndarray[object[3,1]]: ...
    def vertices(self) -> List[numpy.ndarray[object[3,1]]]: ...

class _TemporaryName_N5drake8geometry10VolumeMeshIdEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, elements: List[VolumeElement], vertices: List[numpy.ndarray[numpy.float64[3,1]]]) -> None: ...
    def CalcBarycentric(self, p_MQ: numpy.ndarray[numpy.float64[3,1]], e: int) -> numpy.ndarray[numpy.float64[4,1]]: ...
    def CalcTetrahedronVolume(self, e: int) -> float: ...
    def CalcVolume(self) -> float: ...
    def Equal(self, mesh: VolumeMesh_ğ“£floatğ“¤, vertex_tolerance: float = ...) -> bool: ...
    def element(self, e: int) -> VolumeElement: ...
    def num_elements(self) -> int: ...
    def num_vertices(self) -> int: ...
    def tetrahedra(self) -> List[VolumeElement]: ...
    def vertex(self, v: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def vertices(self) -> List[numpy.ndarray[numpy.float64[3,1]]]: ...

class _TemporaryName_N5drake8geometry11QueryObjectIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def ComputeContactSurfaces(self, *args, **kwargs) -> Any: ...
    def ComputeContactSurfacesWithFallback(self, *args, **kwargs) -> Any: ...
    def ComputePointPairPenetration(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistancePairClosestPoints(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistancePairwiseClosestPoints(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistanceToPoint(self, *args, **kwargs) -> Any: ...
    def FindCollisionCandidates(self, *args, **kwargs) -> Any: ...
    @overload
    def GetPoseInParent(self, frame_id: FrameId) -> pydrake.math.RigidTransform_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def GetPoseInParent(self) -> Any: ...
    @overload
    def GetPoseInWorld(self, frame_id: FrameId) -> pydrake.math.RigidTransform_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def GetPoseInWorld(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform_ğ“£AutoDiffXdğ“¤: ...
    def HasCollisions(self) -> bool: ...
    def RenderColorImage(self, *args, **kwargs) -> Any: ...
    def RenderDepthImage(self, *args, **kwargs) -> Any: ...
    def RenderLabelImage(self, *args, **kwargs) -> Any: ...
    def inspector(self) -> SceneGraphInspector_ğ“£AutoDiffXdğ“¤: ...

class _TemporaryName_N5drake8geometry11QueryObjectINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def ComputePointPairPenetration(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistancePairClosestPoints(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistancePairwiseClosestPoints(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistanceToPoint(self, *args, **kwargs) -> Any: ...
    def FindCollisionCandidates(self, *args, **kwargs) -> Any: ...
    @overload
    def GetPoseInParent(self, frame_id: FrameId) -> pydrake.math.RigidTransform_ğ“£Expressionğ“¤: ...
    @overload
    def GetPoseInParent(self) -> Any: ...
    @overload
    def GetPoseInWorld(self, frame_id: FrameId) -> pydrake.math.RigidTransform_ğ“£Expressionğ“¤: ...
    @overload
    def GetPoseInWorld(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform_ğ“£Expressionğ“¤: ...
    def HasCollisions(self) -> bool: ...
    def RenderColorImage(self, *args, **kwargs) -> Any: ...
    def RenderDepthImage(self, *args, **kwargs) -> Any: ...
    def RenderLabelImage(self, *args, **kwargs) -> Any: ...
    def inspector(self) -> SceneGraphInspector_ğ“£Expressionğ“¤: ...

class _TemporaryName_N5drake8geometry11QueryObjectIdEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def ComputeContactSurfaces(self, *args, **kwargs) -> Any: ...
    def ComputeContactSurfacesWithFallback(self, *args, **kwargs) -> Any: ...
    def ComputePointPairPenetration(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistancePairClosestPoints(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistancePairwiseClosestPoints(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistanceToPoint(self, *args, **kwargs) -> Any: ...
    def FindCollisionCandidates(self, *args, **kwargs) -> Any: ...
    @overload
    def GetPoseInParent(self, frame_id: FrameId) -> pydrake.math.RigidTransform_ğ“£floatğ“¤: ...
    @overload
    def GetPoseInParent(self) -> Any: ...
    @overload
    def GetPoseInWorld(self, frame_id: FrameId) -> pydrake.math.RigidTransform_ğ“£floatğ“¤: ...
    @overload
    def GetPoseInWorld(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform_ğ“£floatğ“¤: ...
    def HasCollisions(self) -> bool: ...
    def RenderColorImage(self, *args, **kwargs) -> Any: ...
    def RenderDepthImage(self, *args, **kwargs) -> Any: ...
    def RenderLabelImage(self, *args, **kwargs) -> Any: ...
    def inspector(self) -> SceneGraphInspector_ğ“£floatğ“¤: ...

class _TemporaryName_N5drake8geometry14ContactSurfaceIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def Equal(self, surface: ContactSurface_ğ“£AutoDiffXdğ“¤) -> bool: ...
    def EvaluateGradE_M_W(self, index: int) -> numpy.ndarray[object[3,1]]: ...
    def EvaluateGradE_N_W(self, index: int) -> numpy.ndarray[object[3,1]]: ...
    def HasGradE_M(self) -> bool: ...
    def HasGradE_N(self) -> bool: ...
    def area(self, face_index: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def centroid(self, face_index: int) -> numpy.ndarray[object[3,1]]: ...
    @overload
    def centroid(self) -> numpy.ndarray[object[3,1]]: ...
    def face_normal(self, face_index: int) -> numpy.ndarray[object[3,1]]: ...
    def id_M(self) -> GeometryId: ...
    def id_N(self) -> GeometryId: ...
    def is_triangle(self) -> bool: ...
    def num_faces(self) -> int: ...
    def num_vertices(self) -> int: ...
    def poly_e_MN(self) -> PolygonSurfaceMeshFieldLinear_ğ“£AutoDiffXdğ“¬AutoDiffXdğ“¤: ...
    def poly_mesh_W(self) -> PolygonSurfaceMesh_ğ“£AutoDiffXdğ“¤: ...
    def representation(self) -> HydroelasticContactRepresentation: ...
    def total_area(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def tri_e_MN(self) -> TriangleSurfaceMeshFieldLinear_ğ“£AutoDiffXdğ“¬AutoDiffXdğ“¤: ...
    def tri_mesh_W(self) -> TriangleSurfaceMesh_ğ“£AutoDiffXdğ“¤: ...
    def __copy__(self) -> ContactSurface_ğ“£AutoDiffXdğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> ContactSurface_ğ“£AutoDiffXdğ“¤: ...

class _TemporaryName_N5drake8geometry14ContactSurfaceIdEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def Equal(self, surface: ContactSurface_ğ“£floatğ“¤) -> bool: ...
    def EvaluateGradE_M_W(self, index: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def EvaluateGradE_N_W(self, index: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def HasGradE_M(self) -> bool: ...
    def HasGradE_N(self) -> bool: ...
    def area(self, face_index: int) -> float: ...
    @overload
    def centroid(self, face_index: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    @overload
    def centroid(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def face_normal(self, face_index: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def id_M(self) -> GeometryId: ...
    def id_N(self) -> GeometryId: ...
    def is_triangle(self) -> bool: ...
    def num_faces(self) -> int: ...
    def num_vertices(self) -> int: ...
    def poly_e_MN(self) -> PolygonSurfaceMeshFieldLinear_ğ“£floatğ“¬floatğ“¤: ...
    def poly_mesh_W(self) -> PolygonSurfaceMesh_ğ“£floatğ“¤: ...
    def representation(self) -> HydroelasticContactRepresentation: ...
    def total_area(self) -> float: ...
    def tri_e_MN(self) -> TriangleSurfaceMeshFieldLinear_ğ“£floatğ“¬floatğ“¤: ...
    def tri_mesh_W(self) -> TriangleSurfaceMesh_ğ“£floatğ“¤: ...
    def __copy__(self) -> ContactSurface_ğ“£floatğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> ContactSurface_ğ“£floatğ“¤: ...

class _TemporaryName_N5drake8geometry15DrakeVisualizerIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(pydrake.systems.framework.LeafSystem_ğ“£AutoDiffXdğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, lcm: pydrake.lcm.DrakeLcmInterface = ..., params: DrakeVisualizerParams = ...) -> None: ...
    def AddToBuilder(self, *args, **kwargs) -> Any: ...
    def DispatchLoadMessage(self, *args, **kwargs) -> Any: ...
    def query_object_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£AutoDiffXdğ“¤: ...

class _TemporaryName_N5drake8geometry15DrakeVisualizerIdEE(pydrake.systems.framework.LeafSystem_ğ“£floatğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, lcm: pydrake.lcm.DrakeLcmInterface = ..., params: DrakeVisualizerParams = ...) -> None: ...
    def AddToBuilder(self, *args, **kwargs) -> Any: ...
    def DispatchLoadMessage(self, *args, **kwargs) -> Any: ...
    def query_object_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£floatğ“¤: ...

class _TemporaryName_N5drake8geometry15MeshFieldLinearIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEENS0_18PolygonSurfaceMeshIS6_EEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def EvaluateAtVertex(self, v: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    def EvaluateCartesian(self, e: int, p_MQ: numpy.ndarray[object[3,1]]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def EvaluateGradient(self, e: int) -> numpy.ndarray[object[3,1]]: ...

class _TemporaryName_N5drake8geometry15MeshFieldLinearIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEENS0_19TriangleSurfaceMeshIS6_EEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def Evaluate(self, e: int, b: numpy.ndarray[object[3,1]]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def EvaluateAtVertex(self, v: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    def EvaluateCartesian(self, e: int, p_MQ: numpy.ndarray[object[3,1]]) -> pydrake.autodiffutils.AutoDiffXd: ...

class _TemporaryName_N5drake8geometry15MeshFieldLinearIdNS0_18PolygonSurfaceMeshIdEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def EvaluateAtVertex(self, v: int) -> float: ...
    def EvaluateCartesian(self, e: int, p_MQ: numpy.ndarray[numpy.float64[3,1]]) -> float: ...
    def EvaluateGradient(self, e: int) -> numpy.ndarray[numpy.float64[3,1]]: ...

class _TemporaryName_N5drake8geometry15MeshFieldLinearIdNS0_19TriangleSurfaceMeshIdEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def Evaluate(self, e: int, b: numpy.ndarray[numpy.float64[3,1]]) -> float: ...
    def EvaluateAtVertex(self, v: int) -> float: ...
    def EvaluateCartesian(self, e: int, p_MQ: numpy.ndarray[numpy.float64[3,1]]) -> float: ...

class _TemporaryName_N5drake8geometry16KinematicsVectorINS_10IdentifierINS0_8FrameTagEEENS_4math14RigidTransformIN5Eigen14AutoDiffScalarINS7_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def clear(self) -> None: ...
    def has_id(self, id: FrameId) -> bool: ...
    @overload
    def ids(self) -> List[FrameId]: ...
    @overload
    def ids(self) -> Any: ...
    def set_value(self, id: FrameId, value: pydrake.math.RigidTransform_ğ“£AutoDiffXdğ“¤) -> None: ...
    def size(self) -> int: ...
    def value(self, id: FrameId) -> pydrake.math.RigidTransform_ğ“£AutoDiffXdğ“¤: ...

class _TemporaryName_N5drake8geometry16KinematicsVectorINS_10IdentifierINS0_8FrameTagEEENS_4math14RigidTransformINS_8symbolic10ExpressionEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def clear(self) -> None: ...
    def has_id(self, id: FrameId) -> bool: ...
    @overload
    def ids(self) -> List[FrameId]: ...
    @overload
    def ids(self) -> Any: ...
    def set_value(self, id: FrameId, value: pydrake.math.RigidTransform_ğ“£Expressionğ“¤) -> None: ...
    def size(self) -> int: ...
    def value(self, id: FrameId) -> pydrake.math.RigidTransform_ğ“£Expressionğ“¤: ...

class _TemporaryName_N5drake8geometry16KinematicsVectorINS_10IdentifierINS0_8FrameTagEEENS_4math14RigidTransformIdEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def clear(self) -> None: ...
    def has_id(self, id: FrameId) -> bool: ...
    @overload
    def ids(self) -> List[FrameId]: ...
    @overload
    def ids(self) -> Any: ...
    def set_value(self, id: FrameId, value: pydrake.math.RigidTransform_ğ“£floatğ“¤) -> None: ...
    def size(self) -> int: ...
    def value(self, id: FrameId) -> pydrake.math.RigidTransform_ğ“£floatğ“¤: ...

class _TemporaryName_N5drake8geometry17MeshcatVisualizerIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(pydrake.systems.framework.LeafSystem_ğ“£AutoDiffXdğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, meshcat: Meshcat, params: MeshcatVisualizerParams = ...) -> None: ...
    def AddToBuilder(self, *args, **kwargs) -> Any: ...
    def Delete(self) -> None: ...
    def DeleteRecording(self) -> None: ...
    def PublishRecording(self) -> None: ...
    def StartRecording(self, set_transforms_while_recording: bool = ...) -> MeshcatAnimation: ...
    def StopRecording(self) -> None: ...
    def get_mutable_recording(self) -> MeshcatAnimation: ...
    def query_object_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£AutoDiffXdğ“¤: ...

class _TemporaryName_N5drake8geometry17MeshcatVisualizerIdEE(pydrake.systems.framework.LeafSystem_ğ“£floatğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, meshcat: Meshcat, params: MeshcatVisualizerParams = ...) -> None: ...
    def AddToBuilder(self, *args, **kwargs) -> Any: ...
    def Delete(self) -> None: ...
    def DeleteRecording(self) -> None: ...
    def PublishRecording(self) -> None: ...
    def StartRecording(self, set_transforms_while_recording: bool = ...) -> MeshcatAnimation: ...
    def StopRecording(self) -> None: ...
    def get_mutable_recording(self) -> MeshcatAnimation: ...
    def query_object_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£floatğ“¤: ...

class _TemporaryName_N5drake8geometry18PolygonSurfaceMeshIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, face_data: List[int], vertices: List[numpy.ndarray[object[3,1]]]) -> None: ...
    def CalcBoundingBox(self) -> Tuple[numpy.ndarray[object[3,1]],numpy.ndarray[object[3,1]]]: ...
    def Equal(self, mesh: PolygonSurfaceMesh_ğ“£AutoDiffXdğ“¤) -> bool: ...
    def area(self, f: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    def centroid(self) -> numpy.ndarray[object[3,1]]: ...
    def element(self, e: int) -> SurfacePolygon: ...
    def element_centroid(self, e: int) -> numpy.ndarray[object[3,1]]: ...
    def face_data(self) -> List[int]: ...
    def face_normal(self, f: int) -> numpy.ndarray[object[3,1]]: ...
    def num_elements(self) -> int: ...
    def num_faces(self) -> int: ...
    def num_vertices(self) -> int: ...
    def total_area(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def vertex(self, v: int) -> numpy.ndarray[object[3,1]]: ...
    def __copy__(self) -> PolygonSurfaceMesh_ğ“£AutoDiffXdğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> PolygonSurfaceMesh_ğ“£AutoDiffXdğ“¤: ...

class _TemporaryName_N5drake8geometry18PolygonSurfaceMeshIdEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, face_data: List[int], vertices: List[numpy.ndarray[numpy.float64[3,1]]]) -> None: ...
    def CalcBoundingBox(self) -> Tuple[numpy.ndarray[numpy.float64[3,1]],numpy.ndarray[numpy.float64[3,1]]]: ...
    def Equal(self, mesh: PolygonSurfaceMesh_ğ“£floatğ“¤) -> bool: ...
    def area(self, f: int) -> float: ...
    def centroid(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def element(self, e: int) -> SurfacePolygon: ...
    def element_centroid(self, e: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def face_data(self) -> List[int]: ...
    def face_normal(self, f: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def num_elements(self) -> int: ...
    def num_faces(self) -> int: ...
    def num_vertices(self) -> int: ...
    def total_area(self) -> float: ...
    def vertex(self, v: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def __copy__(self) -> PolygonSurfaceMesh_ğ“£floatğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> PolygonSurfaceMesh_ğ“£floatğ“¤: ...

class _TemporaryName_N5drake8geometry18SignedDistancePairIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    distance: pydrake.autodiffutils.AutoDiffXd
    id_A: GeometryId
    id_B: GeometryId
    nhat_BA_W: numpy.ndarray[object[3,1]]
    p_ACa: numpy.ndarray[object[3,1]]
    p_BCb: numpy.ndarray[object[3,1]]
    def __init__(self, **kwargs) -> None: ...

class _TemporaryName_N5drake8geometry18SignedDistancePairINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    distance: pydrake.symbolic.Expression
    id_A: GeometryId
    id_B: GeometryId
    nhat_BA_W: numpy.ndarray[object[3,1]]
    p_ACa: numpy.ndarray[object[3,1]]
    p_BCb: numpy.ndarray[object[3,1]]
    def __init__(self, **kwargs) -> None: ...

class _TemporaryName_N5drake8geometry18SignedDistancePairIdEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    distance: float
    id_A: GeometryId
    id_B: GeometryId
    nhat_BA_W: numpy.ndarray[numpy.float64[3,1]]
    p_ACa: numpy.ndarray[numpy.float64[3,1]]
    p_BCb: numpy.ndarray[numpy.float64[3,1]]
    def __init__(self, **kwargs) -> None: ...

class _TemporaryName_N5drake8geometry19SceneGraphInspectorIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    def BelongsToSource(self, frame_id: FrameId, source_id: SourceId) -> bool: ...
    @overload
    def BelongsToSource(self, geometry_id: GeometryId, source_id: SourceId) -> bool: ...
    def CloneGeometryInstance(self, geometry_id: GeometryId) -> GeometryInstance: ...
    def CollisionFiltered(self, geometry_id1: GeometryId, geometry_id2: GeometryId) -> bool: ...
    def FramesForSource(self, source_id: SourceId) -> Set[FrameId]: ...
    def GetAllFrameIds(self) -> List[FrameId]: ...
    def GetAllGeometryIds(self) -> List[GeometryId]: ...
    def GetCollisionCandidates(self) -> Set[Tuple[GeometryId,GeometryId]]: ...
    def GetFrameGroup(self, frame_id: FrameId) -> int: ...
    def GetFrameId(self, geometry_id: GeometryId) -> FrameId: ...
    def GetGeometries(self, frame_id: FrameId, role: Optional[Role] = ...) -> List[GeometryId]: ...
    def GetGeometryIdByName(self, frame_id: FrameId, role: Role, name: str) -> GeometryId: ...
    def GetGeometryIds(self, geometry_set: GeometrySet, role: Optional[Role] = ...) -> Set[GeometryId]: ...
    def GetIllustrationProperties(self, geometry_id: GeometryId) -> IllustrationProperties: ...
    @overload
    def GetName(self, source_id: SourceId) -> str: ...
    @overload
    def GetName(self, frame_id: FrameId) -> str: ...
    @overload
    def GetName(self, geometry_id: GeometryId) -> str: ...
    @overload
    def GetOwningSourceName(self, frame_id: FrameId) -> str: ...
    @overload
    def GetOwningSourceName(self, geometry_id: GeometryId) -> str: ...
    def GetPerceptionProperties(self, geometry_id: GeometryId) -> PerceptionProperties: ...
    def GetPoseInFrame(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform_ğ“£floatğ“¤: ...
    def GetPoseInParent(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform_ğ“£floatğ“¤: ...
    def GetProperties(self, geometry_id: GeometryId, role: Role) -> GeometryProperties: ...
    def GetProximityProperties(self, geometry_id: GeometryId) -> ProximityProperties: ...
    def GetShape(self, geometry_id: GeometryId) -> Shape: ...
    def NumAnchoredGeometries(self) -> int: ...
    def NumDynamicGeometries(self) -> int: ...
    def NumFramesForSource(self, source_id: SourceId) -> int: ...
    def NumGeometriesForFrame(self, frame_id: FrameId) -> int: ...
    def NumGeometriesForFrameWithRole(self, frame_id: FrameId, role: Role) -> int: ...
    def NumGeometriesWithRole(self, role: Role) -> int: ...
    def SourceIsRegistered(self, source_id: SourceId) -> bool: ...
    def geometry_version(self) -> GeometryVersion: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, geometry_id: GeometryId) -> Union[None,TriangleSurfaceMesh_ğ“£floatğ“¤,VolumeMesh_ğ“£floatğ“¤]: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, id) -> Any: ...
    def num_frames(self) -> int: ...
    def num_geometries(self) -> int: ...
    def num_sources(self) -> int: ...
    def world_frame_id(self) -> FrameId: ...

class _TemporaryName_N5drake8geometry19SceneGraphInspectorINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    def BelongsToSource(self, frame_id: FrameId, source_id: SourceId) -> bool: ...
    @overload
    def BelongsToSource(self, geometry_id: GeometryId, source_id: SourceId) -> bool: ...
    def CloneGeometryInstance(self, geometry_id: GeometryId) -> GeometryInstance: ...
    def CollisionFiltered(self, geometry_id1: GeometryId, geometry_id2: GeometryId) -> bool: ...
    def FramesForSource(self, source_id: SourceId) -> Set[FrameId]: ...
    def GetAllFrameIds(self) -> List[FrameId]: ...
    def GetAllGeometryIds(self) -> List[GeometryId]: ...
    def GetCollisionCandidates(self) -> Set[Tuple[GeometryId,GeometryId]]: ...
    def GetFrameGroup(self, frame_id: FrameId) -> int: ...
    def GetFrameId(self, geometry_id: GeometryId) -> FrameId: ...
    def GetGeometries(self, frame_id: FrameId, role: Optional[Role] = ...) -> List[GeometryId]: ...
    def GetGeometryIdByName(self, frame_id: FrameId, role: Role, name: str) -> GeometryId: ...
    def GetGeometryIds(self, geometry_set: GeometrySet, role: Optional[Role] = ...) -> Set[GeometryId]: ...
    def GetIllustrationProperties(self, geometry_id: GeometryId) -> IllustrationProperties: ...
    @overload
    def GetName(self, source_id: SourceId) -> str: ...
    @overload
    def GetName(self, frame_id: FrameId) -> str: ...
    @overload
    def GetName(self, geometry_id: GeometryId) -> str: ...
    @overload
    def GetOwningSourceName(self, frame_id: FrameId) -> str: ...
    @overload
    def GetOwningSourceName(self, geometry_id: GeometryId) -> str: ...
    def GetPerceptionProperties(self, geometry_id: GeometryId) -> PerceptionProperties: ...
    def GetPoseInFrame(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform_ğ“£floatğ“¤: ...
    def GetPoseInParent(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform_ğ“£floatğ“¤: ...
    def GetProperties(self, geometry_id: GeometryId, role: Role) -> GeometryProperties: ...
    def GetProximityProperties(self, geometry_id: GeometryId) -> ProximityProperties: ...
    def GetShape(self, geometry_id: GeometryId) -> Shape: ...
    def NumAnchoredGeometries(self) -> int: ...
    def NumDynamicGeometries(self) -> int: ...
    def NumFramesForSource(self, source_id: SourceId) -> int: ...
    def NumGeometriesForFrame(self, frame_id: FrameId) -> int: ...
    def NumGeometriesForFrameWithRole(self, frame_id: FrameId, role: Role) -> int: ...
    def NumGeometriesWithRole(self, role: Role) -> int: ...
    def SourceIsRegistered(self, source_id: SourceId) -> bool: ...
    def geometry_version(self) -> GeometryVersion: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, geometry_id: GeometryId) -> Union[None,TriangleSurfaceMesh_ğ“£floatğ“¤,VolumeMesh_ğ“£floatğ“¤]: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, id) -> Any: ...
    def num_frames(self) -> int: ...
    def num_geometries(self) -> int: ...
    def num_sources(self) -> int: ...
    def world_frame_id(self) -> FrameId: ...

class _TemporaryName_N5drake8geometry19SceneGraphInspectorIdEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    def BelongsToSource(self, frame_id: FrameId, source_id: SourceId) -> bool: ...
    @overload
    def BelongsToSource(self, geometry_id: GeometryId, source_id: SourceId) -> bool: ...
    def CloneGeometryInstance(self, geometry_id: GeometryId) -> GeometryInstance: ...
    def CollisionFiltered(self, geometry_id1: GeometryId, geometry_id2: GeometryId) -> bool: ...
    def FramesForSource(self, source_id: SourceId) -> Set[FrameId]: ...
    def GetAllFrameIds(self) -> List[FrameId]: ...
    def GetAllGeometryIds(self) -> List[GeometryId]: ...
    def GetCollisionCandidates(self) -> Set[Tuple[GeometryId,GeometryId]]: ...
    def GetFrameGroup(self, frame_id: FrameId) -> int: ...
    def GetFrameId(self, geometry_id: GeometryId) -> FrameId: ...
    def GetGeometries(self, frame_id: FrameId, role: Optional[Role] = ...) -> List[GeometryId]: ...
    def GetGeometryIdByName(self, frame_id: FrameId, role: Role, name: str) -> GeometryId: ...
    def GetGeometryIds(self, geometry_set: GeometrySet, role: Optional[Role] = ...) -> Set[GeometryId]: ...
    def GetIllustrationProperties(self, geometry_id: GeometryId) -> IllustrationProperties: ...
    @overload
    def GetName(self, source_id: SourceId) -> str: ...
    @overload
    def GetName(self, frame_id: FrameId) -> str: ...
    @overload
    def GetName(self, geometry_id: GeometryId) -> str: ...
    @overload
    def GetOwningSourceName(self, frame_id: FrameId) -> str: ...
    @overload
    def GetOwningSourceName(self, geometry_id: GeometryId) -> str: ...
    def GetPerceptionProperties(self, geometry_id: GeometryId) -> PerceptionProperties: ...
    def GetPoseInFrame(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform_ğ“£floatğ“¤: ...
    def GetPoseInParent(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform_ğ“£floatğ“¤: ...
    def GetProperties(self, geometry_id: GeometryId, role: Role) -> GeometryProperties: ...
    def GetProximityProperties(self, geometry_id: GeometryId) -> ProximityProperties: ...
    def GetShape(self, geometry_id: GeometryId) -> Shape: ...
    def NumAnchoredGeometries(self) -> int: ...
    def NumDynamicGeometries(self) -> int: ...
    def NumFramesForSource(self, source_id: SourceId) -> int: ...
    def NumGeometriesForFrame(self, frame_id: FrameId) -> int: ...
    def NumGeometriesForFrameWithRole(self, frame_id: FrameId, role: Role) -> int: ...
    def NumGeometriesWithRole(self, role: Role) -> int: ...
    def SourceIsRegistered(self, source_id: SourceId) -> bool: ...
    def geometry_version(self) -> GeometryVersion: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, geometry_id: GeometryId) -> Union[None,TriangleSurfaceMesh_ğ“£floatğ“¤,VolumeMesh_ğ“£floatğ“¤]: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, id) -> Any: ...
    def num_frames(self) -> int: ...
    def num_geometries(self) -> int: ...
    def num_sources(self) -> int: ...
    def world_frame_id(self) -> FrameId: ...

class _TemporaryName_N5drake8geometry19TriangleSurfaceMeshIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, triangles: List[SurfaceTriangle], vertices: List[numpy.ndarray[object[3,1]]]) -> None: ...
    def CalcBarycentric(self, p_MQ: numpy.ndarray[object[3,1]], t: int) -> numpy.ndarray[object[3,1]]: ...
    def CalcBoundingBox(self) -> Tuple[numpy.ndarray[object[3,1]],numpy.ndarray[object[3,1]]]: ...
    def CalcCartesianFromBarycentric(self, element_index: int, b_Q: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,1]]: ...
    def Equal(self, mesh: TriangleSurfaceMesh_ğ“£AutoDiffXdğ“¤) -> bool: ...
    def area(self, t: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    def centroid(self) -> numpy.ndarray[object[3,1]]: ...
    def element(self, e: int) -> SurfaceTriangle: ...
    def element_centroid(self, t: int) -> numpy.ndarray[object[3,1]]: ...
    def face_normal(self, t: int) -> numpy.ndarray[object[3,1]]: ...
    def num_elements(self) -> int: ...
    def num_triangles(self) -> int: ...
    def num_vertices(self) -> int: ...
    def total_area(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def triangles(self) -> List[SurfaceTriangle]: ...
    def vertex(self, v: int) -> numpy.ndarray[object[3,1]]: ...
    def vertices(self) -> List[numpy.ndarray[object[3,1]]]: ...

class _TemporaryName_N5drake8geometry19TriangleSurfaceMeshIdEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, triangles: List[SurfaceTriangle], vertices: List[numpy.ndarray[numpy.float64[3,1]]]) -> None: ...
    def CalcBarycentric(self, p_MQ: numpy.ndarray[numpy.float64[3,1]], t: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CalcBoundingBox(self) -> Tuple[numpy.ndarray[numpy.float64[3,1]],numpy.ndarray[numpy.float64[3,1]]]: ...
    def CalcCartesianFromBarycentric(self, element_index: int, b_Q: numpy.ndarray[numpy.float64[3,1]]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def Equal(self, mesh: TriangleSurfaceMesh_ğ“£floatğ“¤) -> bool: ...
    def area(self, t: int) -> float: ...
    def centroid(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def element(self, e: int) -> SurfaceTriangle: ...
    def element_centroid(self, t: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def face_normal(self, t: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def num_elements(self) -> int: ...
    def num_triangles(self) -> int: ...
    def num_vertices(self) -> int: ...
    def total_area(self) -> float: ...
    def triangles(self) -> List[SurfaceTriangle]: ...
    def vertex(self, v: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def vertices(self) -> List[numpy.ndarray[numpy.float64[3,1]]]: ...

class _TemporaryName_N5drake8geometry21SignedDistanceToPointIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    distance: pydrake.autodiffutils.AutoDiffXd
    grad_W: numpy.ndarray[object[3,1]]
    id_G: GeometryId
    p_GN: numpy.ndarray[object[3,1]]
    def __init__(self, **kwargs) -> None: ...

class _TemporaryName_N5drake8geometry21SignedDistanceToPointINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    distance: pydrake.symbolic.Expression
    grad_W: numpy.ndarray[object[3,1]]
    id_G: GeometryId
    p_GN: numpy.ndarray[object[3,1]]
    def __init__(self, **kwargs) -> None: ...

class _TemporaryName_N5drake8geometry21SignedDistanceToPointIdEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    distance: float
    grad_W: numpy.ndarray[numpy.float64[3,1]]
    id_G: GeometryId
    p_GN: numpy.ndarray[numpy.float64[3,1]]
    def __init__(self, **kwargs) -> None: ...

class _TemporaryName_N5drake8geometry22PenetrationAsPointPairIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    depth: pydrake.autodiffutils.AutoDiffXd
    id_A: GeometryId
    id_B: GeometryId
    nhat_BA_W: numpy.ndarray[object[3,1]]
    p_WCa: numpy.ndarray[object[3,1]]
    p_WCb: numpy.ndarray[object[3,1]]
    def __init__(self, **kwargs) -> None: ...

class _TemporaryName_N5drake8geometry22PenetrationAsPointPairINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    depth: pydrake.symbolic.Expression
    id_A: GeometryId
    id_B: GeometryId
    nhat_BA_W: numpy.ndarray[object[3,1]]
    p_WCa: numpy.ndarray[object[3,1]]
    p_WCb: numpy.ndarray[object[3,1]]
    def __init__(self, **kwargs) -> None: ...

class _TemporaryName_N5drake8geometry22PenetrationAsPointPairIdEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    depth: float
    id_A: GeometryId
    id_B: GeometryId
    nhat_BA_W: numpy.ndarray[numpy.float64[3,1]]
    p_WCa: numpy.ndarray[numpy.float64[3,1]]
    p_WCb: numpy.ndarray[numpy.float64[3,1]]
    def __init__(self, **kwargs) -> None: ...

class _TemporaryName_N5drake8geometry27MeshcatPointCloudVisualizerIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(pydrake.systems.framework.LeafSystem_ğ“£AutoDiffXdğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, meshcat: Meshcat, path: str, publish_period: float = ...) -> None: ...
    @overload
    def Delete(self) -> None: ...
    @overload
    def Delete(self, path) -> Any: ...
    def cloud_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£AutoDiffXdğ“¤: ...
    def pose_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£AutoDiffXdğ“¤: ...
    def set_default_rgba(self, arg0: Rgba) -> None: ...
    def set_point_size(self, arg0: float) -> None: ...

class _TemporaryName_N5drake8geometry27MeshcatPointCloudVisualizerIdEE(pydrake.systems.framework.LeafSystem_ğ“£floatğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, meshcat: Meshcat, path: str, publish_period: float = ...) -> None: ...
    @overload
    def Delete(self) -> None: ...
    @overload
    def Delete(self, path) -> Any: ...
    def cloud_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£floatğ“¤: ...
    def pose_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£floatğ“¤: ...
    def set_default_rgba(self, arg0: Rgba) -> None: ...
    def set_point_size(self, arg0: float) -> None: ...

def AddCompliantHydroelasticProperties(resolution_hint: float, hydroelastic_modulus: float, properties: ProximityProperties) -> None: ...
def AddCompliantHydroelasticPropertiesForHalfSpace(slab_thickness: float, hydroelastic_modulus: float, properties: ProximityProperties) -> None: ...
@overload
def AddContactMaterial(dissipation: Optional[float], point_stiffness: Optional[float], friction, properties: ProximityProperties) -> None: ...
@overload
def AddContactMaterial() -> Any: ...
@overload
def AddContactMaterial(properties: ProximityProperties, dissipation: Optional[float] = ..., point_stiffness: Optional[float] = ..., friction = ...) -> None: ...
@overload
def AddContactMaterial() -> Any: ...
@overload
def AddRigidHydroelasticProperties(resolution_hint: float, properties: ProximityProperties) -> None: ...
@overload
def AddRigidHydroelasticProperties(properties: ProximityProperties) -> None: ...
def CalcVolume(shape: Shape) -> float: ...
@overload
def ConvertVolumeToSurfaceMesh(volume: VolumeMesh_ğ“£floatğ“¤) -> TriangleSurfaceMesh_ğ“£floatğ“¤: ...
@overload
def ConvertVolumeToSurfaceMesh(volume: VolumeMesh_ğ“£AutoDiffXdğ“¤) -> TriangleSurfaceMesh_ğ“£AutoDiffXdğ“¤: ...
def FindResourceOrThrow(resource_path: str) -> str: ...
def MakePhongIllustrationProperties(diffuse: numpy.ndarray[numpy.float64[4,1]]) -> IllustrationProperties: ...
def ReadObjToTriangleSurfaceMesh(*args, **kwargs) -> Any: ...
