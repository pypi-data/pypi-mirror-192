# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['coveo_testing', 'coveo_testing.temporary_resource']

package_data = \
{'': ['*']}

install_requires = \
['attrs', 'pytest']

setup_kwargs = {
    'name': 'coveo-testing',
    'version': '2.0.8',
    'description': 'Lightweight testing helpers',
    'long_description': '# coveo-testing\n\nA set of test/pytest helpers to facilitate common routines.\n\n\nContent in a nutshell:\n\n- Reusable pytest markers (UnitTest, IntegrationTest)\n- Unique ID generation for tests\n- Multiline logging assertions with includes, excludes, levels and comprehensive assertion output\n- Refactorable `unittest.mock.patch(\'this.module\')` module references\n\n- Human-readable (but still customizable) display for parametrized tests\n\n\nThis project is used as the test base for all other projects in this repository.\n\nTherefore, it cannot depend on any of them.\n\nMore complex use cases may be implemented in the `coveo-testing-extras` project. \nThat\'s also where you can depend on projects that depend on `coveo-testing`. \n\n\n# pytest markers and auto-registration\n\nThis enables code completion on markers.\n\nThree markers are already provided: `[UnitTest, Integration, Interactive]`\n\nHere\'s how you can create additional markers:\n\n```python\n# /test_some_module/markers.py\nimport pytest\n\nDockerTest = pytest.mark.docker_test\nCloudTest = pytest.mark.cloud_test\n\nALL_MARKERS = [DockerTest, CloudTest]\n```\n\nYou can then import these markers and decorate your test functions accordingly:\n\n```python\n# /test_some_module/test_something.py\nfrom coveo_testing.markers import UnitTest, Integration, Interactive\nfrom test_some_module.markers import CloudTest, DockerTest\n\n@UnitTest\ndef test_unit() -> None:\n    ...  # designed to be fast and lightweight, most likely parametrized\n\n\n@Integration\ndef test_integration() -> None:\n    ...  # combines multiple features to achieve a test\n\n\n@CloudTest\ndef test_in_the_cloud() -> None:\n    ...  # this could be a post-deployment test, for instance.\n\n\n@DockerTest\n@Integration\ndef test_through_docker() -> None:\n    ... # will run whenever docker tests or integration tests are requested\n\n\n@Interactive\ndef test_interactive() -> None:\n    ...  # these tests rely on eye-validations, special developer setups, etc  \n\n```\n\nPytest will issue a warning when markers are not registered.\n\nTo register coveo-testing\'s markers along with your custom markers, use the provided `register_markers` method:\n\n```python\n# /test_some_module/conftest.py\nfrom _pytest.config import Config\nfrom coveo_testing.markers import register_markers\nfrom test_some_module.markers import ALL_MARKERS\n\ndef pytest_configure(config: Config) -> None:\n    """This pytest hook is ran once, before collecting tests."""\n    register_markers(config, *ALL_MARKERS)\n```\n\n\n# Human-readable unique ID generation\n\nThe generated ID has this format:\n\n`friendly-name.timestamp.pid.host.executor.sequence`\n\n- friendly-name:\n  - provided by you, for your own benefit\n    \n- timestamp: \n  - format "%m%d%H%M%S" (month, day, hour, minutes, seconds)\n  - computed once, when TestId is imported\n    \n- pid:\n  - the pid of the python process\n    \n- host:\n  - the network name of the machine\n\n- executor:\n  - the content of the `EXECUTOR_NUMBER` environment variable\n  - returns \'default\' when not defined  \n  - historically, this variable comes from jenkins\n  - conceptually, it can be used to help distribute (and identify) tests and executors\n\n- sequence:\n  - Thread-safe\n  - Each `friendly-name` has an isolated `sequence` that starts at 0\n  - Incremented on each new instance\n  - Enables support for parallel parametrized tests\n\n```python\nfrom coveo_testing.temporary_resource.unique_id import TestId, unique_test_id\n\n\n# the friendly name is the only thing you need to specify\ntest_id = TestId(\'friendly-name\')\nstr(test_id)\n\'friendly-name.0202152243.18836.WORKSTATION.default.0\'\n\n\n# you can pass the instance around to share the ID\nstr(test_id)\n\'friendly-name.0202152243.18836.WORKSTATION.default.0\'\n\n\n# create new instances to increment the sequence number\ntest_id = TestId(\'friendly-name\')\nstr(test_id)\n\'friendly-name.0202152243.18836.WORKSTATION.default.1\'\n\n\n# use it in parallel parameterized tests\nimport pytest\n\n@pytest.mark.parametrize(\'param\', (True, False))\ndef test_param(param: bool, unique_test_id: TestId) -> None:\n    # in this case, the friendly name is the function name and\n    # the sequence will increase on each parameter\n    # test_param.0202152243.18836.WORKSTATION.default.0\n    # test_param.0202152243.18836.WORKSTATION.default.1\n    ...\n```\n\n\n# multiline logging assertions\n\nMaybe pytest\'s `caplog` is enough for your needs, or maybe you need more options.\nThis tool uses `in` and `not in` to match strings in a case-sensitive way.\n\n```python\nimport logging\nfrom coveo_testing.logging import assert_logging\n\nwith assert_logging(\n        logging.getLogger(\'logger-name\'),\n        present=[\'evidence1\', \'evidence2\'], \n        absent=[...], \n        level=logging.WARN):\n    ...\n```\n\n\n# Human-readable (but still customizable) display for parametrized tests\n\nIf you\'re like me, you typed `@pytest.mark.parametrize` wrong a couple of times!\n\nEnable IDE completion by using this one instead:\n\n```python\nfrom coveo_testing.parametrize import parametrize\n\n@parametrize(\'var\', (True, False))\ndef test_var(var: bool) -> None:\n    ...\n```\n\nIt has one difference vs the pytest one, and it\'s the way it formats the "parameter name" for each iteration of the test.\n\nPytest will skip a lot of types and will simply name your test "var0", "var1" and so on.\nUsing this `@parametrize` instead, the variable\'s content will be inspected:\n\n```python\nfrom typing import Any\nfrom coveo_testing.parametrize import parametrize\nimport pytest\n\n\nclass StrMe:\n    def __init__(self, var: Any) -> None:\n      self.var = var\n      \n    def __str__(self) -> str:\n      return f"Value: {self.var}"\n\n\n@parametrize(\'var\', [[\'list\', \'display\'], [StrMe(\'hello\')]])\ndef test_param(var: bool) -> None:\n    ...\n\n@pytest.mark.parametrize(\'var\', [[\'list\', \'display\'], [StrMe(\'hello\')]])\ndef test_param_from_pytest(var: bool) -> None:\n    ...\n```\n\nIf you run `pytest --collect-only` you will obtain the following:\n```\n    <Function test_param[list-display]>\n    <Function test_param[Value: hello]>\n    <Function test_param_from_pytest[var0]>\n    <Function test_param_from_pytest[var1]>\n```\n\n\n# Refactorable mock targets\n\n## Demo\n\nConsider this common piece of code:\n\n```python\nfrom unittest.mock import patch, MagicMock\n\n@patch("mymodule.clients.APIClient._do_request")\ndef test(api_client_mock: MagicMock) -> None:\n    ...\n```\n\nBecause the mock target is a string, it makes it difficult to move things around without breaking the tests. You need a\ntool that can extract the string representation of a python objet. This is what `ref` was built for:\n\n```python\nfrom unittest.mock import patch, MagicMock\nfrom coveo_testing.mocks import ref\nfrom mymodule.clients import APIClient\n\n@patch(*ref(APIClient._do_request))\ndef test(api_client_mock: MagicMock) -> None:\n    ...\n```\n\nðŸš€ This way, you can rename or move `mymodule`, `clients`, `APIClient` or even `_do_request`, and your IDE should find\nthese and adjust them just like any other reference in your project.\n\nLet\'s examine a more complex example:\n\n```python\nfrom unittest.mock import patch, MagicMock\nfrom mymodule.tasks import process\n\n@patch("mymodule.tasks.get_api_client")\ndef test(get_api_client_mock: MagicMock) -> None:\n    assert process() is None  # pretend this tests the process function\n```\n\nThe interesting thing in this example is that we\'re mocking `get_api_client` in the `tasks` module. \nLet\'s take a look at the `tasks` module:\n\n```python\nfrom typing import Optional\nfrom mymodule.clients import get_api_client\n\ndef process() -> Optional[bool]:\n    client = get_api_client()\n    return ...\n```\n\nAs we can see, `get_api_client` is defined in another module.\nThe test needs to patch the function _in the tasks module_ since that\'s the context it will be called from. \nUnfortunately, inspecting `get_api_client` from the `tasks` module at runtime leads us back to `mymodule.clients`.\n\nThis single complexity means that hardcoding the context `mymodule.tasks` and symbol `get_api_client` into a string\nfor the patch is the straightforward solution.\n\nBut with `ref`, you specify the context separately:\n\n```python\nfrom unittest.mock import patch, MagicMock\nfrom coveo_testing.mocks import ref\nfrom mymodule.clients import get_api_client\nfrom mymodule.tasks import process\n\n\n@patch(*ref(get_api_client, context=process))\ndef test(get_api_client_mock: MagicMock) -> None:\n    assert process() is None  # pretend this tests the process function\n```\n\nðŸš€ By giving a context to `ref`, the symbol `get_api_client` will be resolved from the context of `process`, which is the\n`mymodule.tasks` module. The result is `mymodule.tasks.get_api_client`.\n\nIf either objects (`get_api_client` or `process`) are moved or renamed using a refactoring tool, the mock will still\npoint to the correct name and context.\n\nðŸš€ And a nice bonus is that your IDE can jump to `get_api_client`\'s definition from the test file now!\n\nIt should be noted that this isn\'t just some string manipulation. `ref` will import and inspect modules and objects\nto make sure that they\'re correct. Here\'s a more complex case with a renamed symbol:\n\nThe module:\n\n```python\nfrom typing import Optional\nfrom mymodule.clients import get_api_client as client_factory  # it got renamed! ðŸ˜±\n\ndef process() -> Optional[bool]:\n    client = client_factory()\n    return ...\n```\n\nThe test:\n\n```python\nfrom unittest.mock import patch, MagicMock\nfrom coveo_testing.mocks import ref\nfrom mymodule.clients import get_api_client\nfrom mymodule.tasks import process\n\n\n@patch(*ref(get_api_client, context=process))\ndef test(get_api_client_mock: MagicMock) -> None:\n    assert process() is None  # pretend this tests the process function\n```\n\nNotice how the test and patch did not change despite the renamed symbol?\n\nðŸš€ This is because `ref` will find `get_api_client` as `client_factory` when inspecting `mymodule.tasks` module,\nand return `mymodule.tasks.client_factory`.\n\nWe can also use ref with `patch.object()` in order to patch a single instance. Consider the following code:\n\n```python\nfrom unittest.mock import patch\nfrom mymodule.clients import APIClient\n\ndef test() -> None:\n    client = APIClient()\n    with patch.object(client, "_do_request"):\n        ...\n```\n\nðŸš€ By specifying `obj=True` to `ref`, you will obtain a `Tuple[instance, attribute_to_patch_as_a_string]` that you\ncan unpack to `patch.object()`:\n\n```python\nfrom unittest.mock import patch\nfrom coveo_testing.mocks import ref\nfrom mymodule.clients import APIClient\n\ndef test() -> None:\n    client = APIClient()\n    with patch.object(*ref(client._do_request, obj=True)):\n        ...\n```\n\nPlease refer to the docstring of `ref` for argument usage information.\n\n## Common Mock Recipes\n\n### Mock something globally without context\n#### Option 1: by leveraging the import mechanism\n\nTo mock something globally without regards for the context, it has to be accessed through a dot `.` by the context.\n\nFor instance, consider this test:\n\n```python\nfrom http.client import HTTPResponse\nfrom unittest.mock import patch, MagicMock\nfrom coveo_testing.mocks import ref\n\nfrom mymodule.tasks import process\n\n\n@patch(*ref(HTTPResponse.close))\ndef test(http_response_close_mock: MagicMock) -> None:\n    assert process()\n```\n\nThe target is `HTTPResponse.close`, which lives in the `http.client` module.\nThe contextof the test is the `process` function, which lives in the `mymodule.tasks` module.\nLet\'s take a look at `mymodule.tasks`\'s source code:\n\n\n```python\nfrom http import client\n\ndef process() -> bool:\n    _ = client.HTTPResponse(...)  # of course this is fake, but serves the example\n    return ...\n```\n\nSince `mymodule.tasks` reaches `HTTPResponse` through a dot (i.e.: `client.HTTPResponse`), we can patch `HTTPResponse`\nwithout using `mymodule.tasks` as the context.\n\nHowever, if `mymodule.tasks` was written like this:\n\n```python\nfrom http.client import HTTPResponse\n\ndef process() -> bool:\n    _ = HTTPResponse(...)\n    return ...\n```\n\nThen the patch would not affect the object used by the `process` function anymore. However, it would affect any other \nmodule that uses the dot to reach `HTTPResponse` since the patch was _still_ applied globally.\n \n\n#### Option 2: By wrapping a hidden function\n\nAnother approach to mocking things globally is to hide a function behind another, and mock the hidden function.\nThis allows modules to use whatever import style they want, and the mocks become straightforward to setup.\n\nPretend this is `mymodule.clients`:\n\n```python\nclass APIClient:\n    ...\n\ndef get_api_client() -> APIClient:\n    return _get_api_client()\n\ndef _get_api_client() -> APIClient:\n    return APIClient()\n```\n\nAnd this is `mymodule.tasks`:\n\n```python\nfrom mymodule.clients import get_api_client\n\ndef process() -> bool:\n    return get_api_client() is not None\n```\n\nSo you _know_ this works globally, because no one will (should?) import the private one except the test:\n\n```python\nfrom unittest.mock import patch, MagicMock\nfrom coveo_testing.mocks import ref\n\nfrom mymodule.tasks import process\nfrom mymodule.clients import _get_api_client\n\n\n@patch(*ref(_get_api_client))\ndef test(api_client_mock: MagicMock) -> None:\n    assert process()\n```\n\n\n### Mock something for a given context\n\nWhen you want to mock something for a given module, you must provide a hint to `ref` as the `context` argument.\n\nThe hint may be a module, or a function/class defined within that module. "Defined" here means that "def" or "class" \nwas used _in that module_. If the hint was imported into the module, it will not work:\n\n`mymodule.tasks`:\n\n```python\nfrom mymodule.clients import get_api_client\n\ndef process() -> bool:\n    client = get_api_client()\n    return ...\n```\n\nThe test, showing 3 different methods that work:\n\n```python\nfrom unittest.mock import patch, MagicMock\nfrom coveo_testing.mocks import ref\n\nfrom mymodule.clients import get_api_client\nfrom mymodule.tasks import process\n\n# you can pass the module as the context\nimport mymodule\n\n@patch(*ref(get_api_client, context=mymodule.tasks))\ndef test(get_api_client_mock: MagicMock) -> None:\n    assert process()\n\n# you can pass the module as the context, version 2\nfrom mymodule import tasks\n    \n@patch(*ref(get_api_client, context=tasks))\ndef test(get_api_client_mock: MagicMock) -> None:\n    assert process()\n\n# you can also pass a function or a class defined in the `tasks` module\nfrom mymodule.tasks import process\n@patch(*ref(get_api_client, context=process))\ndef test(get_api_client_mock: MagicMock) -> None:\n    assert process()\n```\n\nThe 3rd method is encouraged: provide the function or class that is actually using the `get_api_client` import.\nIn our example, that\'s the `process` function.\nIf `process` was ever moved to a different module, it would carry the `get_api_client` import, and the mock would\nbe automatically adjusted to target `process`\'s new module without changes.\n\n### Mock something for the current context\n\nSometimes, the test file _is_ the context. When that happens, just pass `__name__` as the context:\n\n```python\nfrom unittest.mock import patch\nfrom coveo_testing.mocks import ref\nfrom mymodule.clients import get_api_client, APIClient\n\ndef _prepare_test() -> APIClient:\n    client = get_api_client()\n    ...\n    return client\n    \n@patch(*ref(get_api_client, context=__name__))\ndef test() -> None:\n    client = _prepare_test()\n    ...\n```\n\n\n### Mock a method on a class\n\nSince a method cannot be imported and can only be accessed through the use of a dot `.` on a class or instance, \nyou can always patch methods globally:\n\n```python\nwith patch(*ref(MyClass.fn)): ...\n```\n\nThis is because no module can import `fn`; it has to go through an import of `MyClass`.\n\n### Mock a method on one instance of a class\n\nSimply add `obj=True` and use `patch.object()`:\n\n```python\nwith patch.object(*ref(instance.fn, obj=True)): ...\n```\n\n\n### Mock an attribute on a class/instance/module/function/object/etc\n\n`ref` cannot help with this task:\n- You cannot refer an attribute that exists (you would pass the value, not a reference)\n- You cannot refer an attribute that doesn\'t exist (because it doesn\'t exist!)\n\nFor this, there\'s no going around hardcoding the attribute name in a string:\n\n```python\nclass MyClass:\n    def __init__(self) -> None:\n        self.a = 1\n\n\ndef test_attr() -> None:\n    instance = MyClass()\n    with patch.object(instance, "a", new=2):\n        assert instance.a == 2\n        assert MyClass().a == 1\n```\n\nThis sometimes work when patching **instances**. \nThe example works because `a` is a simple attribute that lives in `instance.__dict__` and `patch.object` knows\nabout that.\n\nBut if you tried to patch `MyClass` instead of `instance`, `mock.patch` would complain that there\'s no \nsuch thing as `a` over there.\nThus, patching an attribute globally will most likely result in a lot of wasted time, and should be avoided.\n\nThere\'s no way to make the example work with `ref` because there\'s no way to refer `instance.a` without actually\ngetting the value of `a`, unless we hardcode a string, which defeats the purpose of `ref` completely.\n\n\n### Mock a property\n\nYou can only patch a property globally, through its class:\n\n```python\nclass MyClass:\n    @property\n    def get(self) -> bool:\n        return False\n```\n\n```python\nfrom unittest.mock import PropertyMock, patch, MagicMock\nfrom coveo_testing.mocks import ref\n\nfrom mymodule import MyClass\n\n@patch(*ref(MyClass.get), new_callable=PropertyMock, return_value=True)\ndef test(my_class_get_mock: MagicMock) -> None:\n    assert MyClass().get == True\n    my_class_get_mock.assert_called_once()\n```\n\nYou **cannot** patch a property on an instance, this is a limitation of `unittest.mock` because of the way\nproperties work.\nIf you try, `mock.patch.object()` will complain that the property is read only.\n\n\n### Mock a classmethod or staticmethod on a specific instance\n\nWhen inspecting these special methods on an instance, `ref` ends up finding the class instead of the instance.\n\nTherefore, `ref` is unable to return a `Tuple[instance, function_name]`.\nIt would return `Tuple[class, function_name]`, resulting in a global patch. ðŸ˜±\n\nBut `ref` will detect this mistake, and will raise a helpful exception if it cannot return an instance when you\nspecified `obj=True`.\n\nFor this particular scenario, the workaround is to provide the instance as the context:\n\n```python\nfrom unittest.mock import patch\nfrom coveo_testing.mocks import ref\n\n\nclass MyClass:\n    @staticmethod\n    def get() -> bool:\n        return False\n\n    \ndef test() -> None:\n    instance = MyClass()\n    with patch.object(*ref(instance.get, context=instance, obj=True)) as fn_mock:\n        assert instance.get == True\n        assert MyClass().get == False  # new instances are not affected by the object mock\n        fn_mock.assert_called_once()\n```\n\nSome may prefer a more semantically-correct version by specifying the target through the class instead of the \ninstance. In the end, these are all equivalent:\n\n```python\nwith patch.object(instance, "get"): \n    ...\n\nwith patch.object(*ref(instance.get, context=instance, obj=True)): \n    ...\n\nwith patch.object(*ref(MockClass.get, context=instance, obj=True)): \n    ...\n```\n\nIn this case, the version without ref is much shorter and arguably more pleasant for the eye, but `get` can no longer\nbe renamed without altering the tests.\n',
    'author': 'Jonathan PichÃ©',
    'author_email': 'tools@coveo.com',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'https://github.com/coveooss/coveo-python-oss/tree/main/coveo-testing',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.8',
}


setup(**setup_kwargs)
